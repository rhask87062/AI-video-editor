{"version":3,"file":"index.js","sources":["../src/slash-plugin.ts","../src/slash-provider.ts"],"sourcesContent":["import type { SliceType } from '@milkdown/ctx'\nimport type { PluginSpec } from '@milkdown/prose/state'\nimport type { $Ctx, $Prose } from '@milkdown/utils'\n\nimport { Plugin, PluginKey } from '@milkdown/prose/state'\nimport { $ctx, $prose } from '@milkdown/utils'\n\n/// @internal\nexport type SlashPluginSpecId<Id extends string> = `${Id}_SLASH_SPEC`\n\n/// @internal\nexport type SlashPlugin<Id extends string, State = any> = [\n  $Ctx<PluginSpec<State>, SlashPluginSpecId<Id>>,\n  $Prose,\n] & {\n  key: SliceType<PluginSpec<State>, SlashPluginSpecId<Id>>\n  pluginKey: $Prose['key']\n}\n\n/// Create a slash plugin with a unique id.\nexport function slashFactory<Id extends string, State = any>(id: Id) {\n  const slashSpec = $ctx<PluginSpec<State>, SlashPluginSpecId<Id>>(\n    {},\n    `${id}_SLASH_SPEC`\n  )\n  const slashPlugin = $prose((ctx) => {\n    const spec = ctx.get(slashSpec.key)\n    return new Plugin({\n      key: new PluginKey(`${id}_SLASH`),\n      ...spec,\n    })\n  })\n  const result = [slashSpec, slashPlugin] as SlashPlugin<Id>\n  result.key = slashSpec.key\n  result.pluginKey = slashPlugin.key\n  slashSpec.meta = {\n    package: '@milkdown/plugin-slash',\n    displayName: `Ctx<slashSpec>|${id}`,\n  }\n  slashPlugin.meta = {\n    package: '@milkdown/plugin-slash',\n    displayName: `Prose<slash>|${id}`,\n  }\n\n  return result\n}\n","import type {\n  ComputePositionConfig,\n  Middleware,\n  OffsetOptions,\n  VirtualElement,\n} from '@floating-ui/dom'\nimport type { Node } from '@milkdown/prose/model'\nimport type { EditorState } from '@milkdown/prose/state'\nimport type { EditorView } from '@milkdown/prose/view'\n\nimport { computePosition, flip, offset } from '@floating-ui/dom'\nimport { findParentNode, posToDOMRect } from '@milkdown/prose'\nimport { TextSelection } from '@milkdown/prose/state'\nimport debounce from 'lodash.debounce'\n\n/// Options for slash provider.\nexport interface SlashProviderOptions {\n  /// The slash content.\n  content: HTMLElement\n  /// The debounce time for updating slash, 200ms by default.\n  debounce?: number\n  /// The function to determine whether the tooltip should be shown.\n  shouldShow?: (view: EditorView, prevState?: EditorState) => boolean\n  /// The key trigger for shouldShow, '/' by default.\n  trigger?: string | string[]\n  /// The offset to get the block. Default is 0.\n  offset?: OffsetOptions\n  /// Other middlewares for floating ui. This will be added after the internal middlewares.\n  middleware?: Middleware[]\n  /// Options for floating ui. If you pass `middleware` or `placement`, it will override the internal settings.\n  floatingUIOptions?: Partial<ComputePositionConfig>\n  /// The root element that the slash will be appended to.\n  root?: HTMLElement\n}\n\n/// A provider for creating slash.\nexport class SlashProvider {\n  /// The root element of the slash.\n  element: HTMLElement\n\n  /// @internal\n  #initialized = false\n\n  /// @internal\n  readonly #middleware: Middleware[]\n\n  /// @internal\n  readonly #floatingUIOptions: Partial<ComputePositionConfig>\n\n  /// @internal\n  readonly #root?: HTMLElement\n\n  /// @internal\n  readonly #debounce: number\n\n  /// @internal\n  readonly #trigger: string | string[]\n\n  /// @internal\n  readonly #shouldShow: (view: EditorView, prevState?: EditorState) => boolean\n\n  /// The offset to get the block. Default is 0.\n  readonly #offset?: OffsetOptions\n\n  /// On show callback.\n  onShow = () => {}\n\n  /// On hide callback.\n  onHide = () => {}\n\n  constructor(options: SlashProviderOptions) {\n    this.element = options.content\n    this.#debounce = options.debounce ?? 200\n    this.#shouldShow = options.shouldShow ?? this.#_shouldShow\n    this.#trigger = options.trigger ?? '/'\n    this.#offset = options.offset\n    this.#middleware = options.middleware ?? []\n    this.#floatingUIOptions = options.floatingUIOptions ?? {}\n    this.#root = options.root\n  }\n\n  /// @internal\n  #onUpdate = (view: EditorView, prevState?: EditorState): void => {\n    const { state, composing } = view\n    const { selection, doc } = state\n    const { ranges } = selection\n    const from = Math.min(...ranges.map((range) => range.$from.pos))\n    const to = Math.max(...ranges.map((range) => range.$to.pos))\n    const isSame =\n      prevState && prevState.doc.eq(doc) && prevState.selection.eq(selection)\n\n    if (!this.#initialized) {\n      const root = this.#root ?? view.dom.parentElement ?? document.body\n      root.appendChild(this.element)\n      this.#initialized = true\n    }\n\n    if (composing || isSame) return\n\n    if (!this.#shouldShow(view, prevState)) {\n      this.hide()\n      return\n    }\n\n    const virtualEl: VirtualElement = {\n      getBoundingClientRect: () => posToDOMRect(view, from, to),\n    }\n    computePosition(virtualEl, this.element, {\n      placement: 'bottom-start',\n      middleware: [flip(), offset(this.#offset), ...this.#middleware],\n      ...this.#floatingUIOptions,\n    })\n      .then(({ x, y }) => {\n        Object.assign(this.element.style, {\n          left: `${x}px`,\n          top: `${y}px`,\n        })\n      })\n      .catch(console.error)\n\n    this.show()\n  }\n\n  /// @internal\n  #_shouldShow(view: EditorView): boolean {\n    const currentTextBlockContent = this.getContent(view)\n\n    if (!currentTextBlockContent) return false\n\n    const target = currentTextBlockContent.at(-1)\n\n    if (!target) return false\n\n    return Array.isArray(this.#trigger)\n      ? this.#trigger.includes(target)\n      : this.#trigger === target\n  }\n\n  /// Update provider state by editor view.\n  update = (view: EditorView, prevState?: EditorState): void => {\n    const updater = debounce(this.#onUpdate, this.#debounce)\n\n    updater(view, prevState)\n  }\n\n  /// Get the content of the current text block.\n  /// Pass the `matchNode` function to determine whether the current node should be matched, by default, it will match the paragraph node.\n  getContent = (\n    view: EditorView,\n    matchNode: (node: Node) => boolean = (node) =>\n      node.type.name === 'paragraph'\n  ): string | undefined => {\n    const { selection } = view.state\n    const { empty, $from } = selection\n    const isTextBlock = view.state.selection instanceof TextSelection\n\n    const isSlashChildren = this.element.contains(document.activeElement)\n\n    const notHasFocus = !view.hasFocus() && !isSlashChildren\n\n    const isReadonly = !view.editable\n\n    const paragraph = findParentNode(matchNode)(view.state.selection)\n\n    const isNotInParagraph = !paragraph\n\n    if (notHasFocus || isReadonly || !empty || !isTextBlock || isNotInParagraph)\n      return\n\n    return $from.parent.textBetween(\n      Math.max(0, $from.parentOffset - 500),\n      $from.parentOffset,\n      undefined,\n      '\\uFFFC'\n    )\n  }\n\n  /// Destroy the slash.\n  destroy = () => {}\n\n  /// Show the slash.\n  show = () => {\n    this.element.dataset.show = 'true'\n    this.onShow()\n  }\n\n  /// Hide the slash.\n  hide = () => {\n    this.element.dataset.show = 'false'\n    this.onHide()\n  }\n}\n"],"names":[],"mappings":"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"}