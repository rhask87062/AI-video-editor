var __typeError = (msg) => {
  throw TypeError(msg);
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var _initialized, _middleware, _floatingUIOptions, _root, _debounce, _trigger, _shouldShow, _offset, _onUpdate, _SlashProvider_instances, _shouldShow_fn;
import { Plugin, PluginKey, TextSelection } from "@milkdown/prose/state";
import { $ctx, $prose } from "@milkdown/utils";
import { computePosition, flip, offset } from "@floating-ui/dom";
import { posToDOMRect, findParentNode } from "@milkdown/prose";
import debounce from "lodash.debounce";
function slashFactory(id) {
  const slashSpec = $ctx(
    {},
    `${id}_SLASH_SPEC`
  );
  const slashPlugin = $prose((ctx) => {
    const spec = ctx.get(slashSpec.key);
    return new Plugin({
      key: new PluginKey(`${id}_SLASH`),
      ...spec
    });
  });
  const result = [slashSpec, slashPlugin];
  result.key = slashSpec.key;
  result.pluginKey = slashPlugin.key;
  slashSpec.meta = {
    package: "@milkdown/plugin-slash",
    displayName: `Ctx<slashSpec>|${id}`
  };
  slashPlugin.meta = {
    package: "@milkdown/plugin-slash",
    displayName: `Prose<slash>|${id}`
  };
  return result;
}
class SlashProvider {
  constructor(options) {
    __privateAdd(this, _SlashProvider_instances);
    __privateAdd(this, _initialized);
    /// @internal
    __privateAdd(this, _middleware);
    /// @internal
    __privateAdd(this, _floatingUIOptions);
    /// @internal
    __privateAdd(this, _root);
    /// @internal
    __privateAdd(this, _debounce);
    /// @internal
    __privateAdd(this, _trigger);
    /// @internal
    __privateAdd(this, _shouldShow);
    /// The offset to get the block. Default is 0.
    __privateAdd(this, _offset);
    __privateAdd(this, _onUpdate);
    __privateSet(this, _initialized, false);
    this.onShow = () => {
    };
    this.onHide = () => {
    };
    __privateSet(this, _onUpdate, (view, prevState) => {
      const { state, composing } = view;
      const { selection, doc } = state;
      const { ranges } = selection;
      const from = Math.min(...ranges.map((range) => range.$from.pos));
      const to = Math.max(...ranges.map((range) => range.$to.pos));
      const isSame = prevState && prevState.doc.eq(doc) && prevState.selection.eq(selection);
      if (!__privateGet(this, _initialized)) {
        const root = __privateGet(this, _root) ?? view.dom.parentElement ?? document.body;
        root.appendChild(this.element);
        __privateSet(this, _initialized, true);
      }
      if (composing || isSame) return;
      if (!__privateGet(this, _shouldShow).call(this, view, prevState)) {
        this.hide();
        return;
      }
      const virtualEl = {
        getBoundingClientRect: () => posToDOMRect(view, from, to)
      };
      computePosition(virtualEl, this.element, {
        placement: "bottom-start",
        middleware: [flip(), offset(__privateGet(this, _offset)), ...__privateGet(this, _middleware)],
        ...__privateGet(this, _floatingUIOptions)
      }).then(({ x, y }) => {
        Object.assign(this.element.style, {
          left: `${x}px`,
          top: `${y}px`
        });
      }).catch(console.error);
      this.show();
    });
    this.update = (view, prevState) => {
      const updater = debounce(__privateGet(this, _onUpdate), __privateGet(this, _debounce));
      updater(view, prevState);
    };
    this.getContent = (view, matchNode = (node) => node.type.name === "paragraph") => {
      const { selection } = view.state;
      const { empty, $from } = selection;
      const isTextBlock = view.state.selection instanceof TextSelection;
      const isSlashChildren = this.element.contains(document.activeElement);
      const notHasFocus = !view.hasFocus() && !isSlashChildren;
      const isReadonly = !view.editable;
      const paragraph = findParentNode(matchNode)(view.state.selection);
      const isNotInParagraph = !paragraph;
      if (notHasFocus || isReadonly || !empty || !isTextBlock || isNotInParagraph)
        return;
      return $from.parent.textBetween(
        Math.max(0, $from.parentOffset - 500),
        $from.parentOffset,
        void 0,
        "ï¿¼"
      );
    };
    this.destroy = () => {
    };
    this.show = () => {
      this.element.dataset.show = "true";
      this.onShow();
    };
    this.hide = () => {
      this.element.dataset.show = "false";
      this.onHide();
    };
    this.element = options.content;
    __privateSet(this, _debounce, options.debounce ?? 200);
    __privateSet(this, _shouldShow, options.shouldShow ?? __privateMethod(this, _SlashProvider_instances, _shouldShow_fn));
    __privateSet(this, _trigger, options.trigger ?? "/");
    __privateSet(this, _offset, options.offset);
    __privateSet(this, _middleware, options.middleware ?? []);
    __privateSet(this, _floatingUIOptions, options.floatingUIOptions ?? {});
    __privateSet(this, _root, options.root);
  }
}
_initialized = new WeakMap();
_middleware = new WeakMap();
_floatingUIOptions = new WeakMap();
_root = new WeakMap();
_debounce = new WeakMap();
_trigger = new WeakMap();
_shouldShow = new WeakMap();
_offset = new WeakMap();
_onUpdate = new WeakMap();
_SlashProvider_instances = new WeakSet();
/// @internal
_shouldShow_fn = function(view) {
  const currentTextBlockContent = this.getContent(view);
  if (!currentTextBlockContent) return false;
  const target = currentTextBlockContent.at(-1);
  if (!target) return false;
  return Array.isArray(__privateGet(this, _trigger)) ? __privateGet(this, _trigger).includes(target) : __privateGet(this, _trigger) === target;
};
export {
  SlashProvider,
  slashFactory
};
//# sourceMappingURL=index.js.map
