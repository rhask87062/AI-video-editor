import { codeBlockConfig } from '@milkdown/kit/component/code-block';
import katex from 'katex';
import { F as FeaturesCtx, C as CrepeFeature } from './index-B4c2Fujg.js';
import { c as confirmIcon } from './confirm-DtE-HkVd.js';
import { codeBlockSchema } from '@milkdown/kit/preset/commonmark';
import { a as mathInlineId, m as mathInlineSchema } from './inline-latex-C9IGAXXQ.js';
import { tooltipFactory, TooltipProvider } from '@milkdown/kit/plugin/tooltip';
import { redo, undo } from '@milkdown/kit/prose/history';
import { keymap } from '@milkdown/kit/prose/keymap';
import { Schema } from '@milkdown/kit/prose/model';
import { NodeSelection, EditorState } from '@milkdown/kit/prose/state';
import { EditorView } from '@milkdown/kit/prose/view';
import { defineComponent, h, shallowRef, createApp } from 'vue';
import { Icon } from '@milkdown/kit/component';
import { nodeRule } from '@milkdown/kit/prose';
import { textblockTypeInputRule } from '@milkdown/kit/prose/inputrules';
import { $inputRule, $remark } from '@milkdown/kit/utils';
import remarkMath from 'remark-math';
import { visit } from 'unist-util-visit';
import '@milkdown/kit/core';
import '@milkdown/kit/plugin/clipboard';
import '@milkdown/kit/plugin/history';
import '@milkdown/kit/plugin/indent';
import '@milkdown/kit/plugin/listener';
import '@milkdown/kit/plugin/trailing';
import '@milkdown/kit/preset/gfm';
import '@milkdown/kit/ctx';

const blockLatexSchema = codeBlockSchema.extendSchema((prev) => {
  return (ctx) => {
    const baseSchema = prev(ctx);
    return {
      ...baseSchema,
      toMarkdown: {
        match: baseSchema.toMarkdown.match,
        runner: (state, node) => {
          var _a, _b;
          const language = (_a = node.attrs.language) != null ? _a : "";
          if (language.toLowerCase() === "latex") {
            state.addNode(
              "math",
              void 0,
              ((_b = node.content.firstChild) == null ? void 0 : _b.text) || ""
            );
          } else {
            return baseSchema.toMarkdown.runner(state, node);
          }
        }
      }
    };
  };
});

const inlineLatexTooltip = tooltipFactory("INLINE_LATEX");

const LatexTooltip = defineComponent({
  props: {
    config: {
      type: Object,
      required: true
    },
    innerView: {
      type: Object,
      required: true
    },
    updateValue: {
      type: Object,
      required: true
    }
  },
  setup(props) {
    const innerViewRef = (el) => {
      if (!el || !(el instanceof HTMLElement)) return;
      while (el.firstChild) {
        el.removeChild(el.firstChild);
      }
      if (props.innerView.value) {
        el.appendChild(props.innerView.value.dom);
      }
    };
    const onUpdate = (e) => {
      e.preventDefault();
      props.updateValue.value();
    };
    return () => {
      var _a, _b;
      return /* @__PURE__ */ h("div", { class: "container" }, props.innerView && /* @__PURE__ */ h("div", { ref: innerViewRef }), /* @__PURE__ */ h("button", { onPointerdown: onUpdate }, /* @__PURE__ */ h(Icon, { icon: (_b = (_a = props.config).inlineEditConfirm) == null ? void 0 : _b.call(_a) })));
    };
  }
});

var __typeError = (msg) => {
  throw TypeError(msg);
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), member.set(obj, value), value);
var _content, _provider, _dom, _innerView, _updateValue, _app, _onHide, _shouldShow;
class LatexInlineTooltip {
  constructor(ctx, view, config) {
    this.ctx = ctx;
    __privateAdd(this, _content);
    __privateAdd(this, _provider);
    __privateAdd(this, _dom);
    __privateAdd(this, _innerView, shallowRef(null));
    __privateAdd(this, _updateValue, shallowRef(() => {
    }));
    __privateAdd(this, _app);
    __privateAdd(this, _onHide, () => {
      if (__privateGet(this, _innerView).value) {
        __privateGet(this, _innerView).value.destroy();
        __privateGet(this, _innerView).value = null;
      }
    });
    __privateAdd(this, _shouldShow, (view) => {
      const shouldShow = () => {
        const { selection, schema } = view.state;
        if (selection.empty) return false;
        if (!(selection instanceof NodeSelection)) return false;
        const node = selection.node;
        if (node.type.name !== mathInlineId) return false;
        const textFrom = selection.from;
        const paragraph = schema.nodes.paragraph.create(
          null,
          schema.text(node.attrs.value)
        );
        const innerView = new EditorView(__privateGet(this, _dom), {
          state: EditorState.create({
            doc: paragraph,
            schema: new Schema({
              nodes: {
                doc: {
                  content: "block+"
                },
                paragraph: {
                  content: "inline*",
                  group: "block",
                  parseDOM: [{ tag: "p" }],
                  toDOM() {
                    return ["p", 0];
                  }
                },
                text: {
                  group: "inline"
                }
              }
            }),
            plugins: [
              keymap({
                "Mod-z": undo,
                "Mod-Z": redo,
                "Mod-y": redo,
                Enter: () => {
                  __privateGet(this, _updateValue).value();
                  return true;
                }
              })
            ]
          })
        });
        __privateGet(this, _innerView).value = innerView;
        __privateGet(this, _updateValue).value = () => {
          const { tr } = view.state;
          tr.setNodeAttribute(textFrom, "value", innerView.state.doc.textContent);
          view.dispatch(tr);
          requestAnimationFrame(() => {
            view.focus();
          });
        };
        return true;
      };
      const show = shouldShow();
      if (!show) __privateGet(this, _onHide).call(this);
      return show;
    });
    this.update = (view, prevState) => {
      __privateGet(this, _provider).update(view, prevState);
    };
    this.destroy = () => {
      __privateGet(this, _app).unmount();
      __privateGet(this, _provider).destroy();
      __privateGet(this, _content).remove();
    };
    const content = document.createElement("div");
    content.className = "milkdown-latex-inline-edit";
    __privateSet(this, _content, content);
    __privateSet(this, _app, createApp(LatexTooltip, {
      config,
      innerView: __privateGet(this, _innerView),
      updateValue: __privateGet(this, _updateValue)
    }));
    __privateGet(this, _app).mount(content);
    __privateSet(this, _provider, new TooltipProvider({
      debounce: 0,
      content: __privateGet(this, _content),
      shouldShow: __privateGet(this, _shouldShow),
      offset: 10,
      floatingUIOptions: {
        placement: "bottom"
      }
    }));
    __privateGet(this, _provider).update(view);
    __privateSet(this, _dom, document.createElement("div"));
  }
}
_content = new WeakMap();
_provider = new WeakMap();
_dom = new WeakMap();
_innerView = new WeakMap();
_updateValue = new WeakMap();
_app = new WeakMap();
_onHide = new WeakMap();
_shouldShow = new WeakMap();

const mathInlineInputRule = $inputRule(
  (ctx) => nodeRule(/(?:\$)([^$]+)(?:\$)$/, mathInlineSchema.type(ctx), {
    getAttr: (match) => {
      var _a;
      return {
        value: (_a = match[1]) != null ? _a : ""
      };
    }
  })
);
const mathBlockInputRule = $inputRule(
  (ctx) => textblockTypeInputRule(/^\$\$[\s\n]$/, codeBlockSchema.type(ctx), () => ({
    language: "LaTeX"
  }))
);

const remarkMathPlugin = $remark(
  "remarkMath",
  () => remarkMath
);
function visitMathBlock(ast) {
  return visit(
    ast,
    "math",
    (node, index, parent) => {
      const { value } = node;
      const newNode = {
        type: "code",
        lang: "LaTeX",
        value
      };
      parent.children.splice(index, 1, newNode);
    }
  );
}
const remarkMathBlockPlugin = $remark(
  "remarkMathBlock",
  () => () => visitMathBlock
);

const defineFeature = (editor, config) => {
  editor.config((ctx) => {
    const flags = ctx.get(FeaturesCtx);
    const isCodeMirrorEnabled = flags.includes(CrepeFeature.CodeMirror);
    if (!isCodeMirrorEnabled) {
      throw new Error("You need to enable CodeMirror to use LaTeX feature");
    }
    ctx.update(codeBlockConfig.key, (prev) => ({
      ...prev,
      renderPreview: (language, content) => {
        if (language.toLowerCase() === "latex" && content.length > 0) {
          return renderLatex(content, config == null ? void 0 : config.katexOptions);
        }
        const renderPreview = prev.renderPreview;
        return renderPreview(language, content);
      }
    }));
    ctx.set(inlineLatexTooltip.key, {
      view: (view) => {
        var _a;
        return new LatexInlineTooltip(ctx, view, {
          inlineEditConfirm: (_a = config == null ? void 0 : config.inlineEditConfirm) != null ? _a : () => confirmIcon,
          ...config
        });
      }
    });
  }).use(remarkMathPlugin).use(remarkMathBlockPlugin).use(mathInlineSchema).use(inlineLatexTooltip).use(mathInlineInputRule).use(mathBlockInputRule).use(blockLatexSchema);
};
function renderLatex(content, options) {
  const html = katex.renderToString(content, {
    ...options,
    throwOnError: false,
    displayMode: true
  });
  return html;
}

export { defineFeature };
//# sourceMappingURL=index-BrxoBVRs.js.map
