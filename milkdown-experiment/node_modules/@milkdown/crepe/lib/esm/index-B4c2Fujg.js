import { editorViewCtx, EditorStatus, Editor, rootCtx, defaultValueCtx, editorViewOptionsCtx } from '@milkdown/kit/core';
import { clipboard } from '@milkdown/kit/plugin/clipboard';
import { history } from '@milkdown/kit/plugin/history';
import { indentConfig, indent } from '@milkdown/kit/plugin/indent';
import { listenerCtx, listener } from '@milkdown/kit/plugin/listener';
import { trailing } from '@milkdown/kit/plugin/trailing';
import { commonmark } from '@milkdown/kit/preset/commonmark';
import { gfm } from '@milkdown/kit/preset/gfm';
import { getMarkdown } from '@milkdown/kit/utils';
import { createSlice } from '@milkdown/kit/ctx';

var CrepeFeature = /* @__PURE__ */ ((CrepeFeature2) => {
  CrepeFeature2["CodeMirror"] = "code-mirror";
  CrepeFeature2["ListItem"] = "list-item";
  CrepeFeature2["LinkTooltip"] = "link-tooltip";
  CrepeFeature2["Cursor"] = "cursor";
  CrepeFeature2["ImageBlock"] = "image-block";
  CrepeFeature2["BlockEdit"] = "block-edit";
  CrepeFeature2["Toolbar"] = "toolbar";
  CrepeFeature2["Placeholder"] = "placeholder";
  CrepeFeature2["Table"] = "table";
  CrepeFeature2["Latex"] = "latex";
  return CrepeFeature2;
})(CrepeFeature || {});
const defaultFeatures = {
  ["cursor" /* Cursor */]: true,
  ["list-item" /* ListItem */]: true,
  ["link-tooltip" /* LinkTooltip */]: true,
  ["image-block" /* ImageBlock */]: true,
  ["block-edit" /* BlockEdit */]: true,
  ["placeholder" /* Placeholder */]: true,
  ["toolbar" /* Toolbar */]: true,
  ["code-mirror" /* CodeMirror */]: true,
  ["table" /* Table */]: true,
  ["latex" /* Latex */]: true
};
async function loadFeature(feature, editor, config) {
  switch (feature) {
    case "code-mirror" /* CodeMirror */: {
      const { defineFeature } = await import('./index-C1aVAv1l.js');
      return defineFeature(editor, config);
    }
    case "list-item" /* ListItem */: {
      const { defineFeature } = await import('./index-E8UgFLeN.js');
      return defineFeature(editor, config);
    }
    case "link-tooltip" /* LinkTooltip */: {
      const { defineFeature } = await import('./index-BUBXHhHG.js');
      return defineFeature(editor, config);
    }
    case "image-block" /* ImageBlock */: {
      const { defineFeature } = await import('./index-ChR5Qhyf.js');
      return defineFeature(editor, config);
    }
    case "cursor" /* Cursor */: {
      const { defineFeature } = await import('./index-Bvz1Yyiz.js');
      return defineFeature(editor, config);
    }
    case "block-edit" /* BlockEdit */: {
      const { defineFeature } = await import('./index-CAdCl6lx.js');
      return defineFeature(editor, config);
    }
    case "placeholder" /* Placeholder */: {
      const { defineFeature } = await import('./index-BCvtgOeI.js');
      return defineFeature(editor, config);
    }
    case "toolbar" /* Toolbar */: {
      const { defineFeature } = await import('./index-CbE09OrS.js');
      return defineFeature(editor, config);
    }
    case "table" /* Table */: {
      const { defineFeature } = await import('./index-CwMVnVeI.js');
      return defineFeature(editor, config);
    }
    case "latex" /* Latex */: {
      const { defineFeature } = await import('./index-BrxoBVRs.js');
      return defineFeature(editor, config);
    }
  }
}

const FeaturesCtx = createSlice([], "FeaturesCtx");
const crepeCtx = createSlice({}, "CrepeCtx");
function configureFeatures(features) {
  return (ctx) => {
    ctx.inject(FeaturesCtx, features);
  };
}

var __typeError = (msg) => {
  throw TypeError(msg);
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), member.set(obj, value), value);
var _editor, _initPromise, _rootElement, _editable;
class Crepe {
  constructor({
    root,
    features = {},
    featureConfigs = {},
    defaultValue = ""
  }) {
    __privateAdd(this, _editor);
    __privateAdd(this, _initPromise);
    __privateAdd(this, _rootElement);
    __privateAdd(this, _editable, true);
    this.create = async () => {
      await __privateGet(this, _initPromise);
      return __privateGet(this, _editor).create();
    };
    this.destroy = async () => {
      await __privateGet(this, _initPromise);
      return __privateGet(this, _editor).destroy();
    };
    this.setReadonly = (value) => {
      __privateSet(this, _editable, !value);
      __privateGet(this, _editor).action((ctx) => {
        const view = ctx.get(editorViewCtx);
        view.setProps({
          editable: () => !value
        });
      });
      return this;
    };
    this.getMarkdown = () => {
      return __privateGet(this, _editor).action(getMarkdown());
    };
    this.on = (fn) => {
      if (__privateGet(this, _editor).status !== EditorStatus.Created) {
        __privateGet(this, _editor).config((ctx) => {
          const listener2 = ctx.get(listenerCtx);
          fn(listener2);
        });
        return this;
      }
      __privateGet(this, _editor).action((ctx) => {
        const listener2 = ctx.get(listenerCtx);
        fn(listener2);
      });
      return this;
    };
    var _a;
    const enabledFeatures = Object.entries({
      ...defaultFeatures,
      ...features
    }).filter(([, enabled]) => enabled).map(([feature]) => feature);
    __privateSet(this, _rootElement, (_a = typeof root === "string" ? document.querySelector(root) : root) != null ? _a : document.body);
    __privateSet(this, _editor, Editor.make().config((ctx) => {
      ctx.inject(crepeCtx, this);
    }).config(configureFeatures(enabledFeatures)).config((ctx) => {
      ctx.set(rootCtx, __privateGet(this, _rootElement));
      ctx.set(defaultValueCtx, defaultValue);
      ctx.set(editorViewOptionsCtx, {
        editable: () => __privateGet(this, _editable)
      });
      ctx.update(indentConfig.key, (value) => ({
        ...value,
        size: 4
      }));
    }).use(commonmark).use(listener).use(history).use(indent).use(trailing).use(clipboard).use(gfm));
    const promiseList = [];
    enabledFeatures.forEach((feature) => {
      const config = featureConfigs[feature];
      promiseList.push(loadFeature(feature, __privateGet(this, _editor), config));
    });
    __privateSet(this, _initPromise, Promise.all(promiseList));
  }
  get editor() {
    return __privateGet(this, _editor);
  }
}
_editor = new WeakMap();
_initPromise = new WeakMap();
_rootElement = new WeakMap();
_editable = new WeakMap();
Crepe.Feature = CrepeFeature;

export { CrepeFeature as C, FeaturesCtx as F, Crepe as a, crepeCtx as c };
//# sourceMappingURL=index-B4c2Fujg.js.map
