'use strict';

var codeBlock = require('@milkdown/kit/component/code-block');
var katex = require('katex');
var index = require('./index-DTnzpEoW.js');
var confirm = require('./confirm-CNveM9QH.js');
var commonmark = require('@milkdown/kit/preset/commonmark');
var inlineLatex = require('./inline-latex-D0G71cGk.js');
var tooltip = require('@milkdown/kit/plugin/tooltip');
var history = require('@milkdown/kit/prose/history');
var keymap = require('@milkdown/kit/prose/keymap');
var model = require('@milkdown/kit/prose/model');
var state = require('@milkdown/kit/prose/state');
var view = require('@milkdown/kit/prose/view');
var vue = require('vue');
var component = require('@milkdown/kit/component');
var prose = require('@milkdown/kit/prose');
var inputrules = require('@milkdown/kit/prose/inputrules');
var utils = require('@milkdown/kit/utils');
var remarkMath = require('remark-math');
var unistUtilVisit = require('unist-util-visit');
require('@milkdown/kit/core');
require('@milkdown/kit/plugin/clipboard');
require('@milkdown/kit/plugin/history');
require('@milkdown/kit/plugin/indent');
require('@milkdown/kit/plugin/listener');
require('@milkdown/kit/plugin/trailing');
require('@milkdown/kit/preset/gfm');
require('@milkdown/kit/ctx');

const blockLatexSchema = commonmark.codeBlockSchema.extendSchema((prev) => {
  return (ctx) => {
    const baseSchema = prev(ctx);
    return {
      ...baseSchema,
      toMarkdown: {
        match: baseSchema.toMarkdown.match,
        runner: (state, node) => {
          var _a, _b;
          const language = (_a = node.attrs.language) != null ? _a : "";
          if (language.toLowerCase() === "latex") {
            state.addNode(
              "math",
              void 0,
              ((_b = node.content.firstChild) == null ? void 0 : _b.text) || ""
            );
          } else {
            return baseSchema.toMarkdown.runner(state, node);
          }
        }
      }
    };
  };
});

const inlineLatexTooltip = tooltip.tooltipFactory("INLINE_LATEX");

const LatexTooltip = vue.defineComponent({
  props: {
    config: {
      type: Object,
      required: true
    },
    innerView: {
      type: Object,
      required: true
    },
    updateValue: {
      type: Object,
      required: true
    }
  },
  setup(props) {
    const innerViewRef = (el) => {
      if (!el || !(el instanceof HTMLElement)) return;
      while (el.firstChild) {
        el.removeChild(el.firstChild);
      }
      if (props.innerView.value) {
        el.appendChild(props.innerView.value.dom);
      }
    };
    const onUpdate = (e) => {
      e.preventDefault();
      props.updateValue.value();
    };
    return () => {
      var _a, _b;
      return /* @__PURE__ */ vue.h("div", { class: "container" }, props.innerView && /* @__PURE__ */ vue.h("div", { ref: innerViewRef }), /* @__PURE__ */ vue.h("button", { onPointerdown: onUpdate }, /* @__PURE__ */ vue.h(component.Icon, { icon: (_b = (_a = props.config).inlineEditConfirm) == null ? void 0 : _b.call(_a) })));
    };
  }
});

var __typeError = (msg) => {
  throw TypeError(msg);
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), member.set(obj, value), value);
var _content, _provider, _dom, _innerView, _updateValue, _app, _onHide, _shouldShow;
class LatexInlineTooltip {
  constructor(ctx, view$1, config) {
    this.ctx = ctx;
    __privateAdd(this, _content);
    __privateAdd(this, _provider);
    __privateAdd(this, _dom);
    __privateAdd(this, _innerView, vue.shallowRef(null));
    __privateAdd(this, _updateValue, vue.shallowRef(() => {
    }));
    __privateAdd(this, _app);
    __privateAdd(this, _onHide, () => {
      if (__privateGet(this, _innerView).value) {
        __privateGet(this, _innerView).value.destroy();
        __privateGet(this, _innerView).value = null;
      }
    });
    __privateAdd(this, _shouldShow, (view$1) => {
      const shouldShow = () => {
        const { selection, schema } = view$1.state;
        if (selection.empty) return false;
        if (!(selection instanceof state.NodeSelection)) return false;
        const node = selection.node;
        if (node.type.name !== inlineLatex.mathInlineId) return false;
        const textFrom = selection.from;
        const paragraph = schema.nodes.paragraph.create(
          null,
          schema.text(node.attrs.value)
        );
        const innerView = new view.EditorView(__privateGet(this, _dom), {
          state: state.EditorState.create({
            doc: paragraph,
            schema: new model.Schema({
              nodes: {
                doc: {
                  content: "block+"
                },
                paragraph: {
                  content: "inline*",
                  group: "block",
                  parseDOM: [{ tag: "p" }],
                  toDOM() {
                    return ["p", 0];
                  }
                },
                text: {
                  group: "inline"
                }
              }
            }),
            plugins: [
              keymap.keymap({
                "Mod-z": history.undo,
                "Mod-Z": history.redo,
                "Mod-y": history.redo,
                Enter: () => {
                  __privateGet(this, _updateValue).value();
                  return true;
                }
              })
            ]
          })
        });
        __privateGet(this, _innerView).value = innerView;
        __privateGet(this, _updateValue).value = () => {
          const { tr } = view$1.state;
          tr.setNodeAttribute(textFrom, "value", innerView.state.doc.textContent);
          view$1.dispatch(tr);
          requestAnimationFrame(() => {
            view$1.focus();
          });
        };
        return true;
      };
      const show = shouldShow();
      if (!show) __privateGet(this, _onHide).call(this);
      return show;
    });
    this.update = (view, prevState) => {
      __privateGet(this, _provider).update(view, prevState);
    };
    this.destroy = () => {
      __privateGet(this, _app).unmount();
      __privateGet(this, _provider).destroy();
      __privateGet(this, _content).remove();
    };
    const content = document.createElement("div");
    content.className = "milkdown-latex-inline-edit";
    __privateSet(this, _content, content);
    __privateSet(this, _app, vue.createApp(LatexTooltip, {
      config,
      innerView: __privateGet(this, _innerView),
      updateValue: __privateGet(this, _updateValue)
    }));
    __privateGet(this, _app).mount(content);
    __privateSet(this, _provider, new tooltip.TooltipProvider({
      debounce: 0,
      content: __privateGet(this, _content),
      shouldShow: __privateGet(this, _shouldShow),
      offset: 10,
      floatingUIOptions: {
        placement: "bottom"
      }
    }));
    __privateGet(this, _provider).update(view$1);
    __privateSet(this, _dom, document.createElement("div"));
  }
}
_content = new WeakMap();
_provider = new WeakMap();
_dom = new WeakMap();
_innerView = new WeakMap();
_updateValue = new WeakMap();
_app = new WeakMap();
_onHide = new WeakMap();
_shouldShow = new WeakMap();

const mathInlineInputRule = utils.$inputRule(
  (ctx) => prose.nodeRule(/(?:\$)([^$]+)(?:\$)$/, inlineLatex.mathInlineSchema.type(ctx), {
    getAttr: (match) => {
      var _a;
      return {
        value: (_a = match[1]) != null ? _a : ""
      };
    }
  })
);
const mathBlockInputRule = utils.$inputRule(
  (ctx) => inputrules.textblockTypeInputRule(/^\$\$[\s\n]$/, commonmark.codeBlockSchema.type(ctx), () => ({
    language: "LaTeX"
  }))
);

const remarkMathPlugin = utils.$remark(
  "remarkMath",
  () => remarkMath
);
function visitMathBlock(ast) {
  return unistUtilVisit.visit(
    ast,
    "math",
    (node, index, parent) => {
      const { value } = node;
      const newNode = {
        type: "code",
        lang: "LaTeX",
        value
      };
      parent.children.splice(index, 1, newNode);
    }
  );
}
const remarkMathBlockPlugin = utils.$remark(
  "remarkMathBlock",
  () => () => visitMathBlock
);

const defineFeature = (editor, config) => {
  editor.config((ctx) => {
    const flags = ctx.get(index.FeaturesCtx);
    const isCodeMirrorEnabled = flags.includes(index.CrepeFeature.CodeMirror);
    if (!isCodeMirrorEnabled) {
      throw new Error("You need to enable CodeMirror to use LaTeX feature");
    }
    ctx.update(codeBlock.codeBlockConfig.key, (prev) => ({
      ...prev,
      renderPreview: (language, content) => {
        if (language.toLowerCase() === "latex" && content.length > 0) {
          return renderLatex(content, config == null ? void 0 : config.katexOptions);
        }
        const renderPreview = prev.renderPreview;
        return renderPreview(language, content);
      }
    }));
    ctx.set(inlineLatexTooltip.key, {
      view: (view) => {
        var _a;
        return new LatexInlineTooltip(ctx, view, {
          inlineEditConfirm: (_a = config == null ? void 0 : config.inlineEditConfirm) != null ? _a : () => confirm.confirmIcon,
          ...config
        });
      }
    });
  }).use(remarkMathPlugin).use(remarkMathBlockPlugin).use(inlineLatex.mathInlineSchema).use(inlineLatexTooltip).use(mathInlineInputRule).use(mathBlockInputRule).use(blockLatexSchema);
};
function renderLatex(content, options) {
  const html = katex.renderToString(content, {
    ...options,
    throwOnError: false,
    displayMode: true
  });
  return html;
}

exports.defineFeature = defineFeature;
//# sourceMappingURL=index-Ro84WmQQ.js.map
