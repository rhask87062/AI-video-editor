var __typeError = (msg) => {
  throw TypeError(msg);
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var _ctx, _createSelection, _activeSelection, _active, _activeDOMRect, _dragging, _BlockService_instances, filterNodes_get, view_get, _notify, _hide, _show, _handleMouseDown, _handleMouseUp, _handleDragStart, _mousemoveCallback, _dragEnd, _element, _ctx2, _service, _activeNode, _root, _initialized, _middleware, _floatingUIOptions, _getOffset, _getPosition, _getPlacement, _BlockProvider_instances, init_fn;
import { findParent, browser } from "@milkdown/prose";
import { $ctx, $prose } from "@milkdown/utils";
import { NodeSelection, PluginKey, Plugin } from "@milkdown/prose/state";
import { editorViewCtx } from "@milkdown/core";
import throttle from "lodash.throttle";
import { DOMSerializer } from "@milkdown/prose/model";
import { flip, offset, computePosition } from "@floating-ui/dom";
function withMeta(plugin, meta) {
  Object.assign(plugin, {
    meta: {
      package: "@milkdown/plugin-block",
      ...meta
    }
  });
  return plugin;
}
const defaultNodeFilter = (pos) => {
  const table = findParent((node) => node.type.name === "table")(pos);
  if (table) return false;
  return true;
};
const blockConfig = $ctx(
  { filterNodes: defaultNodeFilter },
  "blockConfig"
);
withMeta(blockConfig, {
  displayName: "Ctx<blockConfig>"
});
function selectRootNodeByDom(view, coords, filterNodes) {
  var _a;
  const root = view.dom.parentElement;
  if (!root) return null;
  try {
    const pos = (_a = view.posAtCoords({
      left: coords.x,
      top: coords.y
    })) == null ? void 0 : _a.inside;
    if (pos == null || pos < 0) return null;
    let $pos = view.state.doc.resolve(pos);
    let node = view.state.doc.nodeAt(pos);
    let element = view.nodeDOM(pos);
    const filter = (needLookup) => {
      const checkDepth = $pos.depth >= 1 && $pos.index($pos.depth) === 0;
      const shouldLookUp = needLookup || checkDepth;
      if (!shouldLookUp) return;
      const ancestorPos = $pos.before($pos.depth);
      node = view.state.doc.nodeAt(ancestorPos);
      element = view.nodeDOM(ancestorPos);
      $pos = view.state.doc.resolve(ancestorPos);
      if (!filterNodes($pos, node)) filter(true);
    };
    const filterResult = filterNodes($pos, node);
    filter(!filterResult);
    if (!element || !node) return null;
    return { node, $pos, el: element };
  } catch {
    return null;
  }
}
let _detachedDoc = null;
function detachedDoc() {
  return _detachedDoc || (_detachedDoc = document.implementation.createHTMLDocument("title"));
}
const wrapMap = {
  thead: ["table"],
  tbody: ["table"],
  tfoot: ["table"],
  caption: ["table"],
  colgroup: ["table"],
  col: ["table", "colgroup"],
  tr: ["table", "tbody"],
  td: ["table", "tbody", "tr"],
  th: ["table", "tbody", "tr"]
};
function serializeForClipboard(view, slice) {
  const context = [];
  let { openStart, openEnd, content } = slice;
  while (openStart > 1 && openEnd > 1 && content.childCount === 1 && content.firstChild.childCount === 1) {
    openStart -= 1;
    openEnd -= 1;
    const node = content.firstChild;
    context.push(
      node.type.name,
      node.attrs !== node.type.defaultAttrs ? node.attrs : null
    );
    content = node.content;
  }
  const serializer = view.someProp("clipboardSerializer") || DOMSerializer.fromSchema(view.state.schema);
  const doc = detachedDoc();
  const wrap = doc.createElement("div");
  wrap.appendChild(serializer.serializeFragment(content, { document: doc }));
  let firstChild = wrap.firstChild;
  let needsWrap;
  let wrappers = 0;
  while (firstChild && firstChild.nodeType === 1 && (needsWrap = wrapMap[firstChild.nodeName.toLowerCase()])) {
    for (let i = needsWrap.length - 1; i >= 0; i--) {
      const wrapper = doc.createElement(needsWrap[i]);
      while (wrap.firstChild) wrapper.appendChild(wrap.firstChild);
      wrap.appendChild(wrapper);
      wrappers++;
    }
    firstChild = wrap.firstChild;
  }
  if (firstChild && firstChild.nodeType === 1) {
    firstChild.setAttribute(
      "data-pm-slice",
      `${openStart} ${openEnd}${wrappers ? ` -${wrappers}` : ""} ${JSON.stringify(context)}`
    );
  }
  const text = view.someProp("clipboardTextSerializer", (f) => f(slice, view)) || slice.content.textBetween(0, slice.content.size, "\n\n");
  return { dom: wrap, text };
}
const brokenClipboardAPI = browser.ie && browser.ie_version < 15 || browser.ios && browser.webkit_version < 604;
const buffer = 20;
class BlockService {
  constructor() {
    __privateAdd(this, _BlockService_instances);
    /// @internal
    __privateAdd(this, _ctx);
    __privateAdd(this, _createSelection);
    __privateAdd(this, _activeSelection);
    __privateAdd(this, _active);
    __privateAdd(this, _activeDOMRect);
    __privateAdd(this, _dragging);
    /// @internal
    __privateAdd(this, _notify);
    __privateAdd(this, _hide);
    __privateAdd(this, _show);
    __privateAdd(this, _handleMouseDown);
    __privateAdd(this, _handleMouseUp);
    __privateAdd(this, _handleDragStart);
    __privateAdd(this, _mousemoveCallback);
    __privateAdd(this, _dragEnd);
    __privateSet(this, _createSelection, () => {
      if (!__privateGet(this, _active)) return null;
      const result = __privateGet(this, _active);
      const view = __privateGet(this, _BlockService_instances, view_get);
      if (view && NodeSelection.isSelectable(result.node)) {
        const nodeSelection = NodeSelection.create(
          view.state.doc,
          result.$pos.pos
        );
        view.dispatch(view.state.tr.setSelection(nodeSelection));
        view.focus();
        __privateSet(this, _activeSelection, nodeSelection);
        return nodeSelection;
      }
      return null;
    });
    __privateSet(this, _activeSelection, null);
    __privateSet(this, _active, null);
    __privateSet(this, _activeDOMRect, void 0);
    __privateSet(this, _dragging, false);
    __privateSet(this, _hide, () => {
      var _a;
      (_a = __privateGet(this, _notify)) == null ? void 0 : _a.call(this, { type: "hide" });
      __privateSet(this, _active, null);
    });
    __privateSet(this, _show, (active) => {
      var _a;
      __privateSet(this, _active, active);
      (_a = __privateGet(this, _notify)) == null ? void 0 : _a.call(this, { type: "show", active });
    });
    this.bind = (ctx, notify) => {
      __privateSet(this, _ctx, ctx);
      __privateSet(this, _notify, notify);
    };
    this.addEvent = (dom) => {
      dom.addEventListener("mousedown", __privateGet(this, _handleMouseDown));
      dom.addEventListener("mouseup", __privateGet(this, _handleMouseUp));
      dom.addEventListener("dragstart", __privateGet(this, _handleDragStart));
    };
    this.removeEvent = (dom) => {
      dom.removeEventListener("mousedown", __privateGet(this, _handleMouseDown));
      dom.removeEventListener("mouseup", __privateGet(this, _handleMouseUp));
      dom.removeEventListener("dragstart", __privateGet(this, _handleDragStart));
    };
    this.unBind = () => {
      __privateSet(this, _notify, void 0);
    };
    __privateSet(this, _handleMouseDown, () => {
      var _a;
      __privateSet(this, _activeDOMRect, (_a = __privateGet(this, _active)) == null ? void 0 : _a.el.getBoundingClientRect());
      __privateGet(this, _createSelection).call(this);
    });
    __privateSet(this, _handleMouseUp, () => {
      if (!__privateGet(this, _dragging)) {
        requestAnimationFrame(() => {
          var _a;
          if (!__privateGet(this, _activeDOMRect)) return;
          (_a = __privateGet(this, _BlockService_instances, view_get)) == null ? void 0 : _a.focus();
        });
        return;
      }
      __privateSet(this, _dragging, false);
      __privateSet(this, _activeSelection, null);
    });
    __privateSet(this, _handleDragStart, (event) => {
      var _a;
      __privateSet(this, _dragging, true);
      const view = __privateGet(this, _BlockService_instances, view_get);
      if (!view) return;
      view.dom.dataset.dragging = "true";
      const selection = __privateGet(this, _activeSelection);
      if (event.dataTransfer && selection) {
        const slice = selection.content();
        event.dataTransfer.effectAllowed = "copyMove";
        const { dom, text } = serializeForClipboard(view, slice);
        event.dataTransfer.clearData();
        event.dataTransfer.setData(
          brokenClipboardAPI ? "Text" : "text/html",
          dom.innerHTML
        );
        if (!brokenClipboardAPI) event.dataTransfer.setData("text/plain", text);
        const activeEl = (_a = __privateGet(this, _active)) == null ? void 0 : _a.el;
        if (activeEl) event.dataTransfer.setDragImage(activeEl, 0, 0);
        view.dragging = {
          slice,
          move: true
        };
      }
    });
    this.keydownCallback = (view) => {
      __privateGet(this, _hide).call(this);
      __privateSet(this, _dragging, false);
      view.dom.dataset.dragging = "false";
      return false;
    };
    __privateSet(this, _mousemoveCallback, throttle((view, event) => {
      if (!view.editable) return;
      const rect = view.dom.getBoundingClientRect();
      const x = rect.left + rect.width / 2;
      const dom = view.root.elementFromPoint(x, event.clientY);
      if (!(dom instanceof Element)) {
        __privateGet(this, _hide).call(this);
        return;
      }
      const filterNodes = __privateGet(this, _BlockService_instances, filterNodes_get);
      if (!filterNodes) return;
      const result = selectRootNodeByDom(
        view,
        { x, y: event.clientY },
        filterNodes
      );
      if (!result) {
        __privateGet(this, _hide).call(this);
        return;
      }
      __privateGet(this, _show).call(this, result);
    }, 200));
    this.mousemoveCallback = (view, event) => {
      if (view.composing || !view.editable) return false;
      __privateGet(this, _mousemoveCallback).call(this, view, event);
      return false;
    };
    this.dragoverCallback = (view, event) => {
      var _a;
      if (__privateGet(this, _dragging)) {
        const root = (_a = __privateGet(this, _BlockService_instances, view_get)) == null ? void 0 : _a.dom.parentElement;
        if (!root) return false;
        const hasHorizontalScrollbar = root.scrollHeight > root.clientHeight;
        const rootRect = root.getBoundingClientRect();
        if (hasHorizontalScrollbar) {
          if (root.scrollTop > 0 && Math.abs(event.y - rootRect.y) < buffer) {
            const top = root.scrollTop > 10 ? root.scrollTop - 10 : 0;
            root.scrollTop = top;
            return false;
          }
          const totalHeight = Math.round(view.dom.getBoundingClientRect().height);
          const scrollBottom = Math.round(root.scrollTop + rootRect.height);
          if (scrollBottom < totalHeight && Math.abs(event.y - (rootRect.height + rootRect.y)) < buffer) {
            const top = root.scrollTop + 10;
            root.scrollTop = top;
            return false;
          }
        }
      }
      return false;
    };
    this.dragenterCallback = (view) => {
      if (!view.dragging) return;
      __privateSet(this, _dragging, true);
      view.dom.dataset.dragging = "true";
    };
    this.dragleaveCallback = (view, event) => {
      const x = event.clientX;
      const y = event.clientY;
      if (x < 0 || y < 0 || x > window.innerWidth || y > window.innerHeight) {
        __privateSet(this, _active, null);
        __privateGet(this, _dragEnd).call(this, view);
      }
    };
    this.dropCallback = (view) => {
      __privateGet(this, _dragEnd).call(this, view);
      return false;
    };
    this.dragendCallback = (view) => {
      __privateGet(this, _dragEnd).call(this, view);
    };
    __privateSet(this, _dragEnd, (view) => {
      __privateSet(this, _dragging, false);
      view.dom.dataset.dragging = "false";
    });
  }
}
_ctx = new WeakMap();
_createSelection = new WeakMap();
_activeSelection = new WeakMap();
_active = new WeakMap();
_activeDOMRect = new WeakMap();
_dragging = new WeakMap();
_BlockService_instances = new WeakSet();
filterNodes_get = function() {
  var _a;
  return (_a = __privateGet(this, _ctx)) == null ? void 0 : _a.get(blockConfig.key).filterNodes;
};
view_get = function() {
  var _a;
  return (_a = __privateGet(this, _ctx)) == null ? void 0 : _a.get(editorViewCtx);
};
_notify = new WeakMap();
_hide = new WeakMap();
_show = new WeakMap();
_handleMouseDown = new WeakMap();
_handleMouseUp = new WeakMap();
_handleDragStart = new WeakMap();
_mousemoveCallback = new WeakMap();
_dragEnd = new WeakMap();
const blockService = $ctx(() => new BlockService(), "blockService");
const blockServiceInstance = $ctx(
  {},
  "blockServiceInstance"
);
withMeta(blockService, {
  displayName: "Ctx<blockService>"
});
withMeta(blockServiceInstance, {
  displayName: "Ctx<blockServiceInstance>"
});
const blockSpec = $ctx({}, "blockSpec");
withMeta(blockSpec, {
  displayName: "Ctx<blockSpec>"
});
const blockPlugin = $prose((ctx) => {
  const milkdownPluginBlockKey = new PluginKey("MILKDOWN_BLOCK");
  const getService = ctx.get(blockService.key);
  const service = getService();
  ctx.set(blockServiceInstance.key, service);
  const spec = ctx.get(blockSpec.key);
  return new Plugin({
    key: milkdownPluginBlockKey,
    ...spec,
    props: {
      ...spec.props,
      handleDOMEvents: {
        drop: (view) => {
          return service.dropCallback(view);
        },
        pointermove: (view, event) => {
          return service.mousemoveCallback(view, event);
        },
        keydown: (view) => {
          return service.keydownCallback(view);
        },
        dragover: (view, event) => {
          return service.dragoverCallback(view, event);
        },
        dragleave: (view, event) => {
          return service.dragleaveCallback(view, event);
        },
        dragenter: (view) => {
          return service.dragenterCallback(view);
        },
        dragend: (view) => {
          return service.dragendCallback(view);
        }
      }
    }
  });
});
withMeta(blockPlugin, {
  displayName: "Prose<block>"
});
class BlockProvider {
  constructor(options) {
    __privateAdd(this, _BlockProvider_instances);
    /// @internal
    __privateAdd(this, _element);
    /// @internal
    __privateAdd(this, _ctx2);
    /// @internal
    __privateAdd(this, _service);
    __privateAdd(this, _activeNode);
    /// @internal
    __privateAdd(this, _root);
    __privateAdd(this, _initialized);
    /// @internal
    __privateAdd(this, _middleware);
    /// @internal
    __privateAdd(this, _floatingUIOptions);
    /// @internal
    __privateAdd(this, _getOffset);
    /// @internal
    __privateAdd(this, _getPosition);
    /// @internal
    __privateAdd(this, _getPlacement);
    __privateSet(this, _activeNode, null);
    __privateSet(this, _initialized, false);
    this.update = () => {
      requestAnimationFrame(() => {
        if (!__privateGet(this, _initialized)) {
          try {
            __privateMethod(this, _BlockProvider_instances, init_fn).call(this);
            __privateSet(this, _initialized, true);
          } catch {
          }
        }
      });
    };
    this.destroy = () => {
      var _a, _b;
      (_a = __privateGet(this, _service)) == null ? void 0 : _a.unBind();
      (_b = __privateGet(this, _service)) == null ? void 0 : _b.removeEvent(__privateGet(this, _element));
      __privateGet(this, _element).remove();
    };
    this.show = (active) => {
      const dom = active.el;
      const editorDom = __privateGet(this, _ctx2).get(editorViewCtx).dom;
      const deriveContext = {
        ctx: __privateGet(this, _ctx2),
        active,
        editorDom,
        blockDom: __privateGet(this, _element)
      };
      const virtualEl = {
        contextElement: dom,
        getBoundingClientRect: () => {
          if (__privateGet(this, _getPosition)) return __privateGet(this, _getPosition).call(this, deriveContext);
          return dom.getBoundingClientRect();
        }
      };
      const middleware = [flip()];
      if (__privateGet(this, _getOffset)) {
        const offsetOption = __privateGet(this, _getOffset).call(this, deriveContext);
        const offsetExt = offset(offsetOption);
        middleware.push(offsetExt);
      }
      computePosition(virtualEl, __privateGet(this, _element), {
        placement: __privateGet(this, _getPlacement) ? __privateGet(this, _getPlacement).call(this, deriveContext) : "left",
        middleware: [...middleware, ...__privateGet(this, _middleware)],
        ...__privateGet(this, _floatingUIOptions)
      }).then(({ x, y }) => {
        Object.assign(__privateGet(this, _element).style, {
          left: `${x}px`,
          top: `${y}px`
        });
        __privateGet(this, _element).dataset.show = "true";
      }).catch(console.error);
    };
    this.hide = () => {
      __privateGet(this, _element).dataset.show = "false";
    };
    __privateSet(this, _ctx2, options.ctx);
    __privateSet(this, _element, options.content);
    __privateSet(this, _getOffset, options.getOffset);
    __privateSet(this, _getPosition, options.getPosition);
    __privateSet(this, _getPlacement, options.getPlacement);
    __privateSet(this, _middleware, options.middleware ?? []);
    __privateSet(this, _floatingUIOptions, options.floatingUIOptions ?? {});
    __privateSet(this, _root, options.root);
    this.hide();
  }
  /// The context of current active node.
  get active() {
    return __privateGet(this, _activeNode);
  }
}
_element = new WeakMap();
_ctx2 = new WeakMap();
_service = new WeakMap();
_activeNode = new WeakMap();
_root = new WeakMap();
_initialized = new WeakMap();
_middleware = new WeakMap();
_floatingUIOptions = new WeakMap();
_getOffset = new WeakMap();
_getPosition = new WeakMap();
_getPlacement = new WeakMap();
_BlockProvider_instances = new WeakSet();
/// @internal
init_fn = function() {
  const view = __privateGet(this, _ctx2).get(editorViewCtx);
  const root = __privateGet(this, _root) ?? view.dom.parentElement ?? document.body;
  root.appendChild(__privateGet(this, _element));
  const service = __privateGet(this, _ctx2).get(blockServiceInstance.key);
  service.bind(__privateGet(this, _ctx2), (message) => {
    if (message.type === "hide") {
      this.hide();
      __privateSet(this, _activeNode, null);
    } else if (message.type === "show") {
      this.show(message.active);
      __privateSet(this, _activeNode, message.active);
    }
  });
  __privateSet(this, _service, service);
  __privateGet(this, _service).addEvent(__privateGet(this, _element));
  __privateGet(this, _element).draggable = true;
};
const block = [
  blockSpec,
  blockConfig,
  blockService,
  blockServiceInstance,
  blockPlugin
];
block.key = blockSpec.key;
block.pluginKey = blockPlugin.key;
export {
  BlockProvider,
  BlockService,
  block,
  blockConfig,
  blockPlugin,
  blockService,
  blockServiceInstance,
  blockSpec,
  defaultNodeFilter
};
//# sourceMappingURL=index.js.map
