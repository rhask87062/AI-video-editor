{"version":3,"file":"index.js","sources":["../src/__internal__/utils.ts","../src/__internal__/remark-handlers.ts","../src/internal-plugin/atoms.ts","../src/internal-plugin/config.ts","../src/internal-plugin/init.ts","../src/internal-plugin/schema.ts","../src/internal-plugin/commands.ts","../src/internal-plugin/parser.ts","../src/internal-plugin/serializer.ts","../src/internal-plugin/editor-state.ts","../src/internal-plugin/editor-view.ts","../src/editor/editor.ts"],"sourcesContent":["import type { Meta, MilkdownPlugin } from '@milkdown/ctx'\n\nexport function withMeta<T extends MilkdownPlugin>(\n  plugin: T,\n  meta: Partial<Meta> & Pick<Meta, 'displayName'>\n): T {\n  plugin.meta = {\n    package: '@milkdown/core',\n    group: 'System',\n    ...meta,\n  }\n\n  return plugin\n}\n","import type { Options } from 'remark-stringify'\n\nexport const remarkHandlers: Required<Options>['handlers'] = {\n  strong: (node, _, state, info) => {\n    const marker = node.marker || state.options.strong || '*'\n    const exit = state.enter('strong')\n    const tracker = state.createTracker(info)\n    let value = tracker.move(marker + marker)\n    value += tracker.move(\n      state.containerPhrasing(node, {\n        before: value,\n        after: marker,\n        ...tracker.current(),\n      })\n    )\n    value += tracker.move(marker + marker)\n    exit()\n    return value\n  },\n  emphasis: (node, _, state, info) => {\n    const marker = node.marker || state.options.emphasis || '*'\n    const exit = state.enter('emphasis')\n    const tracker = state.createTracker(info)\n    let value = tracker.move(marker)\n    value += tracker.move(\n      state.containerPhrasing(node, {\n        before: value,\n        after: marker,\n        ...tracker.current(),\n      })\n    )\n    value += tracker.move(marker)\n    exit()\n    return value\n  },\n}\n","import type { SliceType, TimerType } from '@milkdown/ctx'\nimport type { InputRule } from '@milkdown/prose/inputrules'\nimport type { EditorState, Plugin } from '@milkdown/prose/state'\nimport type {\n  EditorView,\n  MarkViewConstructor,\n  NodeViewConstructor,\n} from '@milkdown/prose/view'\nimport type { RemarkParser, RemarkPlugin } from '@milkdown/transformer'\nimport type { Options } from 'remark-stringify'\n\nimport { createSlice } from '@milkdown/ctx'\nimport remarkParse from 'remark-parse'\nimport remarkStringify from 'remark-stringify'\nimport { unified } from 'unified'\n\nimport type { Editor } from '../editor'\n\nimport { remarkHandlers } from '../__internal__'\n\n/// A slice which contains the editor view instance.\nexport const editorViewCtx = createSlice({} as EditorView, 'editorView')\n\n/// A slice which contains the editor state.\nexport const editorStateCtx = createSlice({} as EditorState, 'editorState')\n\n/// A slice which stores timers that need to be waited for before starting to run the plugin.\n/// By default, it's `[ConfigReady]`.\nexport const initTimerCtx = createSlice([] as TimerType[], 'initTimer')\n\n/// A slice which stores the editor instance.\nexport const editorCtx = createSlice({} as Editor, 'editor')\n\n/// A slice which stores the input rules.\nexport const inputRulesCtx = createSlice([] as InputRule[], 'inputRules')\n\n/// A slice which stores the prosemirror plugins.\nexport const prosePluginsCtx = createSlice([] as Plugin[], 'prosePlugins')\n\n/// A slice which stores the remark plugins.\nexport const remarkPluginsCtx = createSlice(\n  [] as RemarkPlugin[],\n  'remarkPlugins'\n)\n\ntype NodeView = [nodeId: string, view: NodeViewConstructor]\n\n/// A slice which stores the prosemirror node views.\nexport const nodeViewCtx = createSlice([] as NodeView[], 'nodeView')\n\ntype MarkView = [nodeId: string, view: MarkViewConstructor]\n\n/// A slice which stores the prosemirror mark views.\nexport const markViewCtx = createSlice([] as MarkView[], 'markView')\n\n/// A slice which stores the remark instance.\nexport const remarkCtx: SliceType<RemarkParser, 'remark'> = createSlice(\n  unified().use(remarkParse).use(remarkStringify),\n  'remark'\n)\n\n/// A slice which stores the remark stringify options.\nexport const remarkStringifyOptionsCtx = createSlice(\n  {\n    handlers: remarkHandlers,\n  } as Options,\n  'remarkStringifyOptions'\n)\n","import type { Ctx, MilkdownPlugin } from '@milkdown/ctx'\n\nimport { createTimer } from '@milkdown/ctx'\n\nimport { withMeta } from '../__internal__'\n\n/// @internal\nexport type Config = (ctx: Ctx) => void | Promise<void>\n\n/// The timer which will be resolved when the config plugin is ready.\nexport const ConfigReady = createTimer('ConfigReady')\n\n/// The config plugin.\n/// This plugin will load all user configs.\nexport function config(configure: Config): MilkdownPlugin {\n  const plugin: MilkdownPlugin = (ctx) => {\n    ctx.record(ConfigReady)\n\n    return async () => {\n      await configure(ctx)\n      ctx.done(ConfigReady)\n\n      return () => {\n        ctx.clearTimer(ConfigReady)\n      }\n    }\n  }\n\n  withMeta(plugin, {\n    displayName: 'Config',\n  })\n\n  return plugin\n}\n","import type { MilkdownPlugin } from '@milkdown/ctx'\n\nimport { createTimer } from '@milkdown/ctx'\nimport remarkParse from 'remark-parse'\nimport remarkStringify from 'remark-stringify'\nimport { unified } from 'unified'\n\nimport type { Editor } from '../editor'\n\nimport { remarkHandlers, withMeta } from '../__internal__'\nimport {\n  editorCtx,\n  initTimerCtx,\n  inputRulesCtx,\n  markViewCtx,\n  nodeViewCtx,\n  prosePluginsCtx,\n  remarkCtx,\n  remarkPluginsCtx,\n  remarkStringifyOptionsCtx,\n} from './atoms'\nimport { ConfigReady } from './config'\n\n/// The timer which will be resolved when the init plugin is ready.\nexport const InitReady = createTimer('InitReady')\n\n/// The init plugin.\n/// This plugin prepare slices that needed by other plugins. And create a remark instance.\n///\n/// This plugin will wait for the config plugin.\nexport function init(editor: Editor): MilkdownPlugin {\n  const plugin: MilkdownPlugin = (ctx) => {\n    ctx\n      .inject(editorCtx, editor)\n      .inject(prosePluginsCtx, [])\n      .inject(remarkPluginsCtx, [])\n      .inject(inputRulesCtx, [])\n      .inject(nodeViewCtx, [])\n      .inject(markViewCtx, [])\n      .inject(remarkStringifyOptionsCtx, {\n        handlers: remarkHandlers,\n      })\n      .inject(remarkCtx, unified().use(remarkParse).use(remarkStringify))\n      .inject(initTimerCtx, [ConfigReady])\n      .record(InitReady)\n\n    return async () => {\n      await ctx.waitTimers(initTimerCtx)\n      const options = ctx.get(remarkStringifyOptionsCtx)\n      ctx.set(\n        remarkCtx,\n        unified().use(remarkParse).use(remarkStringify, options)\n      )\n\n      ctx.done(InitReady)\n\n      return () => {\n        ctx\n          .remove(editorCtx)\n          .remove(prosePluginsCtx)\n          .remove(remarkPluginsCtx)\n          .remove(inputRulesCtx)\n          .remove(nodeViewCtx)\n          .remove(markViewCtx)\n          .remove(remarkStringifyOptionsCtx)\n          .remove(remarkCtx)\n          .remove(initTimerCtx)\n          .clearTimer(InitReady)\n      }\n    }\n  }\n  withMeta(plugin, {\n    displayName: 'Init',\n  })\n\n  return plugin\n}\n","import type { MilkdownPlugin, TimerType } from '@milkdown/ctx'\nimport type {\n  MarkSchema,\n  NodeSchema,\n  RemarkParser,\n} from '@milkdown/transformer'\n\nimport { createSlice, createTimer } from '@milkdown/ctx'\nimport { Schema } from '@milkdown/prose/model'\n\nimport { withMeta } from '../__internal__'\nimport { remarkCtx, remarkPluginsCtx } from './atoms'\nimport { InitReady } from './init'\n\n/// The timer which will be resolved when the schema plugin is ready.\nexport const SchemaReady = createTimer('SchemaReady')\n\n/// A slice which stores timers that need to be waited for before starting to run the plugin.\n/// By default, it's `[InitReady]`.\nexport const schemaTimerCtx = createSlice([] as TimerType[], 'schemaTimer')\n\n/// A slice which contains the schema.\nexport const schemaCtx = createSlice({} as Schema, 'schema')\n\n/// A slice which stores the nodes spec.\nexport const nodesCtx = createSlice([] as Array<[string, NodeSchema]>, 'nodes')\n\n/// A slice which stores the marks spec.\nexport const marksCtx = createSlice([] as Array<[string, MarkSchema]>, 'marks')\n\nfunction extendPriority<T extends NodeSchema | MarkSchema>(x: T): T {\n  return {\n    ...x,\n    parseDOM: x.parseDOM?.map((rule) => ({ priority: x.priority, ...rule })),\n  }\n}\n\n/// The schema plugin.\n/// This plugin will load all nodes spec and marks spec and create a schema.\n///\n/// This plugin will wait for the init plugin.\nexport const schema: MilkdownPlugin = (ctx) => {\n  ctx\n    .inject(schemaCtx, {} as Schema)\n    .inject(nodesCtx, [])\n    .inject(marksCtx, [])\n    .inject(schemaTimerCtx, [InitReady])\n    .record(SchemaReady)\n\n  return async () => {\n    await ctx.waitTimers(schemaTimerCtx)\n\n    const remark = ctx.get(remarkCtx)\n    const remarkPlugins = ctx.get(remarkPluginsCtx)\n\n    const processor = remarkPlugins.reduce(\n      (acc: RemarkParser, plug) =>\n        acc.use(plug.plugin, plug.options) as unknown as RemarkParser,\n      remark\n    )\n    ctx.set(remarkCtx, processor)\n\n    const nodes = Object.fromEntries(\n      ctx.get(nodesCtx).map(([key, x]) => [key, extendPriority(x)])\n    )\n    const marks = Object.fromEntries(\n      ctx.get(marksCtx).map(([key, x]) => [key, extendPriority(x)])\n    )\n    const schema = new Schema({ nodes, marks })\n\n    ctx.set(schemaCtx, schema)\n\n    ctx.done(SchemaReady)\n\n    return () => {\n      ctx\n        .remove(schemaCtx)\n        .remove(nodesCtx)\n        .remove(marksCtx)\n        .remove(schemaTimerCtx)\n        .clearTimer(SchemaReady)\n    }\n  }\n}\n\nwithMeta(schema, {\n  displayName: 'Schema',\n})\n","import type { Ctx, MilkdownPlugin, SliceType } from '@milkdown/ctx'\nimport type { Command } from '@milkdown/prose/state'\n\nimport { Container, createSlice, createTimer } from '@milkdown/ctx'\nimport { callCommandBeforeEditorView } from '@milkdown/exception'\nimport { chainCommands } from '@milkdown/prose/commands'\n\nimport { withMeta } from '../__internal__'\nimport { editorViewCtx } from './atoms'\nimport { SchemaReady } from './schema'\n\n/// @internal\nexport type Cmd<T = undefined> = (payload?: T) => Command\n\n/// @internal\nexport type CmdKey<T = undefined> = SliceType<Cmd<T>>\n\ntype InferParams<T> = T extends CmdKey<infer U> ? U : never\n\n/// A chainable command helper.\nexport interface CommandChain {\n  /// Run the command chain.\n  run: () => boolean\n  /// Add an inline command to the chain.\n  inline: (command: Command) => CommandChain\n  /// Add a registered command to the chain.\n  pipe: {\n    <T extends CmdKey<any>>(\n      slice: string,\n      payload?: InferParams<T>\n    ): CommandChain\n    <T>(slice: CmdKey<T>, payload?: T): CommandChain\n    (slice: string | CmdKey<any>, payload?: any): CommandChain\n  }\n}\n\n/// The command manager.\n/// This manager will manage all commands in editor.\n/// Generally, you don't need to use this manager directly.\n/// You can use the `$command` and `$commandAsync` in `@milkdown/utils` to create and call a command.\nexport class CommandManager {\n  /// @internal\n  #container = new Container()\n\n  /// @internal\n  #ctx: Ctx | null = null\n\n  /// @internal\n  setCtx = (ctx: Ctx) => {\n    this.#ctx = ctx\n  }\n\n  get ctx() {\n    return this.#ctx\n  }\n\n  /// Register a command into the manager.\n  create<T>(meta: CmdKey<T>, value: Cmd<T>) {\n    const slice = meta.create(this.#container.sliceMap)\n    slice.set(value)\n    return slice\n  }\n\n  /// Get a command from the manager.\n  get<T extends CmdKey<any>>(slice: string): Cmd<InferParams<T>>\n  get<T>(slice: CmdKey<T>): Cmd<T>\n  get(slice: string | CmdKey<any>): Cmd<any>\n  get(slice: string | CmdKey<any>): Cmd<any> {\n    return this.#container.get(slice).get()\n  }\n\n  /// Remove a command from the manager.\n  remove<T extends CmdKey<any>>(slice: string): void\n  remove<T>(slice: CmdKey<T>): void\n  remove(slice: string | CmdKey<any>): void\n  remove(slice: string | CmdKey<any>): void {\n    return this.#container.remove(slice)\n  }\n\n  /// Call a registered command.\n  call<T extends CmdKey<any>>(slice: string, payload?: InferParams<T>): boolean\n  call<T>(slice: CmdKey<T>, payload?: T): boolean\n  call(slice: string | CmdKey<any>, payload?: any): boolean\n  call(slice: string | CmdKey<any>, payload?: any): boolean {\n    if (this.#ctx == null) throw callCommandBeforeEditorView()\n\n    const cmd = this.get(slice)\n    const command = cmd(payload)\n    const view = this.#ctx.get(editorViewCtx)\n    return command(view.state, view.dispatch, view)\n  }\n\n  /// Call an inline command.\n  inline(command: Command) {\n    if (this.#ctx == null) throw callCommandBeforeEditorView()\n    const view = this.#ctx.get(editorViewCtx)\n    return command(view.state, view.dispatch, view)\n  }\n\n  /// Create a command chain.\n  /// All commands added by `pipe` will be run in order until one of them returns `true`.\n  chain = (): CommandChain => {\n    if (this.#ctx == null) throw callCommandBeforeEditorView()\n    const ctx = this.#ctx\n    const commands: Command[] = []\n    const get = this.get\n\n    const chains: CommandChain = {\n      run: () => {\n        const chained = chainCommands(...commands)\n        const view = ctx.get(editorViewCtx)\n        return chained(view.state, view.dispatch, view)\n      },\n      inline: (command: Command) => {\n        commands.push(command)\n        return chains\n      },\n      pipe,\n    }\n\n    function pipe<T extends CmdKey<any>>(\n      slice: string,\n      payload?: InferParams<T>\n    ): typeof chains\n    function pipe<T>(slice: CmdKey<T>, payload?: T): typeof chains\n    function pipe(slice: string | CmdKey<any>, payload?: any): typeof chains\n    function pipe(slice: string | CmdKey<any>, payload?: any) {\n      const cmd = get(slice)\n      commands.push(cmd(payload))\n      return chains\n    }\n\n    return chains\n  }\n}\n\n/// Create a command key, which is a slice type that contains a command.\nexport function createCmdKey<T = undefined>(key = 'cmdKey'): CmdKey<T> {\n  return createSlice((() => () => false) as Cmd<T>, key)\n}\n\n/// A slice which contains the command manager.\nexport const commandsCtx = createSlice(new CommandManager(), 'commands')\n\n/// A slice which stores timers that need to be waited for before starting to run the plugin.\n/// By default, it's `[SchemaReady]`.\nexport const commandsTimerCtx = createSlice([SchemaReady], 'commandsTimer')\n\n/// The timer which will be resolved when the commands plugin is ready.\nexport const CommandsReady = createTimer('CommandsReady')\n\n/// The commands plugin.\n/// This plugin will create a command manager.\n///\n/// This plugin will wait for the schema plugin.\nexport const commands: MilkdownPlugin = (ctx) => {\n  const cmd = new CommandManager()\n  cmd.setCtx(ctx)\n  ctx\n    .inject(commandsCtx, cmd)\n    .inject(commandsTimerCtx, [SchemaReady])\n    .record(CommandsReady)\n  return async () => {\n    await ctx.waitTimers(commandsTimerCtx)\n\n    ctx.done(CommandsReady)\n\n    return () => {\n      ctx.remove(commandsCtx).remove(commandsTimerCtx).clearTimer(CommandsReady)\n    }\n  }\n}\n\nwithMeta(commands, {\n  displayName: 'Commands',\n})\n","import type { MilkdownPlugin, TimerType } from '@milkdown/ctx'\nimport type { Parser } from '@milkdown/transformer'\n\nimport { createSlice, createTimer } from '@milkdown/ctx'\nimport { ctxCallOutOfScope } from '@milkdown/exception'\nimport { ParserState } from '@milkdown/transformer'\n\nimport { withMeta } from '../__internal__'\nimport { remarkCtx } from './atoms'\nimport { SchemaReady, schemaCtx } from './schema'\n\n/// The timer which will be resolved when the parser plugin is ready.\nexport const ParserReady = createTimer('ParserReady')\n\nconst outOfScope = (() => {\n  throw ctxCallOutOfScope()\n}) as Parser\n\n/// A slice which contains the parser.\nexport const parserCtx = createSlice(outOfScope, 'parser')\n\n/// A slice which stores timers that need to be waited for before starting to run the plugin.\n/// By default, it's `[SchemaReady]`.\nexport const parserTimerCtx = createSlice([] as TimerType[], 'parserTimer')\n\n/// The parser plugin.\n/// This plugin will create a parser.\n///\n/// This plugin will wait for the schema plugin.\nexport const parser: MilkdownPlugin = (ctx) => {\n  ctx\n    .inject(parserCtx, outOfScope)\n    .inject(parserTimerCtx, [SchemaReady])\n    .record(ParserReady)\n\n  return async () => {\n    await ctx.waitTimers(parserTimerCtx)\n    const remark = ctx.get(remarkCtx)\n    const schema = ctx.get(schemaCtx)\n\n    ctx.set(parserCtx, ParserState.create(schema, remark))\n    ctx.done(ParserReady)\n    return () => {\n      ctx.remove(parserCtx).remove(parserTimerCtx).clearTimer(ParserReady)\n    }\n  }\n}\n\nwithMeta(parser, {\n  displayName: 'Parser',\n})\n","import type { MilkdownPlugin, TimerType } from '@milkdown/ctx'\nimport type { Serializer } from '@milkdown/transformer'\n\nimport { createSlice, createTimer } from '@milkdown/ctx'\nimport { ctxCallOutOfScope } from '@milkdown/exception'\nimport { SerializerState } from '@milkdown/transformer'\n\nimport { withMeta } from '../__internal__'\nimport { remarkCtx } from './atoms'\nimport { SchemaReady, schemaCtx } from './schema'\n\n/// The timer which will be resolved when the serializer plugin is ready.\nexport const SerializerReady = createTimer('SerializerReady')\n\n/// A slice which stores timers that need to be waited for before starting to run the plugin.\n/// By default, it's `[SchemaReady]`.\nexport const serializerTimerCtx = createSlice(\n  [] as TimerType[],\n  'serializerTimer'\n)\n\nconst outOfScope = (() => {\n  throw ctxCallOutOfScope()\n}) as Serializer\n\n/// A slice which contains the serializer.\nexport const serializerCtx = createSlice<Serializer, 'serializer'>(\n  outOfScope,\n  'serializer'\n)\n\n/// The serializer plugin.\n/// This plugin will create a serializer.\n///\n/// This plugin will wait for the schema plugin.\nexport const serializer: MilkdownPlugin = (ctx) => {\n  ctx\n    .inject(serializerCtx, outOfScope)\n    .inject(serializerTimerCtx, [SchemaReady])\n    .record(SerializerReady)\n\n  return async () => {\n    await ctx.waitTimers(serializerTimerCtx)\n    const remark = ctx.get(remarkCtx)\n    const schema = ctx.get(schemaCtx)\n\n    ctx.set(serializerCtx, SerializerState.create(schema, remark))\n    ctx.done(SerializerReady)\n\n    return () => {\n      ctx\n        .remove(serializerCtx)\n        .remove(serializerTimerCtx)\n        .clearTimer(SerializerReady)\n    }\n  }\n}\n\nwithMeta(serializer, {\n  displayName: 'Serializer',\n})\n","import type { MilkdownPlugin, TimerType } from '@milkdown/ctx'\nimport type { Schema } from '@milkdown/prose/model'\nimport type { Command } from '@milkdown/prose/state'\nimport type { JSONRecord, Parser } from '@milkdown/transformer'\n\nimport { createSlice, createTimer } from '@milkdown/ctx'\nimport { docTypeError } from '@milkdown/exception'\nimport { customInputRules as createInputRules } from '@milkdown/prose'\nimport {\n  baseKeymap,\n  chainCommands,\n  deleteSelection,\n  joinBackward,\n  selectNodeBackward,\n} from '@milkdown/prose/commands'\nimport { undoInputRule } from '@milkdown/prose/inputrules'\nimport { keymap as createKeymap } from '@milkdown/prose/keymap'\nimport { DOMParser, Node } from '@milkdown/prose/model'\nimport { EditorState, Plugin, PluginKey } from '@milkdown/prose/state'\n\nimport { withMeta } from '../__internal__'\nimport { editorStateCtx, inputRulesCtx, prosePluginsCtx } from './atoms'\nimport { CommandsReady } from './commands'\nimport { ParserReady, parserCtx } from './parser'\nimport { schemaCtx } from './schema'\nimport { SerializerReady } from './serializer'\n\n/// @internal\nexport type DefaultValue =\n  | string\n  | { type: 'html'; dom: HTMLElement }\n  | { type: 'json'; value: JSONRecord }\ntype StateOptions = Parameters<typeof EditorState.create>[0]\ntype StateOptionsOverride = (prev: StateOptions) => StateOptions\n\n/// A slice which contains the default value of the editor.\n/// Can be markdown string, html string or json.\nexport const defaultValueCtx = createSlice('' as DefaultValue, 'defaultValue')\n\n/// A slice which contains the options which is used to create the editor state.\nexport const editorStateOptionsCtx = createSlice<StateOptionsOverride>(\n  (x) => x,\n  'stateOptions'\n)\n\n/// A slice which stores timers that need to be waited for before starting to run the plugin.\n/// By default, it's `[ParserReady, SerializerReady, CommandsReady]`.\nexport const editorStateTimerCtx = createSlice(\n  [] as TimerType[],\n  'editorStateTimer'\n)\n\n/// The timer which will be resolved when the editor state plugin is ready.\nexport const EditorStateReady = createTimer('EditorStateReady')\n\n/// @internal\nexport function getDoc(\n  defaultValue: DefaultValue,\n  parser: Parser,\n  schema: Schema\n) {\n  if (typeof defaultValue === 'string') return parser(defaultValue)\n\n  if (defaultValue.type === 'html')\n    return DOMParser.fromSchema(schema).parse(defaultValue.dom)\n\n  if (defaultValue.type === 'json')\n    return Node.fromJSON(schema, defaultValue.value)\n\n  throw docTypeError(defaultValue)\n}\n\nconst key = new PluginKey('MILKDOWN_STATE_TRACKER')\n\nfunction overrideBaseKeymap(keymap: Record<string, Command>) {\n  const handleBackspace = chainCommands(\n    undoInputRule,\n    deleteSelection,\n    joinBackward,\n    selectNodeBackward\n  )\n  keymap.Backspace = handleBackspace\n  return keymap\n}\n\n/// The editor state plugin.\n/// This plugin will create a prosemirror editor state.\n///\n/// This plugin will wait for the parser plugin, serializer plugin and commands plugin.\nexport const editorState: MilkdownPlugin = (ctx) => {\n  ctx\n    .inject(defaultValueCtx, '')\n    .inject(editorStateCtx, {} as EditorState)\n    .inject(editorStateOptionsCtx, (x) => x)\n    .inject(editorStateTimerCtx, [ParserReady, SerializerReady, CommandsReady])\n    .record(EditorStateReady)\n\n  return async () => {\n    await ctx.waitTimers(editorStateTimerCtx)\n\n    const schema = ctx.get(schemaCtx)\n    const parser = ctx.get(parserCtx)\n    const rules = ctx.get(inputRulesCtx)\n    const optionsOverride = ctx.get(editorStateOptionsCtx)\n    const prosePlugins = ctx.get(prosePluginsCtx)\n    const defaultValue = ctx.get(defaultValueCtx)\n    const doc = getDoc(defaultValue, parser, schema)\n\n    const plugins = [\n      ...prosePlugins,\n      new Plugin({\n        key,\n        state: {\n          init: () => {\n            // do nothing\n          },\n          apply: (_tr, _value, _oldState, newState) => {\n            ctx.set(editorStateCtx, newState)\n          },\n        },\n      }),\n      createInputRules({ rules }),\n      createKeymap(overrideBaseKeymap(baseKeymap)),\n    ]\n\n    ctx.set(prosePluginsCtx, plugins)\n\n    const options = optionsOverride({\n      schema,\n      doc,\n      plugins,\n    })\n\n    const state = EditorState.create(options)\n    ctx.set(editorStateCtx, state)\n    ctx.done(EditorStateReady)\n\n    return () => {\n      ctx\n        .remove(defaultValueCtx)\n        .remove(editorStateCtx)\n        .remove(editorStateOptionsCtx)\n        .remove(editorStateTimerCtx)\n        .clearTimer(EditorStateReady)\n    }\n  }\n}\n\nwithMeta(editorState, {\n  displayName: 'EditorState',\n})\n","import type { Ctx, MilkdownPlugin, TimerType } from '@milkdown/ctx'\nimport type { DirectEditorProps } from '@milkdown/prose/view'\n\nimport { createSlice, createTimer } from '@milkdown/ctx'\nimport { Plugin, PluginKey } from '@milkdown/prose/state'\nimport { EditorView } from '@milkdown/prose/view'\n\nimport { withMeta } from '../__internal__'\nimport {\n  editorStateCtx,\n  editorViewCtx,\n  markViewCtx,\n  nodeViewCtx,\n  prosePluginsCtx,\n} from './atoms'\nimport { EditorStateReady } from './editor-state'\nimport { InitReady } from './init'\n\ntype EditorOptions = Omit<DirectEditorProps, 'state'>\n\ntype RootType = Node | undefined | null | string\n\n/// The timer which will be resolved when the editor view plugin is ready.\nexport const EditorViewReady = createTimer('EditorViewReady')\n\n/// A slice which stores timers that need to be waited for before starting to run the plugin.\n/// By default, it's `[EditorStateReady]`.\nexport const editorViewTimerCtx = createSlice(\n  [] as TimerType[],\n  'editorViewTimer'\n)\n\n/// A slice which contains the editor view options which will be passed to the editor view.\nexport const editorViewOptionsCtx = createSlice(\n  {} as Partial<EditorOptions>,\n  'editorViewOptions'\n)\n\n/// A slice which contains the value to get the root element.\n/// Can be a selector string, a node or null.\n/// If it's null, the editor will be created in the body.\nexport const rootCtx = createSlice(null as RootType, 'root')\n\n/// A slice which contains the actually root element.\nexport const rootDOMCtx = createSlice(null as unknown as HTMLElement, 'rootDOM')\n\n/// A slice which contains the root element attributes.\n/// You can add attributes to the root element by this slice.\nexport const rootAttrsCtx = createSlice(\n  {} as Record<string, string>,\n  'rootAttrs'\n)\n\nfunction createViewContainer(root: Node, ctx: Ctx) {\n  const container = document.createElement('div')\n  container.className = 'milkdown'\n  root.appendChild(container)\n  ctx.set(rootDOMCtx, container)\n\n  const attrs = ctx.get(rootAttrsCtx)\n  Object.entries(attrs).forEach(([key, value]) =>\n    container.setAttribute(key, value)\n  )\n\n  return container\n}\n\nfunction prepareViewDom(dom: Element) {\n  dom.classList.add('editor')\n  dom.setAttribute('role', 'textbox')\n}\n\nconst key = new PluginKey('MILKDOWN_VIEW_CLEAR')\n\n/// The editor view plugin.\n/// This plugin will create an editor view.\n///\n/// This plugin will wait for the editor state plugin.\nexport const editorView: MilkdownPlugin = (ctx) => {\n  ctx\n    .inject(rootCtx, document.body)\n    .inject(editorViewCtx, {} as EditorView)\n    .inject(editorViewOptionsCtx, {})\n    .inject(rootDOMCtx, null as unknown as HTMLElement)\n    .inject(rootAttrsCtx, {})\n    .inject(editorViewTimerCtx, [EditorStateReady])\n    .record(EditorViewReady)\n\n  return async () => {\n    await ctx.wait(InitReady)\n\n    const root = ctx.get(rootCtx) || document.body\n    const el = typeof root === 'string' ? document.querySelector(root) : root\n\n    ctx.update(prosePluginsCtx, (xs) => [\n      new Plugin({\n        key,\n        view: (editorView) => {\n          const container = el ? createViewContainer(el, ctx) : undefined\n\n          const handleDOM = () => {\n            if (container && el) {\n              const editor = editorView.dom\n              el.replaceChild(container, editor)\n              container.appendChild(editor)\n            }\n          }\n          handleDOM()\n          return {\n            destroy: () => {\n              if (container?.parentNode)\n                container?.parentNode.replaceChild(editorView.dom, container)\n\n              container?.remove()\n            },\n          }\n        },\n      }),\n      ...xs,\n    ])\n\n    await ctx.waitTimers(editorViewTimerCtx)\n\n    const state = ctx.get(editorStateCtx)\n    const options = ctx.get(editorViewOptionsCtx)\n    const nodeViews = Object.fromEntries(ctx.get(nodeViewCtx))\n    const markViews = Object.fromEntries(ctx.get(markViewCtx))\n    const view = new EditorView(el as Node, {\n      state,\n      nodeViews,\n      markViews,\n      ...options,\n    })\n    prepareViewDom(view.dom)\n    ctx.set(editorViewCtx, view)\n    ctx.done(EditorViewReady)\n\n    return () => {\n      view?.destroy()\n      ctx\n        .remove(rootCtx)\n        .remove(editorViewCtx)\n        .remove(editorViewOptionsCtx)\n        .remove(rootDOMCtx)\n        .remove(rootAttrsCtx)\n        .remove(editorViewTimerCtx)\n        .clearTimer(EditorViewReady)\n    }\n  }\n}\n\nwithMeta(editorView, {\n  displayName: 'EditorView',\n})\n","import type { CtxRunner, MilkdownPlugin, Telemetry } from '@milkdown/ctx'\n\nimport { Clock, Container, Ctx } from '@milkdown/ctx'\n\nimport type { Config } from '../internal-plugin'\n\nimport {\n  commands,\n  config,\n  editorState,\n  editorView,\n  init,\n  parser,\n  schema,\n  serializer,\n} from '../internal-plugin'\n\n/// The status of the editor.\nexport enum EditorStatus {\n  /// The editor is not initialized.\n  Idle = 'Idle',\n  /// The editor is creating.\n  OnCreate = 'OnCreate',\n  /// The editor has been created and ready to use.\n  Created = 'Created',\n  /// The editor is destroying.\n  OnDestroy = 'OnDestroy',\n  /// The editor has been destroyed.\n  Destroyed = 'Destroyed',\n}\n\n/// Type for the callback called when editor status changed.\nexport type OnStatusChange = (status: EditorStatus) => void\n\ntype EditorPluginStore = Map<\n  MilkdownPlugin,\n  {\n    ctx: Ctx | undefined\n    handler: CtxRunner | undefined\n    cleanup: ReturnType<CtxRunner>\n  }\n>\n\n/// The milkdown editor class.\nexport class Editor {\n  /// Create a new editor instance.\n  static make() {\n    return new Editor()\n  }\n\n  /// @internal\n  #enableInspector = false\n  /// @internal\n  #status = EditorStatus.Idle\n  /// @internal\n  #configureList: Config[] = []\n  /// @internal\n  #onStatusChange: OnStatusChange = () => undefined\n\n  /// @internal\n  readonly #container = new Container()\n  /// @internal\n  readonly #clock = new Clock()\n\n  /// @internal\n  readonly #usrPluginStore: EditorPluginStore = new Map()\n\n  /// @internal\n  readonly #sysPluginStore: EditorPluginStore = new Map()\n\n  /// @internal\n  readonly #ctx = new Ctx(this.#container, this.#clock)\n\n  /// @internal\n  readonly #loadInternal = () => {\n    const configPlugin = config(async (ctx) => {\n      await Promise.all(this.#configureList.map((fn) => fn(ctx)))\n    })\n    const internalPlugins = [\n      schema,\n      parser,\n      serializer,\n      commands,\n      editorState,\n      editorView,\n      init(this),\n      configPlugin,\n    ]\n    this.#prepare(internalPlugins, this.#sysPluginStore)\n  }\n\n  /// @internal\n  readonly #prepare = (plugins: MilkdownPlugin[], store: EditorPluginStore) => {\n    plugins.forEach((plugin) => {\n      const ctx = this.#ctx.produce(\n        this.#enableInspector ? plugin.meta : undefined\n      )\n      const handler = plugin(ctx)\n      store.set(plugin, { ctx, handler, cleanup: undefined })\n    })\n  }\n\n  /// @internal\n  readonly #cleanup = (plugins: MilkdownPlugin[], remove = false) => {\n    return Promise.all(\n      [plugins].flat().map((plugin) => {\n        const loader = this.#usrPluginStore.get(plugin)\n        const cleanup = loader?.cleanup\n        if (remove) this.#usrPluginStore.delete(plugin)\n        else\n          this.#usrPluginStore.set(plugin, {\n            ctx: undefined,\n            handler: undefined,\n            cleanup: undefined,\n          })\n\n        if (typeof cleanup === 'function') return cleanup()\n\n        return cleanup\n      })\n    )\n  }\n\n  /// @internal\n  readonly #cleanupInternal = async () => {\n    await Promise.all(\n      [...this.#sysPluginStore.entries()].map(([_, { cleanup }]) => {\n        if (typeof cleanup === 'function') return cleanup()\n\n        return cleanup\n      })\n    )\n    this.#sysPluginStore.clear()\n  }\n\n  /// @internal\n  readonly #setStatus = (status: EditorStatus) => {\n    this.#status = status\n    this.#onStatusChange(status)\n  }\n\n  /// @internal\n  readonly #loadPluginInStore = (store: EditorPluginStore) => {\n    return [...store.entries()].map(async ([key, loader]) => {\n      const { ctx, handler } = loader\n      if (!handler) return\n\n      const cleanup = await handler()\n\n      store.set(key, { ctx, handler, cleanup })\n    })\n  }\n\n  /// Get the ctx of the editor.\n  get ctx() {\n    return this.#ctx\n  }\n\n  /// Get the status of the editor.\n  get status() {\n    return this.#status\n  }\n\n  /// Enable the inspector for the editor.\n  /// You can also pass `false` to disable the inspector.\n  readonly enableInspector = (enable = true) => {\n    this.#enableInspector = enable\n\n    return this\n  }\n\n  /// Subscribe to the status change event for the editor.\n  /// The new subscription will replace the old one.\n  readonly onStatusChange = (onChange: OnStatusChange) => {\n    this.#onStatusChange = onChange\n    return this\n  }\n\n  /// Add a config for the editor.\n  readonly config = (configure: Config) => {\n    this.#configureList.push(configure)\n    return this\n  }\n\n  /// Remove a config for the editor.\n  readonly removeConfig = (configure: Config) => {\n    this.#configureList = this.#configureList.filter((x) => x !== configure)\n    return this\n  }\n\n  /// Use a plugin or a list of plugins for the editor.\n  readonly use = (plugins: MilkdownPlugin | MilkdownPlugin[]) => {\n    const _plugins = [plugins].flat()\n    _plugins.flat().forEach((plugin) => {\n      this.#usrPluginStore.set(plugin, {\n        ctx: undefined,\n        handler: undefined,\n        cleanup: undefined,\n      })\n    })\n\n    if (this.#status === EditorStatus.Created)\n      this.#prepare(_plugins, this.#usrPluginStore)\n\n    return this\n  }\n\n  /// Remove a plugin or a list of plugins from the editor.\n  readonly remove = async (\n    plugins: MilkdownPlugin | MilkdownPlugin[]\n  ): Promise<Editor> => {\n    if (this.#status === EditorStatus.OnCreate) {\n      console.warn(\n        '[Milkdown]: You are trying to remove plugins when the editor is creating, this is not recommended, please check your code.'\n      )\n      return new Promise((resolve) => {\n        setTimeout(() => {\n          resolve(this.remove(plugins))\n        }, 50)\n      })\n    }\n\n    await this.#cleanup([plugins].flat(), true)\n    return this\n  }\n\n  /// Create the editor with current config and plugins.\n  /// If the editor is already created, it will be recreated.\n  readonly create = async (): Promise<Editor> => {\n    if (this.#status === EditorStatus.OnCreate) return this\n\n    if (this.#status === EditorStatus.Created) await this.destroy()\n\n    this.#setStatus(EditorStatus.OnCreate)\n\n    this.#loadInternal()\n    this.#prepare([...this.#usrPluginStore.keys()], this.#usrPluginStore)\n\n    await Promise.all(\n      [\n        this.#loadPluginInStore(this.#sysPluginStore),\n        this.#loadPluginInStore(this.#usrPluginStore),\n      ].flat()\n    )\n\n    this.#setStatus(EditorStatus.Created)\n    return this\n  }\n\n  /// Destroy the editor.\n  /// If you want to clear all plugins, set `clearPlugins` to `true`.\n  readonly destroy = async (clearPlugins = false): Promise<Editor> => {\n    if (\n      this.#status === EditorStatus.Destroyed ||\n      this.#status === EditorStatus.OnDestroy\n    )\n      return this\n\n    if (this.#status === EditorStatus.OnCreate) {\n      return new Promise((resolve) => {\n        setTimeout(() => {\n          resolve(this.destroy(clearPlugins))\n        }, 50)\n      })\n    }\n\n    if (clearPlugins) this.#configureList = []\n\n    this.#setStatus(EditorStatus.OnDestroy)\n    await this.#cleanup([...this.#usrPluginStore.keys()], clearPlugins)\n    await this.#cleanupInternal()\n\n    this.#setStatus(EditorStatus.Destroyed)\n    return this\n  }\n\n  /// Call an action with the ctx of the editor.\n  /// This method should be used after the editor is created.\n  readonly action = <T>(action: (ctx: Ctx) => T) => action(this.#ctx)\n\n  /// Get inspections of plugins in editor.\n  /// Make sure you have enabled inspector by `editor.enableInspector()` before calling this method.\n  readonly inspect = (): Telemetry[] => {\n    if (!this.#enableInspector) {\n      console.warn(\n        '[Milkdown]: You are trying to collect inspection when inspector is disabled, please enable inspector by `editor.enableInspector()` first.'\n      )\n      return []\n    }\n    return [...this.#sysPluginStore.values(), ...this.#usrPluginStore.values()]\n      .map(({ ctx }) => ctx?.inspector?.read())\n      .filter((x): x is Telemetry => Boolean(x))\n  }\n}\n"],"names":["key","schema","commands","outOfScope","parser","keymap","createInputRules","createKeymap","editorView","EditorStatus","_container","_ctx"],"mappings":"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"}