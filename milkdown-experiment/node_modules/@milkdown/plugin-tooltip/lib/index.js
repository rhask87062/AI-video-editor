var __typeError = (msg) => {
  throw TypeError(msg);
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var _debounce, _shouldShow, _middleware, _floatingUIOptions, _root, _initialized, _offset, _shift, _onUpdate, _TooltipProvider_instances, _shouldShow_fn;
import { computePosition, flip, offset, shift } from "@floating-ui/dom";
import { posToDOMRect } from "@milkdown/prose";
import { TextSelection, Plugin, PluginKey } from "@milkdown/prose/state";
import throttle from "lodash.throttle";
import { $ctx, $prose } from "@milkdown/utils";
class TooltipProvider {
  constructor(options) {
    __privateAdd(this, _TooltipProvider_instances);
    /// @internal
    __privateAdd(this, _debounce);
    /// @internal
    __privateAdd(this, _shouldShow);
    /// @internal
    __privateAdd(this, _middleware);
    /// @internal
    __privateAdd(this, _floatingUIOptions);
    /// @internal
    __privateAdd(this, _root);
    __privateAdd(this, _initialized);
    /// @internal
    __privateAdd(this, _offset);
    /// @internal
    __privateAdd(this, _shift);
    __privateAdd(this, _onUpdate);
    __privateSet(this, _initialized, false);
    this.onShow = () => {
    };
    this.onHide = () => {
    };
    __privateSet(this, _onUpdate, (view, prevState) => {
      const { state, composing } = view;
      const { selection, doc } = state;
      const { ranges } = selection;
      const from = Math.min(...ranges.map((range) => range.$from.pos));
      const to = Math.max(...ranges.map((range) => range.$to.pos));
      const isSame = prevState && prevState.doc.eq(doc) && prevState.selection.eq(selection);
      if (!__privateGet(this, _initialized)) {
        const root = __privateGet(this, _root) ?? view.dom.parentElement ?? document.body;
        root.appendChild(this.element);
        __privateSet(this, _initialized, true);
      }
      if (composing || isSame) return;
      if (!__privateGet(this, _shouldShow).call(this, view, prevState)) {
        this.hide();
        return;
      }
      const virtualEl = {
        getBoundingClientRect: () => posToDOMRect(view, from, to)
      };
      computePosition(virtualEl, this.element, {
        placement: __privateGet(this, _floatingUIOptions).placement ?? "top",
        middleware: [
          flip(),
          offset(__privateGet(this, _offset)),
          shift(__privateGet(this, _shift)),
          ...__privateGet(this, _middleware)
        ]
      }).then(({ x, y }) => {
        Object.assign(this.element.style, {
          left: `${x}px`,
          top: `${y}px`
        });
      }).catch(console.error);
      this.show();
    });
    this.update = (view, prevState) => {
      const updater = throttle(__privateGet(this, _onUpdate), __privateGet(this, _debounce));
      updater(view, prevState);
    };
    this.destroy = () => {
    };
    this.show = (virtualElement) => {
      this.element.dataset.show = "true";
      if (virtualElement) {
        computePosition(virtualElement, this.element, {
          placement: "top",
          middleware: [
            flip(),
            offset(__privateGet(this, _offset)),
            shift(__privateGet(this, _shift)),
            ...__privateGet(this, _middleware)
          ],
          ...__privateGet(this, _floatingUIOptions)
        }).then(({ x, y }) => {
          Object.assign(this.element.style, {
            left: `${x}px`,
            top: `${y}px`
          });
        }).catch(console.error);
      }
      this.onShow();
    };
    this.hide = () => {
      if (this.element.dataset.show === "false") return;
      this.element.dataset.show = "false";
      this.onHide();
    };
    this.element = options.content;
    __privateSet(this, _debounce, options.debounce ?? 200);
    __privateSet(this, _shouldShow, options.shouldShow ?? __privateMethod(this, _TooltipProvider_instances, _shouldShow_fn));
    __privateSet(this, _offset, options.offset);
    __privateSet(this, _shift, options.shift);
    __privateSet(this, _middleware, options.middleware ?? []);
    __privateSet(this, _floatingUIOptions, options.floatingUIOptions ?? {});
    __privateSet(this, _root, options.root);
    this.element.dataset.show = "false";
  }
}
_debounce = new WeakMap();
_shouldShow = new WeakMap();
_middleware = new WeakMap();
_floatingUIOptions = new WeakMap();
_root = new WeakMap();
_initialized = new WeakMap();
_offset = new WeakMap();
_shift = new WeakMap();
_onUpdate = new WeakMap();
_TooltipProvider_instances = new WeakSet();
/// @internal
_shouldShow_fn = function(view) {
  const { doc, selection } = view.state;
  const { empty, from, to } = selection;
  const isEmptyTextBlock = !doc.textBetween(from, to).length && view.state.selection instanceof TextSelection;
  const isTooltipChildren = this.element.contains(document.activeElement);
  const notHasFocus = !view.hasFocus() && !isTooltipChildren;
  const isReadonly = !view.editable;
  if (notHasFocus || empty || isEmptyTextBlock || isReadonly) return false;
  return true;
};
function tooltipFactory(id) {
  const tooltipSpec = $ctx(
    {},
    `${id}_TOOLTIP_SPEC`
  );
  const tooltipPlugin = $prose((ctx) => {
    const spec = ctx.get(tooltipSpec.key);
    return new Plugin({
      key: new PluginKey(`${id}_TOOLTIP`),
      ...spec
    });
  });
  const result = [tooltipSpec, tooltipPlugin];
  result.key = tooltipSpec.key;
  result.pluginKey = tooltipPlugin.key;
  tooltipSpec.meta = {
    package: "@milkdown/plugin-tooltip",
    displayName: `Ctx<tooltipSpec>|${id}`
  };
  tooltipPlugin.meta = {
    package: "@milkdown/plugin-tooltip",
    displayName: `Prose<tooltip>|${id}`
  };
  return result;
}
export {
  TooltipProvider,
  tooltipFactory
};
//# sourceMappingURL=index.js.map
