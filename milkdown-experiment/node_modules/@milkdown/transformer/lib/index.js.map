{"version":3,"file":"index.js","sources":["../src/utility/stack.ts","../src/parser/stack-element.ts","../src/parser/state.ts","../src/serializer/stack-element.ts","../src/serializer/state.ts"],"sourcesContent":["import { stackOverFlow } from '@milkdown/exception'\n\n/// The element of the stack, which holds an array of nodes.\nexport abstract class StackElement<Node> {\n  /// A method that can `push` a node into the element.\n  abstract push(node: Node, ...rest: Node[]): void\n}\n\n/// The stack that is used to store the elements.\n///\n/// > Generally, you don't need to use this class directly.\n///\n/// When using the stack, users can call `stack.open` to push a new element into the stack.\n/// And use `stack.push` to push a node into the top element.\n/// Then use `stack.close` to close the top element and pop it.\n///\n/// For example: `stack.open(A).push(B).push(C).close()` will generate a structure like `A(B, C)`.\nexport class Stack<Node, Element extends StackElement<Node>> {\n  protected elements: Element[] = []\n\n  /// Get the size of the stack.\n  size = (): number => {\n    return this.elements.length\n  }\n\n  /// Get the top element of the stack.\n  top = (): Element | undefined => {\n    return this.elements.at(-1)\n  }\n\n  /// Push a node into the top element.\n  push = (node: Node): void => {\n    this.top()?.push(node)\n  }\n\n  /// Push a new element.\n  open = (node: Element): void => {\n    this.elements.push(node)\n  }\n\n  /// Close the top element and pop it.\n  close = (): Element => {\n    const el = this.elements.pop()\n    if (!el) throw stackOverFlow()\n\n    return el\n  }\n}\n","import type { Attrs, Node, NodeType } from '@milkdown/prose/model'\n\nimport { StackElement } from '../utility'\n\nexport class ParserStackElement extends StackElement<Node> {\n  constructor(\n    public type: NodeType,\n    public content: Node[],\n    public attrs?: Attrs\n  ) {\n    super()\n  }\n\n  push(node: Node, ...rest: Node[]) {\n    this.content.push(node, ...rest)\n  }\n\n  pop(): Node | undefined {\n    return this.content.pop()\n  }\n\n  static create(type: NodeType, content: Node[], attrs?: Attrs) {\n    return new ParserStackElement(type, content, attrs)\n  }\n}\n","import type {\n  Attrs,\n  MarkType,\n  Node,\n  NodeType,\n  Schema,\n} from '@milkdown/prose/model'\n\nimport {\n  createNodeInParserFail,\n  parserMatchError,\n  stackOverFlow,\n} from '@milkdown/exception'\nimport { Mark } from '@milkdown/prose/model'\n\nimport type {\n  MarkSchema,\n  MarkdownNode,\n  NodeSchema,\n  RemarkParser,\n} from '../utility'\nimport type { Parser } from './types'\n\nimport { Stack } from '../utility'\nimport { ParserStackElement } from './stack-element'\n\n/// A state machine for parser. Transform remark AST into prosemirror state.\nexport class ParserState extends Stack<Node, ParserStackElement> {\n  /// The schema in current editor.\n  readonly schema: Schema\n\n  /// @internal\n  #marks: readonly Mark[] = Mark.none\n\n  /// Create a parser from schema and remark instance.\n  ///\n  /// ```typescript\n  /// const parser = ParserState.create(schema, remark)\n  /// const prosemirrorNode = parser(SomeMarkdownText)\n  /// ```\n  static create = (schema: Schema, remark: RemarkParser): Parser => {\n    const state = new this(schema)\n    return (text) => {\n      state.run(remark, text)\n      return state.toDoc()\n    }\n  }\n\n  /// @internal\n  protected constructor(schema: Schema) {\n    super()\n    this.schema = schema\n  }\n\n  /// @internal\n  #hasText = (node: Node): node is Node & { text: string } => node.isText\n\n  /// @internal\n  #maybeMerge = (a: Node, b: Node): Node | undefined => {\n    if (this.#hasText(a) && this.#hasText(b) && Mark.sameSet(a.marks, b.marks))\n      return this.schema.text(a.text + b.text, a.marks)\n\n    return undefined\n  }\n\n  /// @internal\n  #matchTarget = (node: MarkdownNode): NodeType | MarkType => {\n    const result = Object.values({\n      ...this.schema.nodes,\n      ...this.schema.marks,\n    }).find((x): x is NodeType | MarkType => {\n      const spec = x.spec as NodeSchema | MarkSchema\n      return spec.parseMarkdown.match(node)\n    })\n\n    if (!result) throw parserMatchError(node)\n\n    return result\n  }\n\n  /// @internal\n  #runNode = (node: MarkdownNode) => {\n    const type = this.#matchTarget(node)\n    const spec = type.spec as NodeSchema | MarkSchema\n\n    spec.parseMarkdown.runner(this, node, type as NodeType & MarkType)\n  }\n\n  /// Inject root node for prosemirror state.\n  injectRoot = (node: MarkdownNode, nodeType: NodeType, attrs?: Attrs) => {\n    this.openNode(nodeType, attrs)\n    this.next(node.children)\n\n    return this\n  }\n\n  /// Open a new node, the next operations will\n  /// add nodes into that new node until `closeNode` is called.\n  openNode = (nodeType: NodeType, attrs?: Attrs) => {\n    this.open(ParserStackElement.create(nodeType, [], attrs))\n    return this\n  }\n\n  /// @internal\n  #closeNodeAndPush = (): Node => {\n    this.#marks = Mark.none\n    const element = this.close()\n\n    return this.#addNodeAndPush(element.type, element.attrs, element.content)\n  }\n\n  /// Close the current node and push it into the parent node.\n  closeNode = () => {\n    try {\n      this.#closeNodeAndPush()\n    } catch (e) {\n      console.error(e)\n    }\n    return this\n  }\n\n  /// @internal\n  #addNodeAndPush = (\n    nodeType: NodeType,\n    attrs?: Attrs,\n    content?: Node[]\n  ): Node => {\n    const node = nodeType.createAndFill(attrs, content, this.#marks)\n    if (!node) throw createNodeInParserFail(nodeType, attrs, content)\n\n    this.push(node)\n\n    return node\n  }\n\n  /// Add a node into current node.\n  addNode = (nodeType: NodeType, attrs?: Attrs, content?: Node[]) => {\n    try {\n      this.#addNodeAndPush(nodeType, attrs, content)\n    } catch (e) {\n      console.error(e)\n    }\n    return this\n  }\n\n  /// Open a new mark, the next nodes added will have that mark.\n  openMark = (markType: MarkType, attrs?: Attrs) => {\n    const mark = markType.create(attrs)\n\n    this.#marks = mark.addToSet(this.#marks)\n    return this\n  }\n\n  /// Close a opened mark.\n  closeMark = (markType: MarkType) => {\n    this.#marks = markType.removeFromSet(this.#marks)\n    return this\n  }\n\n  /// Add a text node into current node.\n  addText = (text: string) => {\n    try {\n      const topElement = this.top()\n      if (!topElement) throw stackOverFlow()\n\n      const prevNode = topElement.pop()\n      const currNode = this.schema.text(text, this.#marks)\n\n      if (!prevNode) {\n        topElement.push(currNode)\n        return this\n      }\n\n      const merged = this.#maybeMerge(prevNode, currNode)\n      if (merged) {\n        topElement.push(merged)\n        return this\n      }\n      topElement.push(prevNode, currNode)\n      return this\n    } catch (e) {\n      console.error(e)\n      return this\n    }\n  }\n\n  /// @internal\n  build = (): Node => {\n    let doc: Node | undefined\n\n    do doc = this.#closeNodeAndPush()\n    while (this.size())\n\n    return doc\n  }\n\n  /// Give the node or node list back to the state and\n  /// the state will find a proper runner (by `match` method in parser spec) to handle it.\n  next = (nodes: MarkdownNode | MarkdownNode[] = []) => {\n    ;[nodes].flat().forEach((node) => this.#runNode(node))\n    return this\n  }\n\n  /// Build the current state into a [prosemirror document](https://prosemirror.net/docs/ref/#model.Document_Structure).\n  toDoc = () => this.build()\n\n  /// Transform a markdown string into prosemirror state.\n  run = (remark: RemarkParser, markdown: string) => {\n    const tree = remark.runSync(\n      remark.parse(markdown),\n      markdown\n    ) as MarkdownNode\n    this.next(tree)\n\n    return this\n  }\n}\n","import type { MarkdownNode } from '..'\nimport type { JSONRecord } from '../utility'\n\nimport { StackElement } from '../utility'\n\nexport class SerializerStackElement extends StackElement<MarkdownNode> {\n  constructor(\n    public type: string,\n    public children?: MarkdownNode[],\n    public value?: string,\n    public props: JSONRecord = {}\n  ) {\n    super()\n  }\n\n  static create = (\n    type: string,\n    children?: MarkdownNode[],\n    value?: string,\n    props: JSONRecord = {}\n  ) => new SerializerStackElement(type, children, value, props)\n\n  push = (node: MarkdownNode, ...rest: MarkdownNode[]) => {\n    if (!this.children) this.children = []\n\n    this.children.push(node, ...rest)\n  }\n\n  pop = (): MarkdownNode | undefined => this.children?.pop()\n}\n","import type {\n  Fragment,\n  MarkType,\n  Node,\n  NodeType,\n  Schema,\n} from '@milkdown/prose/model'\n\nimport { serializerMatchError } from '@milkdown/exception'\nimport { Mark } from '@milkdown/prose/model'\n\nimport type {\n  JSONRecord,\n  MarkSchema,\n  MarkdownNode,\n  NodeSchema,\n  RemarkParser,\n  Root,\n} from '../utility'\nimport type { Serializer } from './types'\n\nimport { Stack } from '../utility'\nimport { SerializerStackElement } from './stack-element'\n\nconst isFragment = (x: Node | Fragment): x is Fragment =>\n  Object.prototype.hasOwnProperty.call(x, 'size')\n\n/// State for serializer.\n/// Transform prosemirror state into remark AST.\nexport class SerializerState extends Stack<\n  MarkdownNode,\n  SerializerStackElement\n> {\n  /// @internal\n  #marks: readonly Mark[] = Mark.none\n  /// Get the schema of state.\n  readonly schema: Schema\n\n  /// Create a serializer from schema and remark instance.\n  ///\n  /// ```typescript\n  /// const serializer = SerializerState.create(schema, remark)\n  /// const markdown = parser(prosemirrorDoc)\n  /// ```\n  static create = (schema: Schema, remark: RemarkParser): Serializer => {\n    const state = new this(schema)\n    return (content: Node) => {\n      state.run(content)\n      return state.toString(remark)\n    }\n  }\n\n  /// @internal\n  constructor(schema: Schema) {\n    super()\n    this.schema = schema\n  }\n\n  /// @internal\n  #matchTarget = (node: Node | Mark): NodeType | MarkType => {\n    const result = Object.values({\n      ...this.schema.nodes,\n      ...this.schema.marks,\n    }).find((x): x is NodeType | MarkType => {\n      const spec = x.spec as NodeSchema | MarkSchema\n      return spec.toMarkdown.match(node as Node & Mark)\n    })\n\n    if (!result) throw serializerMatchError(node.type)\n\n    return result\n  }\n\n  /// @internal\n  #runProseNode = (node: Node) => {\n    const type = this.#matchTarget(node)\n    const spec = type.spec as NodeSchema\n    return spec.toMarkdown.runner(this, node)\n  }\n\n  /// @internal\n  #runProseMark = (mark: Mark, node: Node) => {\n    const type = this.#matchTarget(mark)\n    const spec = type.spec as MarkSchema\n    return spec.toMarkdown.runner(this, mark, node)\n  }\n\n  /// @internal\n  #runNode = (node: Node) => {\n    const { marks } = node\n    const getPriority = (x: Mark) => x.type.spec.priority ?? 50\n    const tmp = [...marks].sort((a, b) => getPriority(a) - getPriority(b))\n    const unPreventNext = tmp.every((mark) => !this.#runProseMark(mark, node))\n    if (unPreventNext) this.#runProseNode(node)\n\n    marks.forEach((mark) => this.#closeMark(mark))\n  }\n\n  /// @internal\n  #searchType = (child: MarkdownNode, type: string): MarkdownNode => {\n    if (child.type === type) return child\n\n    if (child.children?.length !== 1) return child\n\n    const searchNode = (node: MarkdownNode): MarkdownNode | null => {\n      if (node.type === type) return node\n\n      if (node.children?.length !== 1) return null\n\n      const [firstChild] = node.children\n      if (!firstChild) return null\n\n      return searchNode(firstChild)\n    }\n\n    const target = searchNode(child)\n\n    if (!target) return child\n\n    const tmp = target.children ? [...target.children] : undefined\n    const node = { ...child, children: tmp }\n    node.children = tmp\n    target.children = [node]\n\n    return target\n  }\n\n  /// @internal\n  #maybeMergeChildren = (node: MarkdownNode): MarkdownNode => {\n    const { children } = node\n    if (!children) return node\n\n    node.children = children.reduce((nextChildren, child, index) => {\n      if (index === 0) return [child]\n\n      const last = nextChildren.at(-1)\n      if (last && last.isMark && child.isMark) {\n        child = this.#searchType(child, last.type)\n        const { children: currChildren, ...currRest } = child\n        const { children: prevChildren, ...prevRest } = last\n        if (\n          child.type === last.type &&\n          currChildren &&\n          prevChildren &&\n          JSON.stringify(currRest) === JSON.stringify(prevRest)\n        ) {\n          const next = {\n            ...prevRest,\n            children: [...prevChildren, ...currChildren],\n          }\n          return nextChildren\n            .slice(0, -1)\n            .concat(this.#maybeMergeChildren(next))\n        }\n      }\n      return nextChildren.concat(child)\n    }, [] as MarkdownNode[])\n\n    return node\n  }\n\n  /// @internal\n  #createMarkdownNode = (element: SerializerStackElement) => {\n    const node: MarkdownNode = {\n      ...element.props,\n      type: element.type,\n    }\n\n    if (element.children) node.children = element.children\n\n    if (element.value) node.value = element.value\n\n    return node\n  }\n\n  /// Open a new node, the next operations will\n  /// add nodes into that new node until `closeNode` is called.\n  openNode = (type: string, value?: string, props?: JSONRecord) => {\n    this.open(SerializerStackElement.create(type, undefined, value, props))\n    return this\n  }\n\n  #moveSpaces = (\n    element: SerializerStackElement,\n    onPush: () => MarkdownNode\n  ) => {\n    let startSpaces = ''\n    let endSpaces = ''\n    const children = element.children\n    let first = -1\n    let last = -1\n    const findIndex = (node: MarkdownNode[]) => {\n      if (!node) return\n      node.forEach((child, index) => {\n        if (child.type === 'text' && child.value) {\n          if (first < 0) first = index\n\n          last = index\n        }\n      })\n    }\n\n    if (children) {\n      findIndex(children)\n      const lastChild = children?.[last] as\n        | (MarkdownNode & { value: string })\n        | undefined\n      const firstChild = children?.[first] as\n        | (MarkdownNode & { value: string })\n        | undefined\n      if (lastChild && lastChild.value.endsWith(' ')) {\n        endSpaces = lastChild.value.match(/ +$/)![0]\n        lastChild.value = lastChild.value.trimEnd()\n      }\n      if (firstChild && firstChild.value.startsWith(' ')) {\n        startSpaces = firstChild.value.match(/^ +/)![0]\n        firstChild.value = firstChild.value.trimStart()\n      }\n    }\n\n    if (startSpaces.length) this.#addNodeAndPush('text', undefined, startSpaces)\n\n    const result = onPush()\n\n    if (endSpaces.length) this.#addNodeAndPush('text', undefined, endSpaces)\n\n    return result\n  }\n\n  /// @internal\n  #closeNodeAndPush = (trim: boolean = false): MarkdownNode => {\n    const element = this.close()\n\n    const onPush = () =>\n      this.#addNodeAndPush(\n        element.type,\n        element.children,\n        element.value,\n        element.props\n      )\n\n    if (trim) return this.#moveSpaces(element, onPush)\n\n    return onPush()\n  }\n\n  /// Close the current node and push it into the parent node.\n  closeNode = () => {\n    this.#closeNodeAndPush()\n    return this\n  }\n\n  /// @internal\n  #addNodeAndPush = (\n    type: string,\n    children?: MarkdownNode[],\n    value?: string,\n    props?: JSONRecord\n  ): MarkdownNode => {\n    const element = SerializerStackElement.create(type, children, value, props)\n    const node: MarkdownNode = this.#maybeMergeChildren(\n      this.#createMarkdownNode(element)\n    )\n    this.push(node)\n    return node\n  }\n\n  /// Add a node into current node.\n  addNode = (\n    type: string,\n    children?: MarkdownNode[],\n    value?: string,\n    props?: JSONRecord\n  ) => {\n    this.#addNodeAndPush(type, children, value, props)\n    return this\n  }\n\n  /// @internal\n  #openMark = (\n    mark: Mark,\n    type: string,\n    value?: string,\n    props?: JSONRecord\n  ) => {\n    const isIn = mark.isInSet(this.#marks)\n\n    if (isIn) return this\n\n    this.#marks = mark.addToSet(this.#marks)\n    return this.openNode(type, value, { ...props, isMark: true })\n  }\n\n  /// @internal\n  #closeMark = (mark: Mark): void => {\n    const isIn = mark.isInSet(this.#marks)\n\n    if (!isIn) return\n\n    this.#marks = mark.type.removeFromSet(this.#marks)\n    this.#closeNodeAndPush(true)\n  }\n\n  /// Open a new mark, the next nodes added will have that mark.\n  /// The mark will be closed automatically.\n  withMark = (mark: Mark, type: string, value?: string, props?: JSONRecord) => {\n    this.#openMark(mark, type, value, props)\n    return this\n  }\n\n  /// Close a opened mark.\n  /// In most cases you don't need this because\n  /// marks will be closed automatically.\n  closeMark = (mark: Mark) => {\n    this.#closeMark(mark)\n    return this\n  }\n\n  /// @internal\n  build = (): MarkdownNode => {\n    let doc: MarkdownNode | null = null\n    do doc = this.#closeNodeAndPush()\n    while (this.size())\n\n    return doc\n  }\n\n  /// Give the node or node list back to the state and\n  /// the state will find a proper runner (by `match` method in serializer spec) to handle it.\n  next = (nodes: Node | Fragment) => {\n    if (isFragment(nodes)) {\n      nodes.forEach((node) => {\n        this.#runNode(node)\n      })\n      return this\n    }\n    this.#runNode(nodes)\n    return this\n  }\n\n  /// Use a remark parser to serialize current AST stored.\n  override toString = (remark: RemarkParser): string =>\n    remark.stringify(this.build() as Root)\n\n  /// Transform a prosemirror node tree into remark AST.\n  run = (tree: Node) => {\n    this.next(tree)\n\n    return this\n  }\n}\n"],"names":["_marks","_matchTarget","_runNode","_closeNodeAndPush","_addNodeAndPush","node"],"mappings":"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"}