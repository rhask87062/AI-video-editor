{"version":3,"file":"index.js","sources":["../src/__internal__/with-meta.ts","../src/mark/strike-through.ts","../src/node/table/schema.ts","../src/node/table/utils.ts","../src/node/table/command.ts","../src/node/table/input.ts","../src/node/footnote/definition.ts","../src/node/footnote/reference.ts","../src/node/task-list-item.ts","../src/composed/keymap.ts","../src/composed/inputrules.ts","../src/plugin/auto-insert-span-plugin.ts","../src/plugin/column-resizing-plugin.ts","../src/plugin/table-editing-plugin.ts","../src/plugin/remark-gfm-plugin.ts","../src/plugin/keep-table-align-plugin.ts","../src/composed/plugins.ts","../src/composed/schema.ts","../src/composed/commands.ts","../src/index.ts"],"sourcesContent":["import type { Meta, MilkdownPlugin } from '@milkdown/ctx'\n\nexport function withMeta<T extends MilkdownPlugin>(\n  plugin: T,\n  meta: Partial<Meta> & Pick<Meta, 'displayName'>\n): T {\n  Object.assign(plugin, {\n    meta: {\n      package: '@milkdown/preset-gfm',\n      ...meta,\n    },\n  })\n\n  return plugin\n}\n","import { commandsCtx } from '@milkdown/core'\nimport { markRule } from '@milkdown/prose'\nimport { toggleMark } from '@milkdown/prose/commands'\nimport {\n  $command,\n  $inputRule,\n  $markAttr,\n  $markSchema,\n  $useKeymap,\n} from '@milkdown/utils'\n\nimport { withMeta } from '../__internal__'\n\n/// HTML attributes for the strikethrough mark.\nexport const strikethroughAttr = $markAttr('strike_through')\n\nwithMeta(strikethroughAttr, {\n  displayName: 'Attr<strikethrough>',\n  group: 'Strikethrough',\n})\n\n/// Strikethrough mark schema.\nexport const strikethroughSchema = $markSchema('strike_through', (ctx) => ({\n  parseDOM: [\n    { tag: 'del' },\n    {\n      style: 'text-decoration',\n      getAttrs: (value) => (value === 'line-through') as false,\n    },\n  ],\n  toDOM: (mark) => ['del', ctx.get(strikethroughAttr.key)(mark)],\n  parseMarkdown: {\n    match: (node) => node.type === 'delete',\n    runner: (state, node, markType) => {\n      state.openMark(markType)\n      state.next(node.children)\n      state.closeMark(markType)\n    },\n  },\n  toMarkdown: {\n    match: (mark) => mark.type.name === 'strike_through',\n    runner: (state, mark) => {\n      state.withMark(mark, 'delete')\n    },\n  },\n}))\n\nwithMeta(strikethroughSchema.mark, {\n  displayName: 'MarkSchema<strikethrough>',\n  group: 'Strikethrough',\n})\n\nwithMeta(strikethroughSchema.ctx, {\n  displayName: 'MarkSchemaCtx<strikethrough>',\n  group: 'Strikethrough',\n})\n\n/// A command to toggle the strikethrough mark.\nexport const toggleStrikethroughCommand = $command(\n  'ToggleStrikeThrough',\n  (ctx) => () => {\n    return toggleMark(strikethroughSchema.type(ctx))\n  }\n)\n\nwithMeta(toggleStrikethroughCommand, {\n  displayName: 'Command<ToggleStrikethrough>',\n  group: 'Strikethrough',\n})\n\n/// Input rule to create the strikethrough mark.\nexport const strikethroughInputRule = $inputRule((ctx) => {\n  return markRule(/~([^~]+)~$/, strikethroughSchema.type(ctx))\n})\n\nwithMeta(strikethroughInputRule, {\n  displayName: 'InputRule<strikethrough>',\n  group: 'Strikethrough',\n})\n\n/// Keymap for the strikethrough mark.\n/// - `Mod-Alt-x` - Toggle the strikethrough mark.\nexport const strikethroughKeymap = $useKeymap('strikeThroughKeymap', {\n  ToggleStrikethrough: {\n    shortcuts: 'Mod-Alt-x',\n    command: (ctx) => {\n      const commands = ctx.get(commandsCtx)\n      return () => commands.call(toggleStrikethroughCommand.key)\n    },\n  },\n})\n\nwithMeta(strikethroughKeymap.ctx, {\n  displayName: 'KeymapCtx<strikethrough>',\n  group: 'Strikethrough',\n})\n\nwithMeta(strikethroughKeymap.shortcuts, {\n  displayName: 'Keymap<strikethrough>',\n  group: 'Strikethrough',\n})\n","import type { NodeType } from '@milkdown/prose/model'\nimport type { MarkdownNode } from '@milkdown/transformer'\n\nimport { tableNodes } from '@milkdown/prose/tables'\nimport { $nodeSchema } from '@milkdown/utils'\n\nimport { withMeta } from '../../__internal__'\n\nconst originalSchema = tableNodes({\n  tableGroup: 'block',\n  cellContent: 'paragraph',\n  cellAttributes: {\n    alignment: {\n      default: 'left',\n      getFromDOM: (dom) => dom.style.textAlign || 'left',\n      setDOMAttr: (value, attrs) => {\n        attrs.style = `text-align: ${value || 'left'}`\n      },\n    },\n  },\n})\n\n/// Schema for table node.\nexport const tableSchema = $nodeSchema('table', () => ({\n  ...originalSchema.table,\n  content: 'table_header_row table_row+',\n  disableDropCursor: true,\n  parseMarkdown: {\n    match: (node) => node.type === 'table',\n    runner: (state, node, type) => {\n      const align = node.align as (string | null)[]\n      const children = (node.children as MarkdownNode[]).map((x, i) => ({\n        ...x,\n        align,\n        isHeader: i === 0,\n      }))\n      state.openNode(type)\n      state.next(children)\n      state.closeNode()\n    },\n  },\n  toMarkdown: {\n    match: (node) => node.type.name === 'table',\n    runner: (state, node) => {\n      const firstLine = node.content.firstChild?.content\n      if (!firstLine) return\n\n      const align: (string | null)[] = []\n      firstLine.forEach((cell) => {\n        align.push(cell.attrs.alignment)\n      })\n      state.openNode('table', undefined, { align })\n      state.next(node.content)\n      state.closeNode()\n    },\n  },\n}))\n\nwithMeta(tableSchema.node, {\n  displayName: 'NodeSchema<table>',\n  group: 'Table',\n})\n\nwithMeta(tableSchema.ctx, {\n  displayName: 'NodeSchemaCtx<table>',\n  group: 'Table',\n})\n\n/// Schema for table header row node.\nexport const tableHeaderRowSchema = $nodeSchema('table_header_row', () => ({\n  ...originalSchema.table_row,\n  disableDropCursor: true,\n  content: '(table_header)*',\n  parseDOM: [{ tag: 'tr[data-is-header]' }],\n  toDOM() {\n    return ['tr', { 'data-is-header': true }, 0]\n  },\n  parseMarkdown: {\n    match: (node) => Boolean(node.type === 'tableRow' && node.isHeader),\n    runner: (state, node, type) => {\n      const align = node.align as (string | null)[]\n      const children = (node.children as MarkdownNode[]).map((x, i) => ({\n        ...x,\n        align: align[i],\n        isHeader: node.isHeader,\n      }))\n      state.openNode(type)\n      state.next(children)\n      state.closeNode()\n    },\n  },\n  toMarkdown: {\n    match: (node) => node.type.name === 'table_header_row',\n    runner: (state, node) => {\n      state.openNode('tableRow', undefined, { isHeader: true })\n      state.next(node.content)\n      state.closeNode()\n    },\n  },\n}))\n\nwithMeta(tableHeaderRowSchema.node, {\n  displayName: 'NodeSchema<tableHeaderRow>',\n  group: 'Table',\n})\n\nwithMeta(tableHeaderRowSchema.ctx, {\n  displayName: 'NodeSchemaCtx<tableHeaderRow>',\n  group: 'Table',\n})\n\n/// Schema for table row node.\nexport const tableRowSchema = $nodeSchema('table_row', () => ({\n  ...originalSchema.table_row,\n  disableDropCursor: true,\n  content: '(table_cell)*',\n  parseMarkdown: {\n    match: (node) => node.type === 'tableRow',\n    runner: (state, node, type) => {\n      const align = node.align as (string | null)[]\n      const children = (node.children as MarkdownNode[]).map((x, i) => ({\n        ...x,\n        align: align[i],\n      }))\n      state.openNode(type)\n      state.next(children)\n      state.closeNode()\n    },\n  },\n  toMarkdown: {\n    match: (node) => node.type.name === 'table_row',\n    runner: (state, node) => {\n      // if the row is empty, we don't need to create a table row\n      // prevent remark from crashing\n      if (node.content.size === 0) {\n        return\n      }\n      state.openNode('tableRow')\n      state.next(node.content)\n      state.closeNode()\n    },\n  },\n}))\n\nwithMeta(tableRowSchema.node, {\n  displayName: 'NodeSchema<tableRow>',\n  group: 'Table',\n})\n\nwithMeta(tableRowSchema.ctx, {\n  displayName: 'NodeSchemaCtx<tableRow>',\n  group: 'Table',\n})\n\n/// Schema for table cell node.\nexport const tableCellSchema = $nodeSchema('table_cell', () => ({\n  ...originalSchema.table_cell,\n  disableDropCursor: true,\n  parseMarkdown: {\n    match: (node) => node.type === 'tableCell' && !node.isHeader,\n    runner: (state, node, type) => {\n      const align = node.align as string\n      state\n        .openNode(type, { alignment: align })\n        .openNode(state.schema.nodes.paragraph as NodeType)\n        .next(node.children)\n        .closeNode()\n        .closeNode()\n    },\n  },\n  toMarkdown: {\n    match: (node) => node.type.name === 'table_cell',\n    runner: (state, node) => {\n      state.openNode('tableCell').next(node.content).closeNode()\n    },\n  },\n}))\n\nwithMeta(tableCellSchema.node, {\n  displayName: 'NodeSchema<tableCell>',\n  group: 'Table',\n})\n\nwithMeta(tableCellSchema.ctx, {\n  displayName: 'NodeSchemaCtx<tableCell>',\n  group: 'Table',\n})\n\n/// Schema for table header node.\nexport const tableHeaderSchema = $nodeSchema('table_header', () => ({\n  ...originalSchema.table_header,\n  disableDropCursor: true,\n  parseMarkdown: {\n    match: (node) => node.type === 'tableCell' && !!node.isHeader,\n    runner: (state, node, type) => {\n      const align = node.align as string\n      state.openNode(type, { alignment: align })\n      state.openNode(state.schema.nodes.paragraph as NodeType)\n      state.next(node.children)\n      state.closeNode()\n      state.closeNode()\n    },\n  },\n  toMarkdown: {\n    match: (node) => node.type.name === 'table_header',\n    runner: (state, node) => {\n      state.openNode('tableCell')\n      state.next(node.content)\n      state.closeNode()\n    },\n  },\n}))\n\nwithMeta(tableHeaderSchema.node, {\n  displayName: 'NodeSchema<tableHeader>',\n  group: 'Table',\n})\n\nwithMeta(tableHeaderSchema.ctx, {\n  displayName: 'NodeSchemaCtx<tableHeader>',\n  group: 'Table',\n})\n","import type { Ctx } from '@milkdown/ctx'\nimport type { ContentNodeWithPos } from '@milkdown/prose'\nimport type { Node, ResolvedPos } from '@milkdown/prose/model'\nimport type { Selection, Transaction } from '@milkdown/prose/state'\nimport type { TableRect } from '@milkdown/prose/tables'\n\nimport { cloneTr, findParentNodeClosestToPos } from '@milkdown/prose'\nimport { CellSelection, TableMap } from '@milkdown/prose/tables'\n\nimport {\n  tableCellSchema,\n  tableHeaderRowSchema,\n  tableHeaderSchema,\n  tableRowSchema,\n  tableSchema,\n} from './schema'\n\n/// @internal\nexport interface CellPos {\n  pos: number\n  start: number\n  node: Node\n}\n\n/// @internal\nexport function createTable(ctx: Ctx, rowsCount = 3, colsCount = 3): Node {\n  const cells = Array(colsCount)\n    .fill(0)\n    .map(() => tableCellSchema.type(ctx).createAndFill()!)\n\n  const headerCells = Array(colsCount)\n    .fill(0)\n    .map(() => tableHeaderSchema.type(ctx).createAndFill()!)\n\n  const rows = Array(rowsCount)\n    .fill(0)\n    .map((_, i) =>\n      i === 0\n        ? tableHeaderRowSchema.type(ctx).create(null, headerCells)\n        : tableRowSchema.type(ctx).create(null, cells)\n    )\n\n  return tableSchema.type(ctx).create(null, rows)\n}\n\n/// Find the table node with position information for target pos.\nexport function findTable($pos: ResolvedPos) {\n  return findParentNodeClosestToPos(\n    (node) => node.type.spec.tableRole === 'table'\n  )($pos)\n}\n\n/// Get cells in a column of a table.\nexport function getCellsInCol(\n  columnIndex: number,\n  selection: Selection\n): CellPos[] | undefined {\n  const table = findTable(selection.$from)\n  if (!table) return undefined\n  const map = TableMap.get(table.node)\n  if (columnIndex < 0 || columnIndex >= map.width) return undefined\n\n  return map\n    .cellsInRect({\n      left: columnIndex,\n      right: columnIndex + 1,\n      top: 0,\n      bottom: map.height,\n    })\n    .map((pos) => {\n      const node = table.node.nodeAt(pos)\n      if (!node) return undefined\n      const start = pos + table.start\n      return {\n        pos: start,\n        start: start + 1,\n        node,\n      }\n    })\n    .filter((x): x is CellPos => x != null)\n}\n\n/// Get cells in a row of a table.\nexport function getCellsInRow(\n  rowIndex: number,\n  selection: Selection\n): CellPos[] | undefined {\n  const table = findTable(selection.$from)\n  if (!table) return undefined\n  const map = TableMap.get(table.node)\n  if (rowIndex < 0 || rowIndex >= map.height) return undefined\n\n  return map\n    .cellsInRect({\n      left: 0,\n      right: map.width,\n      top: rowIndex,\n      bottom: rowIndex + 1,\n    })\n    .map((pos) => {\n      const node = table.node.nodeAt(pos)\n      if (!node) return undefined\n      const start = pos + table.start\n      return {\n        pos: start,\n        start: start + 1,\n        node,\n      }\n    })\n    .filter((x): x is CellPos => x != null)\n}\n\n/// Get all cells in a table.\nexport function getAllCellsInTable(selection: Selection) {\n  const table = findTable(selection.$from)\n  if (!table) return\n\n  const map = TableMap.get(table.node)\n  const cells = map.cellsInRect({\n    left: 0,\n    right: map.width,\n    top: 0,\n    bottom: map.height,\n  })\n  return cells.map((nodePos) => {\n    const node = table.node.nodeAt(nodePos)\n    const pos = nodePos + table.start\n    return { pos, start: pos + 1, node }\n  })\n}\n\n/// Select a possible table in current selection.\nexport function selectTable(tr: Transaction) {\n  const cells = getAllCellsInTable(tr.selection)\n  if (cells && cells[0]) {\n    const $firstCell = tr.doc.resolve(cells[0].pos)\n    const last = cells[cells.length - 1]\n    if (last) {\n      const $lastCell = tr.doc.resolve(last.pos)\n      return cloneTr(tr.setSelection(new CellSelection($lastCell, $firstCell)))\n    }\n  }\n  return tr\n}\n\n/// @internal\nexport function addRowWithAlignment(\n  ctx: Ctx,\n  tr: Transaction,\n  { map, tableStart, table }: TableRect,\n  row: number\n) {\n  const rowPos = Array(row)\n    .fill(0)\n    .reduce((acc, _, i) => {\n      return acc + table.child(i).nodeSize\n    }, tableStart)\n\n  const cells = Array(map.width)\n    .fill(0)\n    .map((_, col) => {\n      const headerCol = table.nodeAt(map.map[col] as number)\n      return tableCellSchema\n        .type(ctx)\n        .createAndFill({ alignment: headerCol?.attrs.alignment }) as Node\n    })\n\n  tr.insert(rowPos, tableRowSchema.type(ctx).create(null, cells))\n  return tr\n}\n\n/// @internal\nexport function selectLine(type: 'row' | 'col') {\n  return (index: number, pos?: number) => (tr: Transaction) => {\n    pos = pos ?? tr.selection.from\n    const $pos = tr.doc.resolve(pos)\n    const $node = findParentNodeClosestToPos(\n      (node) => node.type.name === 'table'\n    )($pos)\n    const table = $node\n      ? {\n          node: $node.node,\n          from: $node.start,\n        }\n      : undefined\n\n    const isRowSelection = type === 'row'\n    if (table) {\n      const map = TableMap.get(table.node)\n\n      // Check if the index is valid\n      if (index >= 0 && index < (isRowSelection ? map.height : map.width)) {\n        const lastCell = map.positionAt(\n          isRowSelection ? index : map.height - 1,\n          isRowSelection ? map.width - 1 : index,\n          table.node\n        )\n        const $lastCell = tr.doc.resolve(table.from + lastCell)\n\n        const createCellSelection = isRowSelection\n          ? CellSelection.rowSelection\n          : CellSelection.colSelection\n\n        const firstCell = map.positionAt(\n          isRowSelection ? index : 0,\n          isRowSelection ? 0 : index,\n          table.node\n        )\n        const $firstCell = tr.doc.resolve(table.from + firstCell)\n        return cloneTr(\n          tr.setSelection(\n            createCellSelection($lastCell, $firstCell) as unknown as Selection\n          )\n        )\n      }\n    }\n    return tr\n  }\n}\n\n/// If the selection is in a table,\n/// select the {index} row.\nexport const selectRow = selectLine('row')\n\n/// If the selection is in a table,\n/// select the {index} column.\nexport const selectCol = selectLine('col')\n\nfunction transpose<T>(array: T[][]) {\n  return array[0]!.map((_, i) => {\n    return array.map((column) => column[i])\n  }) as T[][]\n}\n\nfunction convertArrayOfRowsToTableNode(\n  tableNode: Node,\n  arrayOfNodes: (Node | null)[][]\n) {\n  const rowsPM = []\n  const map = TableMap.get(tableNode)\n  for (let rowIndex = 0; rowIndex < map.height; rowIndex++) {\n    const row = tableNode.child(rowIndex)\n    const rowCells = []\n\n    for (let colIndex = 0; colIndex < map.width; colIndex++) {\n      if (!arrayOfNodes[rowIndex]![colIndex]) continue\n\n      const cellPos = map.map[rowIndex * map.width + colIndex]!\n\n      const cell = arrayOfNodes[rowIndex]![colIndex]!\n      const oldCell = tableNode.nodeAt(cellPos)!\n      const newCell = oldCell.type.createChecked(\n        Object.assign({}, cell.attrs),\n        cell.content,\n        cell.marks\n      )\n      rowCells.push(newCell)\n    }\n\n    rowsPM.push(row.type.createChecked(row.attrs, rowCells, row.marks))\n  }\n\n  const newTable = tableNode.type.createChecked(\n    tableNode.attrs,\n    rowsPM,\n    tableNode.marks\n  )\n\n  return newTable\n}\n\nfunction convertTableNodeToArrayOfRows(tableNode: Node) {\n  const map = TableMap.get(tableNode)\n  const rows: (Node | null)[][] = []\n  for (let rowIndex = 0; rowIndex < map.height; rowIndex++) {\n    const rowCells: (Node | null)[] = []\n    const seen: Record<number, boolean> = {}\n\n    for (let colIndex = 0; colIndex < map.width; colIndex++) {\n      const cellPos = map.map[rowIndex * map.width + colIndex]!\n      const cell = tableNode.nodeAt(cellPos)\n      const rect = map.findCell(cellPos)\n      if (seen[cellPos] || rect.top !== rowIndex) {\n        rowCells.push(null)\n        continue\n      }\n      seen[cellPos] = true\n\n      rowCells.push(cell)\n    }\n\n    rows.push(rowCells)\n  }\n\n  return rows\n}\n\nfunction moveRowInArrayOfRows(\n  rows: (Node | null)[][],\n  indexesOrigin: number[],\n  indexesTarget: number[],\n  directionOverride: -1 | 1 | 0\n) {\n  const direction = indexesOrigin[0]! > indexesTarget[0]! ? -1 : 1\n\n  const rowsExtracted = rows.splice(indexesOrigin[0]!, indexesOrigin.length)\n  const positionOffset = rowsExtracted.length % 2 === 0 ? 1 : 0\n  let target: number\n\n  if (directionOverride === -1 && direction === 1) {\n    target = indexesTarget[0]! - 1\n  } else if (directionOverride === 1 && direction === -1) {\n    target = indexesTarget[indexesTarget.length - 1]! - positionOffset + 1\n  } else {\n    target =\n      direction === -1\n        ? indexesTarget[0]!\n        : indexesTarget[indexesTarget.length - 1]! - positionOffset\n  }\n\n  rows.splice(target, 0, ...rowsExtracted)\n  return rows\n}\n\nfunction moveTableColumn(\n  table: ContentNodeWithPos,\n  indexesOrigin: number[],\n  indexesTarget: number[],\n  direction: -1 | 1 | 0\n) {\n  let rows = transpose(convertTableNodeToArrayOfRows(table.node))\n\n  rows = moveRowInArrayOfRows(rows, indexesOrigin, indexesTarget, direction)\n  rows = transpose(rows)\n\n  return convertArrayOfRowsToTableNode(table.node, rows)\n}\n\nfunction moveTableRow(\n  table: ContentNodeWithPos,\n  indexesOrigin: number[],\n  indexesTarget: number[],\n  direction: -1 | 1 | 0\n) {\n  let rows = convertTableNodeToArrayOfRows(table.node)\n\n  rows = moveRowInArrayOfRows(rows, indexesOrigin, indexesTarget, direction)\n\n  return convertArrayOfRowsToTableNode(table.node, rows)\n}\n\nfunction getSelectionRangeInColumn(columnIndex: number, tr: Transaction) {\n  let startIndex = columnIndex\n  let endIndex = columnIndex\n\n  // looking for selection start column (startIndex)\n  for (let i = columnIndex; i >= 0; i--) {\n    const cells = getCellsInCol(i, tr.selection)\n    if (cells) {\n      cells.forEach((cell) => {\n        const maybeEndIndex = cell.node.attrs.colspan + i - 1\n        if (maybeEndIndex >= startIndex) startIndex = i\n\n        if (maybeEndIndex > endIndex) endIndex = maybeEndIndex\n      })\n    }\n  }\n  // looking for selection end column (endIndex)\n  for (let i = columnIndex; i <= endIndex; i++) {\n    const cells = getCellsInCol(i, tr.selection)\n    if (cells) {\n      cells.forEach((cell) => {\n        const maybeEndIndex = cell.node.attrs.colspan + i - 1\n        if (cell.node.attrs.colspan > 1 && maybeEndIndex > endIndex)\n          endIndex = maybeEndIndex\n      })\n    }\n  }\n\n  // filter out columns without cells (where all rows have colspan > 1 in the same column)\n  const indexes = []\n  for (let i = startIndex; i <= endIndex; i++) {\n    const maybeCells = getCellsInCol(i, tr.selection)\n    if (maybeCells && maybeCells.length) indexes.push(i)\n  }\n  startIndex = indexes[0]!\n  endIndex = indexes[indexes.length - 1]!\n\n  const firstSelectedColumnCells = getCellsInCol(startIndex, tr.selection)!\n  const firstRowCells = getCellsInRow(0, tr.selection)!\n  const $anchor = tr.doc.resolve(\n    firstSelectedColumnCells[firstSelectedColumnCells.length - 1]!.pos\n  )\n\n  let headCell: CellPos | undefined\n  for (let i = endIndex; i >= startIndex; i--) {\n    const columnCells = getCellsInCol(i, tr.selection)\n    if (columnCells && columnCells.length) {\n      for (let j = firstRowCells.length - 1; j >= 0; j--) {\n        if (firstRowCells[j]!.pos === columnCells[0]!.pos) {\n          headCell = columnCells[0]\n          break\n        }\n      }\n      if (headCell) break\n    }\n  }\n\n  const $head = tr.doc.resolve(headCell!.pos)\n  return { $anchor, $head, indexes }\n}\n\nfunction getSelectionRangeInRow(rowIndex: number, tr: Transaction) {\n  let startIndex = rowIndex\n  let endIndex = rowIndex\n  // looking for selection start row (startIndex)\n  for (let i = rowIndex; i >= 0; i--) {\n    const cells = getCellsInRow(i, tr.selection)\n    cells!.forEach((cell) => {\n      const maybeEndIndex = cell.node.attrs.rowspan + i - 1\n      if (maybeEndIndex >= startIndex) startIndex = i\n\n      if (maybeEndIndex > endIndex) endIndex = maybeEndIndex\n    })\n  }\n  // looking for selection end row (endIndex)\n  for (let i = rowIndex; i <= endIndex; i++) {\n    const cells = getCellsInRow(i, tr.selection)\n    cells!.forEach((cell) => {\n      const maybeEndIndex = cell.node.attrs.rowspan + i - 1\n      if (cell.node.attrs.rowspan > 1 && maybeEndIndex > endIndex)\n        endIndex = maybeEndIndex\n    })\n  }\n\n  // filter out rows without cells (where all columns have rowspan > 1 in the same row)\n  const indexes = []\n  for (let i = startIndex; i <= endIndex; i++) {\n    const maybeCells = getCellsInRow(i, tr.selection)\n    if (maybeCells && maybeCells.length) indexes.push(i)\n  }\n  startIndex = indexes[0]!\n  endIndex = indexes[indexes.length - 1]!\n\n  const firstSelectedRowCells = getCellsInRow(startIndex, tr.selection)!\n  const firstColumnCells = getCellsInCol(0, tr.selection)!\n  const $anchor = tr.doc.resolve(\n    firstSelectedRowCells[firstSelectedRowCells.length - 1]!.pos\n  )\n\n  let headCell: CellPos | undefined\n  for (let i = endIndex; i >= startIndex; i--) {\n    const rowCells = getCellsInRow(i, tr.selection)\n    if (rowCells && rowCells.length) {\n      for (let j = firstColumnCells.length - 1; j >= 0; j--) {\n        if (firstColumnCells[j]!.pos === rowCells[0]!.pos) {\n          headCell = rowCells[0]!\n          break\n        }\n      }\n      if (headCell) break\n    }\n  }\n\n  const $head = tr.doc.resolve(headCell!.pos)\n  return { $anchor, $head, indexes }\n}\n\nexport interface MoveColParams {\n  tr: Transaction\n  origin: number\n  target: number\n  select?: boolean\n  pos?: number\n}\n\n/// If the selection is in a table,\n/// Move the columns at `origin` to `target` in current table.\n/// The `select` is true by default, which means the selection will be set to the moved column.\nexport function moveCol(moveColParams: MoveColParams) {\n  const { tr, origin, target, select = true, pos } = moveColParams\n  const $pos = pos != null ? tr.doc.resolve(pos) : tr.selection.$from\n  const table = findTable($pos)\n  if (!table) return tr\n\n  const { indexes: indexesOriginColumn } = getSelectionRangeInColumn(origin, tr)\n  const { indexes: indexesTargetColumn } = getSelectionRangeInColumn(target, tr)\n\n  if (indexesOriginColumn.includes(target)) return tr\n\n  const newTable = moveTableColumn(\n    table,\n    indexesOriginColumn,\n    indexesTargetColumn,\n    0\n  )\n\n  const _tr = cloneTr(tr).replaceWith(\n    table.pos,\n    table.pos + table.node.nodeSize,\n    newTable\n  )\n\n  if (!select) return _tr\n\n  const map = TableMap.get(newTable)\n  const start = table.start\n  const index = target\n  const lastCell = map.positionAt(map.height - 1, index, newTable)\n  const $lastCell = _tr.doc.resolve(start + lastCell)\n\n  const createCellSelection = CellSelection.colSelection\n\n  const firstCell = map.positionAt(0, index, newTable)\n  const $firstCell = _tr.doc.resolve(start + firstCell)\n\n  return _tr.setSelection(createCellSelection($lastCell, $firstCell))\n}\n\nexport interface MoveRowParams {\n  tr: Transaction\n  origin: number\n  target: number\n  select?: boolean\n  pos?: number\n}\n\n/// If the selection is in a table,\n/// Move the rows at `origin` and `target` in current table.\n/// The `select` is true by default, which means the selection will be set to the moved row.\nexport function moveRow(moveRowParams: MoveRowParams) {\n  const { tr, origin, target, select = true, pos } = moveRowParams\n  const $pos = pos != null ? tr.doc.resolve(pos) : tr.selection.$from\n  const table = findTable($pos)\n  if (!table) return tr\n\n  const { indexes: indexesOriginRow } = getSelectionRangeInRow(origin, tr)\n  const { indexes: indexesTargetRow } = getSelectionRangeInRow(target, tr)\n\n  if (indexesOriginRow.includes(target)) return tr\n\n  const newTable = moveTableRow(table, indexesOriginRow, indexesTargetRow, 0)\n\n  const _tr = cloneTr(tr).replaceWith(\n    table.pos,\n    table.pos + table.node.nodeSize,\n    newTable\n  )\n\n  if (!select) return _tr\n\n  const map = TableMap.get(newTable)\n  const start = table.start\n  const index = target\n  const lastCell = map.positionAt(index, map.width - 1, newTable)\n  const $lastCell = _tr.doc.resolve(start + lastCell)\n\n  const createCellSelection = CellSelection.rowSelection\n\n  const firstCell = map.positionAt(index, 0, newTable)\n  const $firstCell = _tr.doc.resolve(start + firstCell)\n\n  return _tr.setSelection(createCellSelection($lastCell, $firstCell))\n}\n","import { paragraphSchema } from '@milkdown/preset-commonmark'\nimport { findParentNodeType } from '@milkdown/prose'\nimport { Selection } from '@milkdown/prose/state'\nimport {\n  CellSelection,\n  addColumnAfter,\n  addColumnBefore,\n  deleteColumn,\n  deleteRow,\n  deleteTable,\n  goToNextCell,\n  isInTable,\n  selectedRect,\n  setCellAttr,\n} from '@milkdown/prose/tables'\nimport { $command } from '@milkdown/utils'\n\nimport { withMeta } from '../../__internal__'\nimport { tableSchema } from './schema'\nimport {\n  addRowWithAlignment,\n  createTable,\n  moveCol,\n  moveRow,\n  selectCol,\n  selectRow,\n  selectTable,\n} from './utils'\n\n/// A command for moving cursor to previous cell.\nexport const goToPrevTableCellCommand = $command(\n  'GoToPrevTableCell',\n  () => () => goToNextCell(-1)\n)\n\nwithMeta(goToPrevTableCellCommand, {\n  displayName: 'Command<goToPrevTableCellCommand>',\n  group: 'Table',\n})\n\n/// A command for moving cursor to next cell.\nexport const goToNextTableCellCommand = $command(\n  'GoToNextTableCell',\n  () => () => goToNextCell(1)\n)\n\nwithMeta(goToNextTableCellCommand, {\n  displayName: 'Command<goToNextTableCellCommand>',\n  group: 'Table',\n})\n\n/// A command for quitting current table and insert a new paragraph node.\nexport const exitTable = $command(\n  'ExitTable',\n  (ctx) => () => (state, dispatch) => {\n    if (!isInTable(state)) return false\n\n    const { $head } = state.selection\n    const table = findParentNodeType($head, tableSchema.type(ctx))\n    if (!table) return false\n\n    const { to } = table\n\n    const tr = state.tr.replaceWith(\n      to,\n      to,\n      paragraphSchema.type(ctx).createAndFill()!\n    )\n\n    tr.setSelection(Selection.near(tr.doc.resolve(to), 1)).scrollIntoView()\n    dispatch?.(tr)\n    return true\n  }\n)\n\nwithMeta(exitTable, {\n  displayName: 'Command<breakTableCommand>',\n  group: 'Table',\n})\n\n/// A command for inserting a table.\n/// You can specify the number of rows and columns.\n/// By default, it will insert a 3x3 table.\nexport const insertTableCommand = $command(\n  'InsertTable',\n  (ctx) =>\n    ({ row, col }: { row?: number; col?: number } = {}) =>\n    (state, dispatch) => {\n      const { selection, tr } = state\n      const { from } = selection\n      const table = createTable(ctx, row, col)\n      const _tr = tr.replaceSelectionWith(table)\n      const sel = Selection.findFrom(_tr.doc.resolve(from), 1, true)\n      if (sel) _tr.setSelection(sel)\n\n      dispatch?.(_tr)\n\n      return true\n    }\n)\n\nwithMeta(insertTableCommand, {\n  displayName: 'Command<insertTableCommand>',\n  group: 'Table',\n})\n\n/// A command for moving a row in a table.\n/// You should specify the `from` and `to` index.\nexport const moveRowCommand = $command(\n  'MoveRow',\n  () =>\n    ({ from, to, pos }: { from?: number; to?: number; pos?: number } = {}) =>\n    (state, dispatch) => {\n      const { tr } = state\n      const result = dispatch?.(\n        moveRow({ tr, origin: from ?? 0, target: to ?? 0, pos, select: true })\n      )\n\n      return Boolean(result)\n    }\n)\n\nwithMeta(moveRowCommand, {\n  displayName: 'Command<moveRowCommand>',\n  group: 'Table',\n})\n\n/// A command for moving a column in a table.\n/// You should specify the `from` and `to` index.\nexport const moveColCommand = $command(\n  'MoveCol',\n  () =>\n    ({ from, to, pos }: { from?: number; to?: number; pos?: number } = {}) =>\n    (state, dispatch) => {\n      const { tr } = state\n      const result = dispatch?.(\n        moveCol({ tr, origin: from ?? 0, target: to ?? 0, pos, select: true })\n      )\n\n      return Boolean(result)\n    }\n)\n\nwithMeta(moveColCommand, {\n  displayName: 'Command<moveColCommand>',\n  group: 'Table',\n})\n\n/// A command for selecting a row.\nexport const selectRowCommand = $command<\n  { index: number; pos?: number },\n  'SelectRow'\n>(\n  'SelectRow',\n  () =>\n    (payload: { index: number; pos?: number } = { index: 0 }) =>\n    (state, dispatch) => {\n      const { tr } = state\n      const result = dispatch?.(selectRow(payload.index, payload.pos)(tr))\n\n      return Boolean(result)\n    }\n)\n\nwithMeta(selectRowCommand, {\n  displayName: 'Command<selectRowCommand>',\n  group: 'Table',\n})\n\n/// A command for selecting a column.\nexport const selectColCommand = $command<\n  { index: number; pos?: number },\n  'SelectCol'\n>(\n  'SelectCol',\n  () =>\n    (payload: { index: number; pos?: number } = { index: 0 }) =>\n    (state, dispatch) => {\n      const { tr } = state\n      const result = dispatch?.(selectCol(payload.index, payload.pos)(tr))\n\n      return Boolean(result)\n    }\n)\n\nwithMeta(selectColCommand, {\n  displayName: 'Command<selectColCommand>',\n  group: 'Table',\n})\n\n/// A command for selecting a table.\nexport const selectTableCommand = $command(\n  'SelectTable',\n  () => () => (state, dispatch) => {\n    const { tr } = state\n    const result = dispatch?.(selectTable(tr))\n\n    return Boolean(result)\n  }\n)\n\nwithMeta(selectTableCommand, {\n  displayName: 'Command<selectTableCommand>',\n  group: 'Table',\n})\n\n/// A command for deleting selected cells.\n/// If the selection is a row or column, the row or column will be deleted.\n/// If all cells are selected, the table will be deleted.\nexport const deleteSelectedCellsCommand = $command(\n  'DeleteSelectedCells',\n  () => () => (state, dispatch) => {\n    const { selection } = state\n    if (!(selection instanceof CellSelection)) return false\n\n    const isRow = selection.isRowSelection()\n    const isCol = selection.isColSelection()\n\n    if (isRow && isCol) return deleteTable(state, dispatch)\n\n    if (isCol) return deleteColumn(state, dispatch)\n    else return deleteRow(state, dispatch)\n  }\n)\n\nwithMeta(deleteSelectedCellsCommand, {\n  displayName: 'Command<deleteSelectedCellsCommand>',\n  group: 'Table',\n})\n\n/// A command for adding a column before the current column.\nexport const addColBeforeCommand = $command(\n  'AddColBefore',\n  () => () => addColumnBefore\n)\n\nwithMeta(addColBeforeCommand, {\n  displayName: 'Command<addColBeforeCommand>',\n  group: 'Table',\n})\n\n/// A command for adding a column after the current column.\nexport const addColAfterCommand = $command(\n  'AddColAfter',\n  () => () => addColumnAfter\n)\n\nwithMeta(addColAfterCommand, {\n  displayName: 'Command<addColAfterCommand>',\n  group: 'Table',\n})\n\n/// A command for adding a row before the current row.\nexport const addRowBeforeCommand = $command(\n  'AddRowBefore',\n  (ctx) => () => (state, dispatch) => {\n    if (!isInTable(state)) return false\n    if (dispatch) {\n      const rect = selectedRect(state)\n      dispatch(addRowWithAlignment(ctx, state.tr, rect, rect.top))\n    }\n    return true\n  }\n)\n\nwithMeta(addRowBeforeCommand, {\n  displayName: 'Command<addRowBeforeCommand>',\n  group: 'Table',\n})\n\n/// A command for adding a row after the current row.\nexport const addRowAfterCommand = $command(\n  'AddRowAfter',\n  (ctx) => () => (state, dispatch) => {\n    if (!isInTable(state)) return false\n    if (dispatch) {\n      const rect = selectedRect(state)\n      dispatch(addRowWithAlignment(ctx, state.tr, rect, rect.bottom))\n    }\n    return true\n  }\n)\n\nwithMeta(addRowAfterCommand, {\n  displayName: 'Command<addRowAfterCommand>',\n  group: 'Table',\n})\n\n/// A command for setting alignment property for selected cells.\n/// You can specify the alignment as `left`, `center`, or `right`.\n/// It's `left` by default.\nexport const setAlignCommand = $command<\n  'left' | 'center' | 'right',\n  'SetAlign'\n>(\n  'SetAlign',\n  () =>\n    (alignment = 'left') =>\n      setCellAttr('alignment', alignment)\n)\n\nwithMeta(setAlignCommand, {\n  displayName: 'Command<setAlignCommand>',\n  group: 'Table',\n})\n","import { commandsCtx } from '@milkdown/core'\nimport { InputRule } from '@milkdown/prose/inputrules'\nimport { TextSelection } from '@milkdown/prose/state'\nimport { $inputRule, $useKeymap } from '@milkdown/utils'\n\nimport { withMeta } from '../../__internal__'\nimport {\n  exitTable,\n  goToNextTableCellCommand,\n  goToPrevTableCellCommand,\n} from './command'\nimport { tableSchema } from './schema'\nimport { createTable } from './utils'\n\n/// A input rule for creating table.\n/// For example, `|2x2|` will create a 2x2 table.\nexport const insertTableInputRule = $inputRule(\n  (ctx) =>\n    new InputRule(\n      /^\\|(?<col>\\d+)[xX](?<row>\\d+)\\|\\s$/,\n      (state, match, start, end) => {\n        const $start = state.doc.resolve(start)\n        if (\n          !$start\n            .node(-1)\n            .canReplaceWith(\n              $start.index(-1),\n              $start.indexAfter(-1),\n              tableSchema.type(ctx)\n            )\n        )\n          return null\n\n        const row = Math.max(Number(match.groups?.row ?? 0), 2)\n\n        const tableNode = createTable(ctx, row, Number(match.groups?.col))\n        const tr = state.tr.replaceRangeWith(start, end, tableNode)\n        return tr\n          .setSelection(TextSelection.create(tr.doc, start + 3))\n          .scrollIntoView()\n      }\n    )\n)\n\nwithMeta(insertTableInputRule, {\n  displayName: 'InputRule<insertTableInputRule>',\n  group: 'Table',\n})\n\n/// Keymap for table commands.\n/// - `<Mod-]>`/`<Tab>`: Move to the next cell.\n/// - `<Mod-[>`/`<Shift-Tab>`: Move to the previous cell.\n/// - `<Mod-Enter>`: Exit the table, and break it if possible.\nexport const tableKeymap = $useKeymap('tableKeymap', {\n  NextCell: {\n    shortcuts: ['Mod-]', 'Tab'],\n    command: (ctx) => {\n      const commands = ctx.get(commandsCtx)\n\n      return () => commands.call(goToNextTableCellCommand.key)\n    },\n  },\n  PrevCell: {\n    shortcuts: ['Mod-[', 'Shift-Tab'],\n    command: (ctx) => {\n      const commands = ctx.get(commandsCtx)\n\n      return () => commands.call(goToPrevTableCellCommand.key)\n    },\n  },\n  ExitTable: {\n    shortcuts: ['Mod-Enter', 'Enter'],\n    command: (ctx) => {\n      const commands = ctx.get(commandsCtx)\n\n      return () => commands.call(exitTable.key)\n    },\n  },\n})\n\nwithMeta(tableKeymap.ctx, {\n  displayName: 'KeymapCtx<table>',\n  group: 'Table',\n})\n\nwithMeta(tableKeymap.shortcuts, {\n  displayName: 'Keymap<table>',\n  group: 'Table',\n})\n","import { expectDomTypeError } from '@milkdown/exception'\nimport { $nodeSchema } from '@milkdown/utils'\n\nimport { withMeta } from '../../__internal__'\n\nconst id = 'footnote_definition'\nconst markdownId = 'footnoteDefinition'\n\n/// Footnote definition node schema.\nexport const footnoteDefinitionSchema = $nodeSchema(\n  'footnote_definition',\n  () => ({\n    group: 'block',\n    content: 'block+',\n    defining: true,\n    attrs: {\n      label: {\n        default: '',\n        validate: 'string',\n      },\n    },\n    parseDOM: [\n      {\n        tag: `dl[data-type=\"${id}\"]`,\n        getAttrs: (dom) => {\n          if (!(dom instanceof HTMLElement)) throw expectDomTypeError(dom)\n\n          return {\n            label: dom.dataset.label,\n          }\n        },\n        contentElement: 'dd',\n      },\n    ],\n    toDOM: (node) => {\n      const label = node.attrs.label\n\n      return [\n        'dl',\n        {\n          // TODO: add a prosemirror plugin to sync label on change\n          'data-label': label,\n          'data-type': id,\n        },\n        ['dt', label],\n        ['dd', 0],\n      ]\n    },\n    parseMarkdown: {\n      match: ({ type }) => type === markdownId,\n      runner: (state, node, type) => {\n        state\n          .openNode(type, {\n            label: node.label as string,\n          })\n          .next(node.children)\n          .closeNode()\n      },\n    },\n    toMarkdown: {\n      match: (node) => node.type.name === id,\n      runner: (state, node) => {\n        state\n          .openNode(markdownId, undefined, {\n            label: node.attrs.label,\n            identifier: node.attrs.label,\n          })\n          .next(node.content)\n          .closeNode()\n      },\n    },\n  })\n)\n\nwithMeta(footnoteDefinitionSchema.ctx, {\n  displayName: 'NodeSchemaCtx<footnodeDef>',\n  group: 'footnote',\n})\n\nwithMeta(footnoteDefinitionSchema.node, {\n  displayName: 'NodeSchema<footnodeDef>',\n  group: 'footnote',\n})\n","import { expectDomTypeError } from '@milkdown/exception'\nimport { $nodeSchema } from '@milkdown/utils'\n\nimport { withMeta } from '../../__internal__'\n\nconst id = 'footnote_reference'\n\n/// Footnote reference node schema.\nexport const footnoteReferenceSchema = $nodeSchema(\n  'footnote_reference',\n  () => ({\n    group: 'inline',\n    inline: true,\n    atom: true,\n    attrs: {\n      label: {\n        default: '',\n        validate: 'string',\n      },\n    },\n    parseDOM: [\n      {\n        tag: `sup[data-type=\"${id}\"]`,\n        getAttrs: (dom) => {\n          if (!(dom instanceof HTMLElement)) throw expectDomTypeError(dom)\n\n          return {\n            label: dom.dataset.label,\n          }\n        },\n      },\n    ],\n    toDOM: (node) => {\n      const label = node.attrs.label\n      return [\n        'sup',\n        {\n          // TODO: add a prosemirror plugin to sync label on change\n          'data-label': label,\n          'data-type': id,\n        },\n        label,\n      ]\n    },\n    parseMarkdown: {\n      match: ({ type }) => type === 'footnoteReference',\n      runner: (state, node, type) => {\n        state.addNode(type, {\n          label: node.label as string,\n        })\n      },\n    },\n    toMarkdown: {\n      match: (node) => node.type.name === id,\n      runner: (state, node) => {\n        state.addNode('footnoteReference', undefined, undefined, {\n          label: node.attrs.label,\n          identifier: node.attrs.label,\n        })\n      },\n    },\n  })\n)\n\nwithMeta(footnoteReferenceSchema.ctx, {\n  displayName: 'NodeSchemaCtx<footnodeRef>',\n  group: 'footnote',\n})\n\nwithMeta(footnoteReferenceSchema.node, {\n  displayName: 'NodeSchema<footnodeRef>',\n  group: 'footnote',\n})\n","import { expectDomTypeError } from '@milkdown/exception'\nimport { listItemSchema } from '@milkdown/preset-commonmark'\nimport { InputRule } from '@milkdown/prose/inputrules'\nimport { $inputRule } from '@milkdown/utils'\n\nimport { withMeta } from '../__internal__'\n\n/// This schema extends the [list item](/preset-commonmark#list-item) schema and add task list support for it.\nexport const extendListItemSchemaForTask = listItemSchema.extendSchema(\n  (prev) => {\n    return (ctx) => {\n      const baseSchema = prev(ctx)\n      return {\n        ...baseSchema,\n        attrs: {\n          ...baseSchema.attrs,\n          checked: {\n            default: null,\n            validate: 'boolean|null',\n          },\n        },\n        parseDOM: [\n          {\n            tag: 'li[data-item-type=\"task\"]',\n            getAttrs: (dom) => {\n              if (!(dom instanceof HTMLElement)) throw expectDomTypeError(dom)\n\n              return {\n                label: dom.dataset.label,\n                listType: dom.dataset.listType,\n                spread: dom.dataset.spread,\n                checked: dom.dataset.checked\n                  ? dom.dataset.checked === 'true'\n                  : null,\n              }\n            },\n          },\n          ...(baseSchema?.parseDOM || []),\n        ],\n        toDOM: (node) => {\n          if (baseSchema.toDOM && node.attrs.checked == null)\n            return baseSchema.toDOM(node)\n\n          return [\n            'li',\n            {\n              'data-item-type': 'task',\n              'data-label': node.attrs.label,\n              'data-list-type': node.attrs.listType,\n              'data-spread': node.attrs.spread,\n              'data-checked': node.attrs.checked,\n            },\n            0,\n          ]\n        },\n        parseMarkdown: {\n          match: ({ type }) => type === 'listItem',\n          runner: (state, node, type) => {\n            if (node.checked == null) {\n              baseSchema.parseMarkdown.runner(state, node, type)\n              return\n            }\n\n            const label = node.label != null ? `${node.label}.` : '•'\n            const checked = node.checked != null ? Boolean(node.checked) : null\n            const listType = node.label != null ? 'ordered' : 'bullet'\n            const spread = node.spread != null ? `${node.spread}` : 'true'\n\n            state.openNode(type, { label, listType, spread, checked })\n            state.next(node.children)\n            state.closeNode()\n          },\n        },\n        toMarkdown: {\n          match: (node) => node.type.name === 'list_item',\n          runner: (state, node) => {\n            if (node.attrs.checked == null) {\n              baseSchema.toMarkdown.runner(state, node)\n              return\n            }\n\n            const label = node.attrs.label\n            const listType = node.attrs.listType\n            const spread = node.attrs.spread === 'true'\n            const checked = node.attrs.checked\n\n            state.openNode('listItem', undefined, {\n              label,\n              listType,\n              spread,\n              checked,\n            })\n            state.next(node.content)\n            state.closeNode()\n          },\n        },\n      }\n    }\n  }\n)\n\nwithMeta(extendListItemSchemaForTask, {\n  displayName: 'NodeSchema<listItem>',\n  group: 'ListItem',\n})\n\n/// Input rule for wrapping a block in task list node.\n/// Users can type `[ ] ` or `[x] ` to wrap the block in task list node with checked status.\nexport const wrapInTaskListInputRule = $inputRule(() => {\n  return new InputRule(\n    /^\\[(?<checked>\\s|x)\\]\\s$/,\n    (state, match, start, end) => {\n      const pos = state.doc.resolve(start)\n      let depth = 0\n      let node = pos.node(depth)\n      while (node && node.type.name !== 'list_item') {\n        depth--\n        node = pos.node(depth)\n      }\n\n      if (!node || node.attrs.checked != null) return null\n\n      const checked = Boolean(match.groups?.checked === 'x')\n\n      const finPos = pos.before(depth)\n      const tr = state.tr\n\n      tr.deleteRange(start, end).setNodeMarkup(finPos, undefined, {\n        ...node.attrs,\n        checked,\n      })\n\n      return tr\n    }\n  )\n})\n\nwithMeta(wrapInTaskListInputRule, {\n  displayName: 'InputRule<wrapInTaskListInputRule>',\n  group: 'ListItem',\n})\n","import type { MilkdownPlugin } from '@milkdown/ctx'\n\nimport { strikethroughKeymap } from '../mark'\nimport { tableKeymap } from '../node'\n\n/// @internal\nexport const keymap: MilkdownPlugin[] = [\n  strikethroughKeymap,\n  tableKeymap,\n].flat()\n","import type { MilkdownPlugin } from '@milkdown/ctx'\n\nimport { strikethroughInputRule } from '../mark'\nimport { insertTableInputRule, wrapInTaskListInputRule } from '../node'\n\n/// @internal\nexport const inputRules: MilkdownPlugin[] = [\n  insertTableInputRule,\n  wrapInTaskListInputRule,\n]\n\nexport const markInputRules: MilkdownPlugin[] = [strikethroughInputRule]\n","import { $prose } from '@milkdown/utils'\nimport { imeSpan } from 'prosemirror-safari-ime-span'\n\nimport { withMeta } from '../__internal__'\n\n/// This plugin is used to fix the bug of IME composing in table in Safari browser.\n/// original discussion in https://discuss.prosemirror.net/t/ime-composing-problems-on-td-or-th-element-in-safari-browser/4501\nexport const autoInsertSpanPlugin = $prose(() => imeSpan)\n\nwithMeta(autoInsertSpanPlugin, {\n  displayName: 'Prose<autoInsertSpanPlugin>',\n  group: 'Prose',\n})\n","import { columnResizing } from '@milkdown/prose/tables'\nimport { $prose } from '@milkdown/utils'\n\nimport { withMeta } from '../__internal__'\n\n/// This plugin is wrapping the `columnResizing` plugin from [prosemirror-tables](https://github.com/ProseMirror/prosemirror-tables).\nexport const columnResizingPlugin = $prose(() => columnResizing({}))\n\nwithMeta(columnResizingPlugin, {\n  displayName: 'Prose<columnResizingPlugin>',\n  group: 'Prose',\n})\n","import { tableEditing } from '@milkdown/prose/tables'\nimport { $prose } from '@milkdown/utils'\n\nimport { withMeta } from '../__internal__'\n\n/// This plugin is wrapping the `tableEditing` plugin from [prosemirror-tables](https://github.com/ProseMirror/prosemirror-tables).\nexport const tableEditingPlugin = $prose(() =>\n  tableEditing({ allowTableNodeSelection: true })\n)\n\nwithMeta(tableEditingPlugin, {\n  displayName: 'Prose<tableEditingPlugin>',\n  group: 'Prose',\n})\n","import type { $Remark } from '@milkdown/utils'\nimport type { Options } from 'remark-gfm'\n\nimport { $remark } from '@milkdown/utils'\nimport remarkGFM from 'remark-gfm'\n\nimport { withMeta } from '../__internal__'\n\n/// This plugin is wrapping the [remark-gfm](https://github.com/remarkjs/remark-gfm).\nexport const remarkGFMPlugin: $Remark<'remarkGFM', Options | null | undefined> =\n  $remark('remarkGFM', () => remarkGFM)\n\nwithMeta(remarkGFMPlugin.plugin, {\n  displayName: 'Remark<remarkGFMPlugin>',\n  group: 'Remark',\n})\n\nwithMeta(remarkGFMPlugin.options, {\n  displayName: 'RemarkConfig<remarkGFMPlugin>',\n  group: 'Remark',\n})\n","import type { Node } from '@milkdown/prose/model'\nimport type { Transaction } from '@milkdown/prose/state'\n\nimport { Plugin, PluginKey } from '@milkdown/prose/state'\nimport { $prose } from '@milkdown/utils'\n\nimport { withMeta } from '../__internal__'\n\nconst pluginKey = new PluginKey('MILKDOWN_KEEP_TABLE_ALIGN_PLUGIN')\n\nfunction getChildIndex(node: Node, parent: Node) {\n  let index = 0\n  parent.forEach((child, _offset, i) => {\n    if (child === node) index = i\n  })\n  return index\n}\n\nexport const keepTableAlignPlugin = $prose(() => {\n  return new Plugin({\n    key: pluginKey,\n    appendTransaction: (_tr, oldState, state) => {\n      let tr: Transaction | undefined\n      const check = (node: Node, pos: number) => {\n        if (!tr) tr = state.tr\n\n        if (node.type.name !== 'table_cell') return\n\n        const $pos = state.doc.resolve(pos)\n        const tableRow = $pos.node($pos.depth)\n        const table = $pos.node($pos.depth - 1)\n        const tableHeaderRow = table.firstChild\n        // TODO: maybe consider add a header row\n        if (!tableHeaderRow) return\n\n        const index = getChildIndex(node, tableRow)\n        const headerCell = tableHeaderRow.maybeChild(index)\n        if (!headerCell) return\n        const align = headerCell.attrs.alignment\n        const currentAlign = node.attrs.alignment\n        if (align === currentAlign) return\n\n        tr.setNodeMarkup(pos, undefined, { ...node.attrs, alignment: align })\n      }\n      if (oldState.doc !== state.doc) state.doc.descendants(check)\n\n      return tr\n    },\n  })\n})\n\nwithMeta(keepTableAlignPlugin, {\n  displayName: 'Prose<keepTableAlignPlugin>',\n  group: 'Prose',\n})\n","import type { MilkdownPlugin } from '@milkdown/ctx'\n\nimport {\n  autoInsertSpanPlugin,\n  keepTableAlignPlugin,\n  remarkGFMPlugin,\n  tableEditingPlugin,\n} from '../plugin'\n\n/// @internal\nexport const plugins: MilkdownPlugin[] = [\n  keepTableAlignPlugin,\n  autoInsertSpanPlugin,\n  remarkGFMPlugin,\n  tableEditingPlugin,\n].flat()\n","import type { MilkdownPlugin } from '@milkdown/ctx'\n\nimport { strikethroughAttr, strikethroughSchema } from '../mark'\nimport {\n  extendListItemSchemaForTask,\n  footnoteDefinitionSchema,\n  footnoteReferenceSchema,\n  tableCellSchema,\n  tableHeaderRowSchema,\n  tableHeaderSchema,\n  tableRowSchema,\n  tableSchema,\n} from '../node'\n\n/// @internal\nexport const schema: MilkdownPlugin[] = [\n  extendListItemSchemaForTask,\n\n  tableSchema,\n  tableHeaderRowSchema,\n  tableRowSchema,\n  tableHeaderSchema,\n  tableCellSchema,\n\n  footnoteDefinitionSchema,\n  footnoteReferenceSchema,\n\n  strikethroughAttr,\n  strikethroughSchema,\n].flat()\n","import { toggleStrikethroughCommand } from '../mark'\nimport {\n  addColAfterCommand,\n  addColBeforeCommand,\n  addRowAfterCommand,\n  addRowBeforeCommand,\n  deleteSelectedCellsCommand,\n  exitTable,\n  goToNextTableCellCommand,\n  goToPrevTableCellCommand,\n  insertTableCommand,\n  moveColCommand,\n  moveRowCommand,\n  selectColCommand,\n  selectRowCommand,\n  selectTableCommand,\n  setAlignCommand,\n} from '../node'\n\n/// @internal\nexport const commands = [\n  goToNextTableCellCommand,\n  goToPrevTableCellCommand,\n  exitTable,\n  insertTableCommand,\n  moveRowCommand,\n  moveColCommand,\n  selectRowCommand,\n  selectColCommand,\n  selectTableCommand,\n  deleteSelectedCellsCommand,\n  addRowBeforeCommand,\n  addRowAfterCommand,\n  addColBeforeCommand,\n  addColAfterCommand,\n  setAlignCommand,\n\n  toggleStrikethroughCommand,\n]\n","import {\n  commands,\n  inputRules,\n  keymap,\n  markInputRules,\n  plugins,\n  schema,\n} from './composed'\n\nexport * from './node'\nexport * from './mark'\nexport * from './plugin'\nexport * from './composed'\n\n/// The GFM preset, includes all the plugins.\nexport const gfm = [\n  schema,\n  inputRules,\n  markInputRules,\n  keymap,\n  commands,\n  plugins,\n].flat()\n"],"names":["commands","id"],"mappings":";;;;;;;;;;;AAEgB,SAAA,SACd,QACA,MACG;AACH,SAAO,OAAO,QAAQ;AAAA,IACpB,MAAM;AAAA,MACJ,SAAS;AAAA,MACT,GAAG;AAAA,IAAA;AAAA,EACL,CACD;AAEM,SAAA;AACT;ACAa,MAAA,oBAAoB,UAAU,gBAAgB;AAE3D,SAAS,mBAAmB;AAAA,EAC1B,aAAa;AAAA,EACb,OAAO;AACT,CAAC;AAGM,MAAM,sBAAsB,YAAY,kBAAkB,CAAC,SAAS;AAAA,EACzE,UAAU;AAAA,IACR,EAAE,KAAK,MAAM;AAAA,IACb;AAAA,MACE,OAAO;AAAA,MACP,UAAU,CAAC,UAAW,UAAU;AAAA,IAAA;AAAA,EAEpC;AAAA,EACA,OAAO,CAAC,SAAS,CAAC,OAAO,IAAI,IAAI,kBAAkB,GAAG,EAAE,IAAI,CAAC;AAAA,EAC7D,eAAe;AAAA,IACb,OAAO,CAAC,SAAS,KAAK,SAAS;AAAA,IAC/B,QAAQ,CAAC,OAAO,MAAM,aAAa;AACjC,YAAM,SAAS,QAAQ;AACjB,YAAA,KAAK,KAAK,QAAQ;AACxB,YAAM,UAAU,QAAQ;AAAA,IAAA;AAAA,EAE5B;AAAA,EACA,YAAY;AAAA,IACV,OAAO,CAAC,SAAS,KAAK,KAAK,SAAS;AAAA,IACpC,QAAQ,CAAC,OAAO,SAAS;AACjB,YAAA,SAAS,MAAM,QAAQ;AAAA,IAAA;AAAA,EAC/B;AAEJ,EAAE;AAEF,SAAS,oBAAoB,MAAM;AAAA,EACjC,aAAa;AAAA,EACb,OAAO;AACT,CAAC;AAED,SAAS,oBAAoB,KAAK;AAAA,EAChC,aAAa;AAAA,EACb,OAAO;AACT,CAAC;AAGM,MAAM,6BAA6B;AAAA,EACxC;AAAA,EACA,CAAC,QAAQ,MAAM;AACb,WAAO,WAAW,oBAAoB,KAAK,GAAG,CAAC;AAAA,EAAA;AAEnD;AAEA,SAAS,4BAA4B;AAAA,EACnC,aAAa;AAAA,EACb,OAAO;AACT,CAAC;AAGY,MAAA,yBAAyB,WAAW,CAAC,QAAQ;AACxD,SAAO,SAAS,cAAc,oBAAoB,KAAK,GAAG,CAAC;AAC7D,CAAC;AAED,SAAS,wBAAwB;AAAA,EAC/B,aAAa;AAAA,EACb,OAAO;AACT,CAAC;AAIY,MAAA,sBAAsB,WAAW,uBAAuB;AAAA,EACnE,qBAAqB;AAAA,IACnB,WAAW;AAAA,IACX,SAAS,CAAC,QAAQ;AACV,YAAAA,YAAW,IAAI,IAAI,WAAW;AACpC,aAAO,MAAMA,UAAS,KAAK,2BAA2B,GAAG;AAAA,IAAA;AAAA,EAC3D;AAEJ,CAAC;AAED,SAAS,oBAAoB,KAAK;AAAA,EAChC,aAAa;AAAA,EACb,OAAO;AACT,CAAC;AAED,SAAS,oBAAoB,WAAW;AAAA,EACtC,aAAa;AAAA,EACb,OAAO;AACT,CAAC;AC5FD,MAAM,iBAAiB,WAAW;AAAA,EAChC,YAAY;AAAA,EACZ,aAAa;AAAA,EACb,gBAAgB;AAAA,IACd,WAAW;AAAA,MACT,SAAS;AAAA,MACT,YAAY,CAAC,QAAQ,IAAI,MAAM,aAAa;AAAA,MAC5C,YAAY,CAAC,OAAO,UAAU;AACtB,cAAA,QAAQ,eAAe,SAAS,MAAM;AAAA,MAAA;AAAA,IAC9C;AAAA,EACF;AAEJ,CAAC;AAGY,MAAA,cAAc,YAAY,SAAS,OAAO;AAAA,EACrD,GAAG,eAAe;AAAA,EAClB,SAAS;AAAA,EACT,mBAAmB;AAAA,EACnB,eAAe;AAAA,IACb,OAAO,CAAC,SAAS,KAAK,SAAS;AAAA,IAC/B,QAAQ,CAAC,OAAO,MAAM,SAAS;AAC7B,YAAM,QAAQ,KAAK;AACnB,YAAM,WAAY,KAAK,SAA4B,IAAI,CAAC,GAAG,OAAO;AAAA,QAChE,GAAG;AAAA,QACH;AAAA,QACA,UAAU,MAAM;AAAA,MAAA,EAChB;AACF,YAAM,SAAS,IAAI;AACnB,YAAM,KAAK,QAAQ;AACnB,YAAM,UAAU;AAAA,IAAA;AAAA,EAEpB;AAAA,EACA,YAAY;AAAA,IACV,OAAO,CAAC,SAAS,KAAK,KAAK,SAAS;AAAA,IACpC,QAAQ,CAAC,OAAO,SAAS;;AACjB,YAAA,aAAY,UAAK,QAAQ,eAAb,mBAAyB;AAC3C,UAAI,CAAC,UAAW;AAEhB,YAAM,QAA2B,CAAC;AACxB,gBAAA,QAAQ,CAAC,SAAS;AACpB,cAAA,KAAK,KAAK,MAAM,SAAS;AAAA,MAAA,CAChC;AACD,YAAM,SAAS,SAAS,QAAW,EAAE,OAAO;AACtC,YAAA,KAAK,KAAK,OAAO;AACvB,YAAM,UAAU;AAAA,IAAA;AAAA,EAClB;AAEJ,EAAE;AAEF,SAAS,YAAY,MAAM;AAAA,EACzB,aAAa;AAAA,EACb,OAAO;AACT,CAAC;AAED,SAAS,YAAY,KAAK;AAAA,EACxB,aAAa;AAAA,EACb,OAAO;AACT,CAAC;AAGY,MAAA,uBAAuB,YAAY,oBAAoB,OAAO;AAAA,EACzE,GAAG,eAAe;AAAA,EAClB,mBAAmB;AAAA,EACnB,SAAS;AAAA,EACT,UAAU,CAAC,EAAE,KAAK,sBAAsB;AAAA,EACxC,QAAQ;AACN,WAAO,CAAC,MAAM,EAAE,kBAAkB,KAAA,GAAQ,CAAC;AAAA,EAC7C;AAAA,EACA,eAAe;AAAA,IACb,OAAO,CAAC,SAAS,QAAQ,KAAK,SAAS,cAAc,KAAK,QAAQ;AAAA,IAClE,QAAQ,CAAC,OAAO,MAAM,SAAS;AAC7B,YAAM,QAAQ,KAAK;AACnB,YAAM,WAAY,KAAK,SAA4B,IAAI,CAAC,GAAG,OAAO;AAAA,QAChE,GAAG;AAAA,QACH,OAAO,MAAM,CAAC;AAAA,QACd,UAAU,KAAK;AAAA,MAAA,EACf;AACF,YAAM,SAAS,IAAI;AACnB,YAAM,KAAK,QAAQ;AACnB,YAAM,UAAU;AAAA,IAAA;AAAA,EAEpB;AAAA,EACA,YAAY;AAAA,IACV,OAAO,CAAC,SAAS,KAAK,KAAK,SAAS;AAAA,IACpC,QAAQ,CAAC,OAAO,SAAS;AACvB,YAAM,SAAS,YAAY,QAAW,EAAE,UAAU,MAAM;AAClD,YAAA,KAAK,KAAK,OAAO;AACvB,YAAM,UAAU;AAAA,IAAA;AAAA,EAClB;AAEJ,EAAE;AAEF,SAAS,qBAAqB,MAAM;AAAA,EAClC,aAAa;AAAA,EACb,OAAO;AACT,CAAC;AAED,SAAS,qBAAqB,KAAK;AAAA,EACjC,aAAa;AAAA,EACb,OAAO;AACT,CAAC;AAGY,MAAA,iBAAiB,YAAY,aAAa,OAAO;AAAA,EAC5D,GAAG,eAAe;AAAA,EAClB,mBAAmB;AAAA,EACnB,SAAS;AAAA,EACT,eAAe;AAAA,IACb,OAAO,CAAC,SAAS,KAAK,SAAS;AAAA,IAC/B,QAAQ,CAAC,OAAO,MAAM,SAAS;AAC7B,YAAM,QAAQ,KAAK;AACnB,YAAM,WAAY,KAAK,SAA4B,IAAI,CAAC,GAAG,OAAO;AAAA,QAChE,GAAG;AAAA,QACH,OAAO,MAAM,CAAC;AAAA,MAAA,EACd;AACF,YAAM,SAAS,IAAI;AACnB,YAAM,KAAK,QAAQ;AACnB,YAAM,UAAU;AAAA,IAAA;AAAA,EAEpB;AAAA,EACA,YAAY;AAAA,IACV,OAAO,CAAC,SAAS,KAAK,KAAK,SAAS;AAAA,IACpC,QAAQ,CAAC,OAAO,SAAS;AAGnB,UAAA,KAAK,QAAQ,SAAS,GAAG;AAC3B;AAAA,MAAA;AAEF,YAAM,SAAS,UAAU;AACnB,YAAA,KAAK,KAAK,OAAO;AACvB,YAAM,UAAU;AAAA,IAAA;AAAA,EAClB;AAEJ,EAAE;AAEF,SAAS,eAAe,MAAM;AAAA,EAC5B,aAAa;AAAA,EACb,OAAO;AACT,CAAC;AAED,SAAS,eAAe,KAAK;AAAA,EAC3B,aAAa;AAAA,EACb,OAAO;AACT,CAAC;AAGY,MAAA,kBAAkB,YAAY,cAAc,OAAO;AAAA,EAC9D,GAAG,eAAe;AAAA,EAClB,mBAAmB;AAAA,EACnB,eAAe;AAAA,IACb,OAAO,CAAC,SAAS,KAAK,SAAS,eAAe,CAAC,KAAK;AAAA,IACpD,QAAQ,CAAC,OAAO,MAAM,SAAS;AAC7B,YAAM,QAAQ,KAAK;AACnB,YACG,SAAS,MAAM,EAAE,WAAW,MAAO,CAAA,EACnC,SAAS,MAAM,OAAO,MAAM,SAAqB,EACjD,KAAK,KAAK,QAAQ,EAClB,YACA,UAAU;AAAA,IAAA;AAAA,EAEjB;AAAA,EACA,YAAY;AAAA,IACV,OAAO,CAAC,SAAS,KAAK,KAAK,SAAS;AAAA,IACpC,QAAQ,CAAC,OAAO,SAAS;AACvB,YAAM,SAAS,WAAW,EAAE,KAAK,KAAK,OAAO,EAAE,UAAU;AAAA,IAAA;AAAA,EAC3D;AAEJ,EAAE;AAEF,SAAS,gBAAgB,MAAM;AAAA,EAC7B,aAAa;AAAA,EACb,OAAO;AACT,CAAC;AAED,SAAS,gBAAgB,KAAK;AAAA,EAC5B,aAAa;AAAA,EACb,OAAO;AACT,CAAC;AAGY,MAAA,oBAAoB,YAAY,gBAAgB,OAAO;AAAA,EAClE,GAAG,eAAe;AAAA,EAClB,mBAAmB;AAAA,EACnB,eAAe;AAAA,IACb,OAAO,CAAC,SAAS,KAAK,SAAS,eAAe,CAAC,CAAC,KAAK;AAAA,IACrD,QAAQ,CAAC,OAAO,MAAM,SAAS;AAC7B,YAAM,QAAQ,KAAK;AACnB,YAAM,SAAS,MAAM,EAAE,WAAW,OAAO;AACzC,YAAM,SAAS,MAAM,OAAO,MAAM,SAAqB;AACjD,YAAA,KAAK,KAAK,QAAQ;AACxB,YAAM,UAAU;AAChB,YAAM,UAAU;AAAA,IAAA;AAAA,EAEpB;AAAA,EACA,YAAY;AAAA,IACV,OAAO,CAAC,SAAS,KAAK,KAAK,SAAS;AAAA,IACpC,QAAQ,CAAC,OAAO,SAAS;AACvB,YAAM,SAAS,WAAW;AACpB,YAAA,KAAK,KAAK,OAAO;AACvB,YAAM,UAAU;AAAA,IAAA;AAAA,EAClB;AAEJ,EAAE;AAEF,SAAS,kBAAkB,MAAM;AAAA,EAC/B,aAAa;AAAA,EACb,OAAO;AACT,CAAC;AAED,SAAS,kBAAkB,KAAK;AAAA,EAC9B,aAAa;AAAA,EACb,OAAO;AACT,CAAC;ACpMM,SAAS,YAAY,KAAU,YAAY,GAAG,YAAY,GAAS;AACxE,QAAM,QAAQ,MAAM,SAAS,EAC1B,KAAK,CAAC,EACN,IAAI,MAAM,gBAAgB,KAAK,GAAG,EAAE,eAAgB;AAEvD,QAAM,cAAc,MAAM,SAAS,EAChC,KAAK,CAAC,EACN,IAAI,MAAM,kBAAkB,KAAK,GAAG,EAAE,eAAgB;AAEzD,QAAM,OAAO,MAAM,SAAS,EACzB,KAAK,CAAC,EACN;AAAA,IAAI,CAAC,GAAG,MACP,MAAM,IACF,qBAAqB,KAAK,GAAG,EAAE,OAAO,MAAM,WAAW,IACvD,eAAe,KAAK,GAAG,EAAE,OAAO,MAAM,KAAK;AAAA,EACjD;AAEF,SAAO,YAAY,KAAK,GAAG,EAAE,OAAO,MAAM,IAAI;AAChD;AAGO,SAAS,UAAU,MAAmB;AACpC,SAAA;AAAA,IACL,CAAC,SAAS,KAAK,KAAK,KAAK,cAAc;AAAA,IACvC,IAAI;AACR;AAGgB,SAAA,cACd,aACA,WACuB;AACjB,QAAA,QAAQ,UAAU,UAAU,KAAK;AACnC,MAAA,CAAC,MAAc,QAAA;AACnB,QAAM,MAAM,SAAS,IAAI,MAAM,IAAI;AACnC,MAAI,cAAc,KAAK,eAAe,IAAI,MAAc,QAAA;AAExD,SAAO,IACJ,YAAY;AAAA,IACX,MAAM;AAAA,IACN,OAAO,cAAc;AAAA,IACrB,KAAK;AAAA,IACL,QAAQ,IAAI;AAAA,EAAA,CACb,EACA,IAAI,CAAC,QAAQ;AACZ,UAAM,OAAO,MAAM,KAAK,OAAO,GAAG;AAC9B,QAAA,CAAC,KAAa,QAAA;AACZ,UAAA,QAAQ,MAAM,MAAM;AACnB,WAAA;AAAA,MACL,KAAK;AAAA,MACL,OAAO,QAAQ;AAAA,MACf;AAAA,IACF;AAAA,EACD,CAAA,EACA,OAAO,CAAC,MAAoB,KAAK,IAAI;AAC1C;AAGgB,SAAA,cACd,UACA,WACuB;AACjB,QAAA,QAAQ,UAAU,UAAU,KAAK;AACnC,MAAA,CAAC,MAAc,QAAA;AACnB,QAAM,MAAM,SAAS,IAAI,MAAM,IAAI;AACnC,MAAI,WAAW,KAAK,YAAY,IAAI,OAAe,QAAA;AAEnD,SAAO,IACJ,YAAY;AAAA,IACX,MAAM;AAAA,IACN,OAAO,IAAI;AAAA,IACX,KAAK;AAAA,IACL,QAAQ,WAAW;AAAA,EAAA,CACpB,EACA,IAAI,CAAC,QAAQ;AACZ,UAAM,OAAO,MAAM,KAAK,OAAO,GAAG;AAC9B,QAAA,CAAC,KAAa,QAAA;AACZ,UAAA,QAAQ,MAAM,MAAM;AACnB,WAAA;AAAA,MACL,KAAK;AAAA,MACL,OAAO,QAAQ;AAAA,MACf;AAAA,IACF;AAAA,EACD,CAAA,EACA,OAAO,CAAC,MAAoB,KAAK,IAAI;AAC1C;AAGO,SAAS,mBAAmB,WAAsB;AACjD,QAAA,QAAQ,UAAU,UAAU,KAAK;AACvC,MAAI,CAAC,MAAO;AAEZ,QAAM,MAAM,SAAS,IAAI,MAAM,IAAI;AAC7B,QAAA,QAAQ,IAAI,YAAY;AAAA,IAC5B,MAAM;AAAA,IACN,OAAO,IAAI;AAAA,IACX,KAAK;AAAA,IACL,QAAQ,IAAI;AAAA,EAAA,CACb;AACM,SAAA,MAAM,IAAI,CAAC,YAAY;AAC5B,UAAM,OAAO,MAAM,KAAK,OAAO,OAAO;AAChC,UAAA,MAAM,UAAU,MAAM;AAC5B,WAAO,EAAE,KAAK,OAAO,MAAM,GAAG,KAAK;AAAA,EAAA,CACpC;AACH;AAGO,SAAS,YAAY,IAAiB;AACrC,QAAA,QAAQ,mBAAmB,GAAG,SAAS;AACzC,MAAA,SAAS,MAAM,CAAC,GAAG;AACrB,UAAM,aAAa,GAAG,IAAI,QAAQ,MAAM,CAAC,EAAE,GAAG;AAC9C,UAAM,OAAO,MAAM,MAAM,SAAS,CAAC;AACnC,QAAI,MAAM;AACR,YAAM,YAAY,GAAG,IAAI,QAAQ,KAAK,GAAG;AAClC,aAAA,QAAQ,GAAG,aAAa,IAAI,cAAc,WAAW,UAAU,CAAC,CAAC;AAAA,IAAA;AAAA,EAC1E;AAEK,SAAA;AACT;AAGgB,SAAA,oBACd,KACA,IACA,EAAE,KAAK,YAAY,SACnB,KACA;AACM,QAAA,SAAS,MAAM,GAAG,EACrB,KAAK,CAAC,EACN,OAAO,CAAC,KAAK,GAAG,MAAM;AACrB,WAAO,MAAM,MAAM,MAAM,CAAC,EAAE;AAAA,KAC3B,UAAU;AAET,QAAA,QAAQ,MAAM,IAAI,KAAK,EAC1B,KAAK,CAAC,EACN,IAAI,CAAC,GAAG,QAAQ;AACf,UAAM,YAAY,MAAM,OAAO,IAAI,IAAI,GAAG,CAAW;AAC9C,WAAA,gBACJ,KAAK,GAAG,EACR,cAAc,EAAE,WAAW,uCAAW,MAAM,WAAW;AAAA,EAAA,CAC3D;AAEA,KAAA,OAAO,QAAQ,eAAe,KAAK,GAAG,EAAE,OAAO,MAAM,KAAK,CAAC;AACvD,SAAA;AACT;AAGO,SAAS,WAAW,MAAqB;AAC9C,SAAO,CAAC,OAAe,QAAiB,CAAC,OAAoB;AACrD,UAAA,OAAO,GAAG,UAAU;AAC1B,UAAM,OAAO,GAAG,IAAI,QAAQ,GAAG;AAC/B,UAAM,QAAQ;AAAA,MACZ,CAAC,SAAS,KAAK,KAAK,SAAS;AAAA,MAC7B,IAAI;AACN,UAAM,QAAQ,QACV;AAAA,MACE,MAAM,MAAM;AAAA,MACZ,MAAM,MAAM;AAAA,IAAA,IAEd;AAEJ,UAAM,iBAAiB,SAAS;AAChC,QAAI,OAAO;AACT,YAAM,MAAM,SAAS,IAAI,MAAM,IAAI;AAGnC,UAAI,SAAS,KAAK,SAAS,iBAAiB,IAAI,SAAS,IAAI,QAAQ;AACnE,cAAM,WAAW,IAAI;AAAA,UACnB,iBAAiB,QAAQ,IAAI,SAAS;AAAA,UACtC,iBAAiB,IAAI,QAAQ,IAAI;AAAA,UACjC,MAAM;AAAA,QACR;AACA,cAAM,YAAY,GAAG,IAAI,QAAQ,MAAM,OAAO,QAAQ;AAEtD,cAAM,sBAAsB,iBACxB,cAAc,eACd,cAAc;AAElB,cAAM,YAAY,IAAI;AAAA,UACpB,iBAAiB,QAAQ;AAAA,UACzB,iBAAiB,IAAI;AAAA,UACrB,MAAM;AAAA,QACR;AACA,cAAM,aAAa,GAAG,IAAI,QAAQ,MAAM,OAAO,SAAS;AACjD,eAAA;AAAA,UACL,GAAG;AAAA,YACD,oBAAoB,WAAW,UAAU;AAAA,UAAA;AAAA,QAE7C;AAAA,MAAA;AAAA,IACF;AAEK,WAAA;AAAA,EACT;AACF;AAIa,MAAA,YAAY,WAAW,KAAK;AAI5B,MAAA,YAAY,WAAW,KAAK;AAEzC,SAAS,UAAa,OAAc;AAClC,SAAO,MAAM,CAAC,EAAG,IAAI,CAAC,GAAG,MAAM;AAC7B,WAAO,MAAM,IAAI,CAAC,WAAW,OAAO,CAAC,CAAC;AAAA,EAAA,CACvC;AACH;AAEA,SAAS,8BACP,WACA,cACA;AACA,QAAM,SAAS,CAAC;AACV,QAAA,MAAM,SAAS,IAAI,SAAS;AAClC,WAAS,WAAW,GAAG,WAAW,IAAI,QAAQ,YAAY;AAClD,UAAA,MAAM,UAAU,MAAM,QAAQ;AACpC,UAAM,WAAW,CAAC;AAElB,aAAS,WAAW,GAAG,WAAW,IAAI,OAAO,YAAY;AACvD,UAAI,CAAC,aAAa,QAAQ,EAAG,QAAQ,EAAG;AAExC,YAAM,UAAU,IAAI,IAAI,WAAW,IAAI,QAAQ,QAAQ;AAEvD,YAAM,OAAO,aAAa,QAAQ,EAAG,QAAQ;AACvC,YAAA,UAAU,UAAU,OAAO,OAAO;AAClC,YAAA,UAAU,QAAQ,KAAK;AAAA,QAC3B,OAAO,OAAO,IAAI,KAAK,KAAK;AAAA,QAC5B,KAAK;AAAA,QACL,KAAK;AAAA,MACP;AACA,eAAS,KAAK,OAAO;AAAA,IAAA;AAGhB,WAAA,KAAK,IAAI,KAAK,cAAc,IAAI,OAAO,UAAU,IAAI,KAAK,CAAC;AAAA,EAAA;AAG9D,QAAA,WAAW,UAAU,KAAK;AAAA,IAC9B,UAAU;AAAA,IACV;AAAA,IACA,UAAU;AAAA,EACZ;AAEO,SAAA;AACT;AAEA,SAAS,8BAA8B,WAAiB;AAChD,QAAA,MAAM,SAAS,IAAI,SAAS;AAClC,QAAM,OAA0B,CAAC;AACjC,WAAS,WAAW,GAAG,WAAW,IAAI,QAAQ,YAAY;AACxD,UAAM,WAA4B,CAAC;AACnC,UAAM,OAAgC,CAAC;AAEvC,aAAS,WAAW,GAAG,WAAW,IAAI,OAAO,YAAY;AACvD,YAAM,UAAU,IAAI,IAAI,WAAW,IAAI,QAAQ,QAAQ;AACjD,YAAA,OAAO,UAAU,OAAO,OAAO;AAC/B,YAAA,OAAO,IAAI,SAAS,OAAO;AACjC,UAAI,KAAK,OAAO,KAAK,KAAK,QAAQ,UAAU;AAC1C,iBAAS,KAAK,IAAI;AAClB;AAAA,MAAA;AAEF,WAAK,OAAO,IAAI;AAEhB,eAAS,KAAK,IAAI;AAAA,IAAA;AAGpB,SAAK,KAAK,QAAQ;AAAA,EAAA;AAGb,SAAA;AACT;AAEA,SAAS,qBACP,MACA,eACA,eACA,mBACA;AACA,QAAM,YAAY,cAAc,CAAC,IAAK,cAAc,CAAC,IAAK,KAAK;AAE/D,QAAM,gBAAgB,KAAK,OAAO,cAAc,CAAC,GAAI,cAAc,MAAM;AACzE,QAAM,iBAAiB,cAAc,SAAS,MAAM,IAAI,IAAI;AACxD,MAAA;AAMG;AAEH,aAAA,cAAc,KACV,cAAc,CAAC,IACf,cAAc,cAAc,SAAS,CAAC,IAAK;AAAA,EAAA;AAGnD,OAAK,OAAO,QAAQ,GAAG,GAAG,aAAa;AAChC,SAAA;AACT;AAEA,SAAS,gBACP,OACA,eACA,eACA,WACA;AACA,MAAI,OAAO,UAAU,8BAA8B,MAAM,IAAI,CAAC;AAE9D,SAAO,qBAAqB,MAAM,eAAe,aAAwB;AACzE,SAAO,UAAU,IAAI;AAEd,SAAA,8BAA8B,MAAM,MAAM,IAAI;AACvD;AAEA,SAAS,aACP,OACA,eACA,eACA,WACA;AACI,MAAA,OAAO,8BAA8B,MAAM,IAAI;AAEnD,SAAO,qBAAqB,MAAM,eAAe,aAAwB;AAElE,SAAA,8BAA8B,MAAM,MAAM,IAAI;AACvD;AAEA,SAAS,0BAA0B,aAAqB,IAAiB;AACvE,MAAI,aAAa;AACjB,MAAI,WAAW;AAGf,WAAS,IAAI,aAAa,KAAK,GAAG,KAAK;AACrC,UAAM,QAAQ,cAAc,GAAG,GAAG,SAAS;AAC3C,QAAI,OAAO;AACH,YAAA,QAAQ,CAAC,SAAS;AACtB,cAAM,gBAAgB,KAAK,KAAK,MAAM,UAAU,IAAI;AAChD,YAAA,iBAAiB,WAAyB,cAAA;AAE1C,YAAA,gBAAgB,SAAqB,YAAA;AAAA,MAAA,CAC1C;AAAA,IAAA;AAAA,EACH;AAGF,WAAS,IAAI,aAAa,KAAK,UAAU,KAAK;AAC5C,UAAM,QAAQ,cAAc,GAAG,GAAG,SAAS;AAC3C,QAAI,OAAO;AACH,YAAA,QAAQ,CAAC,SAAS;AACtB,cAAM,gBAAgB,KAAK,KAAK,MAAM,UAAU,IAAI;AACpD,YAAI,KAAK,KAAK,MAAM,UAAU,KAAK,gBAAgB;AACtC,qBAAA;AAAA,MAAA,CACd;AAAA,IAAA;AAAA,EACH;AAIF,QAAM,UAAU,CAAC;AACjB,WAAS,IAAI,YAAY,KAAK,UAAU,KAAK;AAC3C,UAAM,aAAa,cAAc,GAAG,GAAG,SAAS;AAChD,QAAI,cAAc,WAAW,OAAQ,SAAQ,KAAK,CAAC;AAAA,EAAA;AAErD,eAAa,QAAQ,CAAC;AACX,aAAA,QAAQ,QAAQ,SAAS,CAAC;AAErC,QAAM,2BAA2B,cAAc,YAAY,GAAG,SAAS;AACvE,QAAM,gBAAgB,cAAc,GAAG,GAAG,SAAS;AAC7C,QAAA,UAAU,GAAG,IAAI;AAAA,IACrB,yBAAyB,yBAAyB,SAAS,CAAC,EAAG;AAAA,EACjE;AAEI,MAAA;AACJ,WAAS,IAAI,UAAU,KAAK,YAAY,KAAK;AAC3C,UAAM,cAAc,cAAc,GAAG,GAAG,SAAS;AAC7C,QAAA,eAAe,YAAY,QAAQ;AACrC,eAAS,IAAI,cAAc,SAAS,GAAG,KAAK,GAAG,KAAK;AAClD,YAAI,cAAc,CAAC,EAAG,QAAQ,YAAY,CAAC,EAAG,KAAK;AACjD,qBAAW,YAAY,CAAC;AACxB;AAAA,QAAA;AAAA,MACF;AAEF,UAAI,SAAU;AAAA,IAAA;AAAA,EAChB;AAGF,QAAM,QAAQ,GAAG,IAAI,QAAQ,SAAU,GAAG;AACnC,SAAA,EAAE,SAAS,OAAO,QAAQ;AACnC;AAEA,SAAS,uBAAuB,UAAkB,IAAiB;AACjE,MAAI,aAAa;AACjB,MAAI,WAAW;AAEf,WAAS,IAAI,UAAU,KAAK,GAAG,KAAK;AAClC,UAAM,QAAQ,cAAc,GAAG,GAAG,SAAS;AACpC,UAAA,QAAQ,CAAC,SAAS;AACvB,YAAM,gBAAgB,KAAK,KAAK,MAAM,UAAU,IAAI;AAChD,UAAA,iBAAiB,WAAyB,cAAA;AAE1C,UAAA,gBAAgB,SAAqB,YAAA;AAAA,IAAA,CAC1C;AAAA,EAAA;AAGH,WAAS,IAAI,UAAU,KAAK,UAAU,KAAK;AACzC,UAAM,QAAQ,cAAc,GAAG,GAAG,SAAS;AACpC,UAAA,QAAQ,CAAC,SAAS;AACvB,YAAM,gBAAgB,KAAK,KAAK,MAAM,UAAU,IAAI;AACpD,UAAI,KAAK,KAAK,MAAM,UAAU,KAAK,gBAAgB;AACtC,mBAAA;AAAA,IAAA,CACd;AAAA,EAAA;AAIH,QAAM,UAAU,CAAC;AACjB,WAAS,IAAI,YAAY,KAAK,UAAU,KAAK;AAC3C,UAAM,aAAa,cAAc,GAAG,GAAG,SAAS;AAChD,QAAI,cAAc,WAAW,OAAQ,SAAQ,KAAK,CAAC;AAAA,EAAA;AAErD,eAAa,QAAQ,CAAC;AACX,aAAA,QAAQ,QAAQ,SAAS,CAAC;AAErC,QAAM,wBAAwB,cAAc,YAAY,GAAG,SAAS;AACpE,QAAM,mBAAmB,cAAc,GAAG,GAAG,SAAS;AAChD,QAAA,UAAU,GAAG,IAAI;AAAA,IACrB,sBAAsB,sBAAsB,SAAS,CAAC,EAAG;AAAA,EAC3D;AAEI,MAAA;AACJ,WAAS,IAAI,UAAU,KAAK,YAAY,KAAK;AAC3C,UAAM,WAAW,cAAc,GAAG,GAAG,SAAS;AAC1C,QAAA,YAAY,SAAS,QAAQ;AAC/B,eAAS,IAAI,iBAAiB,SAAS,GAAG,KAAK,GAAG,KAAK;AACrD,YAAI,iBAAiB,CAAC,EAAG,QAAQ,SAAS,CAAC,EAAG,KAAK;AACjD,qBAAW,SAAS,CAAC;AACrB;AAAA,QAAA;AAAA,MACF;AAEF,UAAI,SAAU;AAAA,IAAA;AAAA,EAChB;AAGF,QAAM,QAAQ,GAAG,IAAI,QAAQ,SAAU,GAAG;AACnC,SAAA,EAAE,SAAS,OAAO,QAAQ;AACnC;AAaO,SAAS,QAAQ,eAA8B;AACpD,QAAM,EAAE,IAAI,QAAQ,QAAQ,SAAS,MAAM,QAAQ;AAC7C,QAAA,OAAO,OAAO,OAAO,GAAG,IAAI,QAAQ,GAAG,IAAI,GAAG,UAAU;AACxD,QAAA,QAAQ,UAAU,IAAI;AACxB,MAAA,CAAC,MAAc,QAAA;AAEnB,QAAM,EAAE,SAAS,oBAAA,IAAwB,0BAA0B,QAAQ,EAAE;AAC7E,QAAM,EAAE,SAAS,oBAAA,IAAwB,0BAA0B,QAAQ,EAAE;AAE7E,MAAI,oBAAoB,SAAS,MAAM,EAAU,QAAA;AAEjD,QAAM,WAAW;AAAA,IACf;AAAA,IACA;AAAA,IACA;AAAA,EAEF;AAEM,QAAA,MAAM,QAAQ,EAAE,EAAE;AAAA,IACtB,MAAM;AAAA,IACN,MAAM,MAAM,MAAM,KAAK;AAAA,IACvB;AAAA,EACF;AAEI,MAAA,CAAC,OAAe,QAAA;AAEd,QAAA,MAAM,SAAS,IAAI,QAAQ;AACjC,QAAM,QAAQ,MAAM;AACpB,QAAM,QAAQ;AACd,QAAM,WAAW,IAAI,WAAW,IAAI,SAAS,GAAG,OAAO,QAAQ;AAC/D,QAAM,YAAY,IAAI,IAAI,QAAQ,QAAQ,QAAQ;AAElD,QAAM,sBAAsB,cAAc;AAE1C,QAAM,YAAY,IAAI,WAAW,GAAG,OAAO,QAAQ;AACnD,QAAM,aAAa,IAAI,IAAI,QAAQ,QAAQ,SAAS;AAEpD,SAAO,IAAI,aAAa,oBAAoB,WAAW,UAAU,CAAC;AACpE;AAaO,SAAS,QAAQ,eAA8B;AACpD,QAAM,EAAE,IAAI,QAAQ,QAAQ,SAAS,MAAM,QAAQ;AAC7C,QAAA,OAAO,OAAO,OAAO,GAAG,IAAI,QAAQ,GAAG,IAAI,GAAG,UAAU;AACxD,QAAA,QAAQ,UAAU,IAAI;AACxB,MAAA,CAAC,MAAc,QAAA;AAEnB,QAAM,EAAE,SAAS,iBAAA,IAAqB,uBAAuB,QAAQ,EAAE;AACvE,QAAM,EAAE,SAAS,iBAAA,IAAqB,uBAAuB,QAAQ,EAAE;AAEvE,MAAI,iBAAiB,SAAS,MAAM,EAAU,QAAA;AAE9C,QAAM,WAAW,aAAa,OAAO,kBAAkB,gBAAmB;AAEpE,QAAA,MAAM,QAAQ,EAAE,EAAE;AAAA,IACtB,MAAM;AAAA,IACN,MAAM,MAAM,MAAM,KAAK;AAAA,IACvB;AAAA,EACF;AAEI,MAAA,CAAC,OAAe,QAAA;AAEd,QAAA,MAAM,SAAS,IAAI,QAAQ;AACjC,QAAM,QAAQ,MAAM;AACpB,QAAM,QAAQ;AACd,QAAM,WAAW,IAAI,WAAW,OAAO,IAAI,QAAQ,GAAG,QAAQ;AAC9D,QAAM,YAAY,IAAI,IAAI,QAAQ,QAAQ,QAAQ;AAElD,QAAM,sBAAsB,cAAc;AAE1C,QAAM,YAAY,IAAI,WAAW,OAAO,GAAG,QAAQ;AACnD,QAAM,aAAa,IAAI,IAAI,QAAQ,QAAQ,SAAS;AAEpD,SAAO,IAAI,aAAa,oBAAoB,WAAW,UAAU,CAAC;AACpE;ACrhBO,MAAM,2BAA2B;AAAA,EACtC;AAAA,EACA,MAAM,MAAM,aAAa,EAAE;AAC7B;AAEA,SAAS,0BAA0B;AAAA,EACjC,aAAa;AAAA,EACb,OAAO;AACT,CAAC;AAGM,MAAM,2BAA2B;AAAA,EACtC;AAAA,EACA,MAAM,MAAM,aAAa,CAAC;AAC5B;AAEA,SAAS,0BAA0B;AAAA,EACjC,aAAa;AAAA,EACb,OAAO;AACT,CAAC;AAGM,MAAM,YAAY;AAAA,EACvB;AAAA,EACA,CAAC,QAAQ,MAAM,CAAC,OAAO,aAAa;AAClC,QAAI,CAAC,UAAU,KAAK,EAAU,QAAA;AAExB,UAAA,EAAE,UAAU,MAAM;AACxB,UAAM,QAAQ,mBAAmB,OAAO,YAAY,KAAK,GAAG,CAAC;AACzD,QAAA,CAAC,MAAc,QAAA;AAEb,UAAA,EAAE,OAAO;AAET,UAAA,KAAK,MAAM,GAAG;AAAA,MAClB;AAAA,MACA;AAAA,MACA,gBAAgB,KAAK,GAAG,EAAE,cAAc;AAAA,IAC1C;AAEG,OAAA,aAAa,UAAU,KAAK,GAAG,IAAI,QAAQ,EAAE,GAAG,CAAC,CAAC,EAAE,eAAe;AACtE,yCAAW;AACJ,WAAA;AAAA,EAAA;AAEX;AAEA,SAAS,WAAW;AAAA,EAClB,aAAa;AAAA,EACb,OAAO;AACT,CAAC;AAKM,MAAM,qBAAqB;AAAA,EAChC;AAAA,EACA,CAAC,QACC,CAAC,EAAE,KAAK,IAAI,IAAoC,OAChD,CAAC,OAAO,aAAa;AACb,UAAA,EAAE,WAAW,GAAA,IAAO;AACpB,UAAA,EAAE,SAAS;AACjB,UAAM,QAAQ,YAAY,KAAK,KAAK,GAAG;AACjC,UAAA,MAAM,GAAG,qBAAqB,KAAK;AACnC,UAAA,MAAM,UAAU,SAAS,IAAI,IAAI,QAAQ,IAAI,GAAG,GAAG,IAAI;AACzD,QAAA,IAAS,KAAA,aAAa,GAAG;AAE7B,yCAAW;AAEJ,WAAA;AAAA,EAAA;AAEb;AAEA,SAAS,oBAAoB;AAAA,EAC3B,aAAa;AAAA,EACb,OAAO;AACT,CAAC;AAIM,MAAM,iBAAiB;AAAA,EAC5B;AAAA,EACA,MACE,CAAC,EAAE,MAAM,IAAI,IAAI,IAAkD,OACnE,CAAC,OAAO,aAAa;AACb,UAAA,EAAE,OAAO;AACf,UAAM,SAAS;AAAA,MACb,QAAQ,EAAE,IAAI,QAAQ,QAAQ,GAAG,QAAQ,MAAM,GAAG,KAAK,QAAQ,KAAM,CAAA;AAAA;AAGvE,WAAO,QAAQ,MAAM;AAAA,EAAA;AAE3B;AAEA,SAAS,gBAAgB;AAAA,EACvB,aAAa;AAAA,EACb,OAAO;AACT,CAAC;AAIM,MAAM,iBAAiB;AAAA,EAC5B;AAAA,EACA,MACE,CAAC,EAAE,MAAM,IAAI,IAAI,IAAkD,OACnE,CAAC,OAAO,aAAa;AACb,UAAA,EAAE,OAAO;AACf,UAAM,SAAS;AAAA,MACb,QAAQ,EAAE,IAAI,QAAQ,QAAQ,GAAG,QAAQ,MAAM,GAAG,KAAK,QAAQ,KAAM,CAAA;AAAA;AAGvE,WAAO,QAAQ,MAAM;AAAA,EAAA;AAE3B;AAEA,SAAS,gBAAgB;AAAA,EACvB,aAAa;AAAA,EACb,OAAO;AACT,CAAC;AAGM,MAAM,mBAAmB;AAAA,EAI9B;AAAA,EACA,MACE,CAAC,UAA2C,EAAE,OAAO,EAAE,MACvD,CAAC,OAAO,aAAa;AACb,UAAA,EAAE,OAAO;AACT,UAAA,SAAS,qCAAW,UAAU,QAAQ,OAAO,QAAQ,GAAG,EAAE,EAAE;AAElE,WAAO,QAAQ,MAAM;AAAA,EAAA;AAE3B;AAEA,SAAS,kBAAkB;AAAA,EACzB,aAAa;AAAA,EACb,OAAO;AACT,CAAC;AAGM,MAAM,mBAAmB;AAAA,EAI9B;AAAA,EACA,MACE,CAAC,UAA2C,EAAE,OAAO,EAAE,MACvD,CAAC,OAAO,aAAa;AACb,UAAA,EAAE,OAAO;AACT,UAAA,SAAS,qCAAW,UAAU,QAAQ,OAAO,QAAQ,GAAG,EAAE,EAAE;AAElE,WAAO,QAAQ,MAAM;AAAA,EAAA;AAE3B;AAEA,SAAS,kBAAkB;AAAA,EACzB,aAAa;AAAA,EACb,OAAO;AACT,CAAC;AAGM,MAAM,qBAAqB;AAAA,EAChC;AAAA,EACA,MAAM,MAAM,CAAC,OAAO,aAAa;AACzB,UAAA,EAAE,OAAO;AACf,UAAM,SAAS,qCAAW,YAAY,EAAE;AAExC,WAAO,QAAQ,MAAM;AAAA,EAAA;AAEzB;AAEA,SAAS,oBAAoB;AAAA,EAC3B,aAAa;AAAA,EACb,OAAO;AACT,CAAC;AAKM,MAAM,6BAA6B;AAAA,EACxC;AAAA,EACA,MAAM,MAAM,CAAC,OAAO,aAAa;AACzB,UAAA,EAAE,cAAc;AAClB,QAAA,EAAE,qBAAqB,eAAuB,QAAA;AAE5C,UAAA,QAAQ,UAAU,eAAe;AACjC,UAAA,QAAQ,UAAU,eAAe;AAEvC,QAAI,SAAS,MAAc,QAAA,YAAY,OAAO,QAAQ;AAEtD,QAAI,MAAO,QAAO,aAAa,OAAO,QAAQ;AAAA,QACzC,QAAO,UAAU,OAAO,QAAQ;AAAA,EAAA;AAEzC;AAEA,SAAS,4BAA4B;AAAA,EACnC,aAAa;AAAA,EACb,OAAO;AACT,CAAC;AAGM,MAAM,sBAAsB;AAAA,EACjC;AAAA,EACA,MAAM,MAAM;AACd;AAEA,SAAS,qBAAqB;AAAA,EAC5B,aAAa;AAAA,EACb,OAAO;AACT,CAAC;AAGM,MAAM,qBAAqB;AAAA,EAChC;AAAA,EACA,MAAM,MAAM;AACd;AAEA,SAAS,oBAAoB;AAAA,EAC3B,aAAa;AAAA,EACb,OAAO;AACT,CAAC;AAGM,MAAM,sBAAsB;AAAA,EACjC;AAAA,EACA,CAAC,QAAQ,MAAM,CAAC,OAAO,aAAa;AAClC,QAAI,CAAC,UAAU,KAAK,EAAU,QAAA;AAC9B,QAAI,UAAU;AACN,YAAA,OAAO,aAAa,KAAK;AAC/B,eAAS,oBAAoB,KAAK,MAAM,IAAI,MAAM,KAAK,GAAG,CAAC;AAAA,IAAA;AAEtD,WAAA;AAAA,EAAA;AAEX;AAEA,SAAS,qBAAqB;AAAA,EAC5B,aAAa;AAAA,EACb,OAAO;AACT,CAAC;AAGM,MAAM,qBAAqB;AAAA,EAChC;AAAA,EACA,CAAC,QAAQ,MAAM,CAAC,OAAO,aAAa;AAClC,QAAI,CAAC,UAAU,KAAK,EAAU,QAAA;AAC9B,QAAI,UAAU;AACN,YAAA,OAAO,aAAa,KAAK;AAC/B,eAAS,oBAAoB,KAAK,MAAM,IAAI,MAAM,KAAK,MAAM,CAAC;AAAA,IAAA;AAEzD,WAAA;AAAA,EAAA;AAEX;AAEA,SAAS,oBAAoB;AAAA,EAC3B,aAAa;AAAA,EACb,OAAO;AACT,CAAC;AAKM,MAAM,kBAAkB;AAAA,EAI7B;AAAA,EACA,MACE,CAAC,YAAY,WACX,YAAY,aAAa,SAAS;AACxC;AAEA,SAAS,iBAAiB;AAAA,EACxB,aAAa;AAAA,EACb,OAAO;AACT,CAAC;AChSM,MAAM,uBAAuB;AAAA,EAClC,CAAC,QACC,IAAI;AAAA,IACF;AAAA,IACA,CAAC,OAAO,OAAO,OAAO,QAAQ;;AAC5B,YAAM,SAAS,MAAM,IAAI,QAAQ,KAAK;AACtC,UACE,CAAC,OACE,KAAK,EAAE,EACP;AAAA,QACC,OAAO,MAAM,EAAE;AAAA,QACf,OAAO,WAAW,EAAE;AAAA,QACpB,YAAY,KAAK,GAAG;AAAA,MACtB;AAEK,eAAA;AAEH,YAAA,MAAM,KAAK,IAAI,SAAO,WAAM,WAAN,mBAAc,QAAO,CAAC,GAAG,CAAC;AAEhD,YAAA,YAAY,YAAY,KAAK,KAAK,QAAO,WAAM,WAAN,mBAAc,GAAG,CAAC;AACjE,YAAM,KAAK,MAAM,GAAG,iBAAiB,OAAO,KAAK,SAAS;AACnD,aAAA,GACJ,aAAa,cAAc,OAAO,GAAG,KAAK,QAAQ,CAAC,CAAC,EACpD,eAAe;AAAA,IAAA;AAAA,EACpB;AAEN;AAEA,SAAS,sBAAsB;AAAA,EAC7B,aAAa;AAAA,EACb,OAAO;AACT,CAAC;AAMY,MAAA,cAAc,WAAW,eAAe;AAAA,EACnD,UAAU;AAAA,IACR,WAAW,CAAC,SAAS,KAAK;AAAA,IAC1B,SAAS,CAAC,QAAQ;AACV,YAAAA,YAAW,IAAI,IAAI,WAAW;AAEpC,aAAO,MAAMA,UAAS,KAAK,yBAAyB,GAAG;AAAA,IAAA;AAAA,EAE3D;AAAA,EACA,UAAU;AAAA,IACR,WAAW,CAAC,SAAS,WAAW;AAAA,IAChC,SAAS,CAAC,QAAQ;AACV,YAAAA,YAAW,IAAI,IAAI,WAAW;AAEpC,aAAO,MAAMA,UAAS,KAAK,yBAAyB,GAAG;AAAA,IAAA;AAAA,EAE3D;AAAA,EACA,WAAW;AAAA,IACT,WAAW,CAAC,aAAa,OAAO;AAAA,IAChC,SAAS,CAAC,QAAQ;AACV,YAAAA,YAAW,IAAI,IAAI,WAAW;AAEpC,aAAO,MAAMA,UAAS,KAAK,UAAU,GAAG;AAAA,IAAA;AAAA,EAC1C;AAEJ,CAAC;AAED,SAAS,YAAY,KAAK;AAAA,EACxB,aAAa;AAAA,EACb,OAAO;AACT,CAAC;AAED,SAAS,YAAY,WAAW;AAAA,EAC9B,aAAa;AAAA,EACb,OAAO;AACT,CAAC;ACnFD,MAAMC,OAAK;AACX,MAAM,aAAa;AAGZ,MAAM,2BAA2B;AAAA,EACtC;AAAA,EACA,OAAO;AAAA,IACL,OAAO;AAAA,IACP,SAAS;AAAA,IACT,UAAU;AAAA,IACV,OAAO;AAAA,MACL,OAAO;AAAA,QACL,SAAS;AAAA,QACT,UAAU;AAAA,MAAA;AAAA,IAEd;AAAA,IACA,UAAU;AAAA,MACR;AAAA,QACE,KAAK,iBAAiBA,IAAE;AAAA,QACxB,UAAU,CAAC,QAAQ;AACjB,cAAI,EAAE,eAAe,aAAc,OAAM,mBAAmB,GAAG;AAExD,iBAAA;AAAA,YACL,OAAO,IAAI,QAAQ;AAAA,UACrB;AAAA,QACF;AAAA,QACA,gBAAgB;AAAA,MAAA;AAAA,IAEpB;AAAA,IACA,OAAO,CAAC,SAAS;AACT,YAAA,QAAQ,KAAK,MAAM;AAElB,aAAA;AAAA,QACL;AAAA,QACA;AAAA;AAAA,UAEE,cAAc;AAAA,UACd,aAAaA;AAAAA,QACf;AAAA,QACA,CAAC,MAAM,KAAK;AAAA,QACZ,CAAC,MAAM,CAAC;AAAA,MACV;AAAA,IACF;AAAA,IACA,eAAe;AAAA,MACb,OAAO,CAAC,EAAE,WAAW,SAAS;AAAA,MAC9B,QAAQ,CAAC,OAAO,MAAM,SAAS;AAC7B,cACG,SAAS,MAAM;AAAA,UACd,OAAO,KAAK;AAAA,QACb,CAAA,EACA,KAAK,KAAK,QAAQ,EAClB,UAAU;AAAA,MAAA;AAAA,IAEjB;AAAA,IACA,YAAY;AAAA,MACV,OAAO,CAAC,SAAS,KAAK,KAAK,SAASA;AAAAA,MACpC,QAAQ,CAAC,OAAO,SAAS;AAEpB,cAAA,SAAS,YAAY,QAAW;AAAA,UAC/B,OAAO,KAAK,MAAM;AAAA,UAClB,YAAY,KAAK,MAAM;AAAA,QACxB,CAAA,EACA,KAAK,KAAK,OAAO,EACjB,UAAU;AAAA,MAAA;AAAA,IACf;AAAA,EAEJ;AACF;AAEA,SAAS,yBAAyB,KAAK;AAAA,EACrC,aAAa;AAAA,EACb,OAAO;AACT,CAAC;AAED,SAAS,yBAAyB,MAAM;AAAA,EACtC,aAAa;AAAA,EACb,OAAO;AACT,CAAC;AC7ED,MAAM,KAAK;AAGJ,MAAM,0BAA0B;AAAA,EACrC;AAAA,EACA,OAAO;AAAA,IACL,OAAO;AAAA,IACP,QAAQ;AAAA,IACR,MAAM;AAAA,IACN,OAAO;AAAA,MACL,OAAO;AAAA,QACL,SAAS;AAAA,QACT,UAAU;AAAA,MAAA;AAAA,IAEd;AAAA,IACA,UAAU;AAAA,MACR;AAAA,QACE,KAAK,kBAAkB,EAAE;AAAA,QACzB,UAAU,CAAC,QAAQ;AACjB,cAAI,EAAE,eAAe,aAAc,OAAM,mBAAmB,GAAG;AAExD,iBAAA;AAAA,YACL,OAAO,IAAI,QAAQ;AAAA,UACrB;AAAA,QAAA;AAAA,MACF;AAAA,IAEJ;AAAA,IACA,OAAO,CAAC,SAAS;AACT,YAAA,QAAQ,KAAK,MAAM;AAClB,aAAA;AAAA,QACL;AAAA,QACA;AAAA;AAAA,UAEE,cAAc;AAAA,UACd,aAAa;AAAA,QACf;AAAA,QACA;AAAA,MACF;AAAA,IACF;AAAA,IACA,eAAe;AAAA,MACb,OAAO,CAAC,EAAE,WAAW,SAAS;AAAA,MAC9B,QAAQ,CAAC,OAAO,MAAM,SAAS;AAC7B,cAAM,QAAQ,MAAM;AAAA,UAClB,OAAO,KAAK;AAAA,QAAA,CACb;AAAA,MAAA;AAAA,IAEL;AAAA,IACA,YAAY;AAAA,MACV,OAAO,CAAC,SAAS,KAAK,KAAK,SAAS;AAAA,MACpC,QAAQ,CAAC,OAAO,SAAS;AACjB,cAAA,QAAQ,qBAAqB,QAAW,QAAW;AAAA,UACvD,OAAO,KAAK,MAAM;AAAA,UAClB,YAAY,KAAK,MAAM;AAAA,QAAA,CACxB;AAAA,MAAA;AAAA,IACH;AAAA,EAEJ;AACF;AAEA,SAAS,wBAAwB,KAAK;AAAA,EACpC,aAAa;AAAA,EACb,OAAO;AACT,CAAC;AAED,SAAS,wBAAwB,MAAM;AAAA,EACrC,aAAa;AAAA,EACb,OAAO;AACT,CAAC;AChEM,MAAM,8BAA8B,eAAe;AAAA,EACxD,CAAC,SAAS;AACR,WAAO,CAAC,QAAQ;AACR,YAAA,aAAa,KAAK,GAAG;AACpB,aAAA;AAAA,QACL,GAAG;AAAA,QACH,OAAO;AAAA,UACL,GAAG,WAAW;AAAA,UACd,SAAS;AAAA,YACP,SAAS;AAAA,YACT,UAAU;AAAA,UAAA;AAAA,QAEd;AAAA,QACA,UAAU;AAAA,UACR;AAAA,YACE,KAAK;AAAA,YACL,UAAU,CAAC,QAAQ;AACjB,kBAAI,EAAE,eAAe,aAAc,OAAM,mBAAmB,GAAG;AAExD,qBAAA;AAAA,gBACL,OAAO,IAAI,QAAQ;AAAA,gBACnB,UAAU,IAAI,QAAQ;AAAA,gBACtB,QAAQ,IAAI,QAAQ;AAAA,gBACpB,SAAS,IAAI,QAAQ,UACjB,IAAI,QAAQ,YAAY,SACxB;AAAA,cACN;AAAA,YAAA;AAAA,UAEJ;AAAA,UACA,IAAI,yCAAY,aAAY,CAAA;AAAA,QAC9B;AAAA,QACA,OAAO,CAAC,SAAS;AACf,cAAI,WAAW,SAAS,KAAK,MAAM,WAAW;AACrC,mBAAA,WAAW,MAAM,IAAI;AAEvB,iBAAA;AAAA,YACL;AAAA,YACA;AAAA,cACE,kBAAkB;AAAA,cAClB,cAAc,KAAK,MAAM;AAAA,cACzB,kBAAkB,KAAK,MAAM;AAAA,cAC7B,eAAe,KAAK,MAAM;AAAA,cAC1B,gBAAgB,KAAK,MAAM;AAAA,YAC7B;AAAA,YACA;AAAA,UACF;AAAA,QACF;AAAA,QACA,eAAe;AAAA,UACb,OAAO,CAAC,EAAE,WAAW,SAAS;AAAA,UAC9B,QAAQ,CAAC,OAAO,MAAM,SAAS;AACzB,gBAAA,KAAK,WAAW,MAAM;AACxB,yBAAW,cAAc,OAAO,OAAO,MAAM,IAAI;AACjD;AAAA,YAAA;AAGF,kBAAM,QAAQ,KAAK,SAAS,OAAO,GAAG,KAAK,KAAK,MAAM;AACtD,kBAAM,UAAU,KAAK,WAAW,OAAO,QAAQ,KAAK,OAAO,IAAI;AAC/D,kBAAM,WAAW,KAAK,SAAS,OAAO,YAAY;AAClD,kBAAM,SAAS,KAAK,UAAU,OAAO,GAAG,KAAK,MAAM,KAAK;AAExD,kBAAM,SAAS,MAAM,EAAE,OAAO,UAAU,QAAQ,SAAS;AACnD,kBAAA,KAAK,KAAK,QAAQ;AACxB,kBAAM,UAAU;AAAA,UAAA;AAAA,QAEpB;AAAA,QACA,YAAY;AAAA,UACV,OAAO,CAAC,SAAS,KAAK,KAAK,SAAS;AAAA,UACpC,QAAQ,CAAC,OAAO,SAAS;AACnB,gBAAA,KAAK,MAAM,WAAW,MAAM;AACnB,yBAAA,WAAW,OAAO,OAAO,IAAI;AACxC;AAAA,YAAA;AAGI,kBAAA,QAAQ,KAAK,MAAM;AACnB,kBAAA,WAAW,KAAK,MAAM;AACtB,kBAAA,SAAS,KAAK,MAAM,WAAW;AAC/B,kBAAA,UAAU,KAAK,MAAM;AAErB,kBAAA,SAAS,YAAY,QAAW;AAAA,cACpC;AAAA,cACA;AAAA,cACA;AAAA,cACA;AAAA,YAAA,CACD;AACK,kBAAA,KAAK,KAAK,OAAO;AACvB,kBAAM,UAAU;AAAA,UAAA;AAAA,QAClB;AAAA,MAEJ;AAAA,IACF;AAAA,EAAA;AAEJ;AAEA,SAAS,6BAA6B;AAAA,EACpC,aAAa;AAAA,EACb,OAAO;AACT,CAAC;AAIY,MAAA,0BAA0B,WAAW,MAAM;AACtD,SAAO,IAAI;AAAA,IACT;AAAA,IACA,CAAC,OAAO,OAAO,OAAO,QAAQ;;AAC5B,YAAM,MAAM,MAAM,IAAI,QAAQ,KAAK;AACnC,UAAI,QAAQ;AACR,UAAA,OAAO,IAAI,KAAK,KAAK;AACzB,aAAO,QAAQ,KAAK,KAAK,SAAS,aAAa;AAC7C;AACO,eAAA,IAAI,KAAK,KAAK;AAAA,MAAA;AAGvB,UAAI,CAAC,QAAQ,KAAK,MAAM,WAAW,KAAa,QAAA;AAEhD,YAAM,UAAU,UAAQ,WAAM,WAAN,mBAAc,aAAY,GAAG;AAE/C,YAAA,SAAS,IAAI,OAAO,KAAK;AAC/B,YAAM,KAAK,MAAM;AAEjB,SAAG,YAAY,OAAO,GAAG,EAAE,cAAc,QAAQ,QAAW;AAAA,QAC1D,GAAG,KAAK;AAAA,QACR;AAAA,MAAA,CACD;AAEM,aAAA;AAAA,IAAA;AAAA,EAEX;AACF,CAAC;AAED,SAAS,yBAAyB;AAAA,EAChC,aAAa;AAAA,EACb,OAAO;AACT,CAAC;ACtIM,MAAM,SAA2B;AAAA,EACtC;AAAA,EACA;AACF,EAAE,KAAK;ACHA,MAAM,aAA+B;AAAA,EAC1C;AAAA,EACA;AACF;AAEa,MAAA,iBAAmC,CAAC,sBAAsB;ACJ1D,MAAA,uBAAuB,OAAO,MAAM,OAAO;AAExD,SAAS,sBAAsB;AAAA,EAC7B,aAAa;AAAA,EACb,OAAO;AACT,CAAC;ACNM,MAAM,uBAAuB,OAAO,MAAM,eAAe,EAAE,CAAC;AAEnE,SAAS,sBAAsB;AAAA,EAC7B,aAAa;AAAA,EACb,OAAO;AACT,CAAC;ACLM,MAAM,qBAAqB;AAAA,EAAO,MACvC,aAAa,EAAE,yBAAyB,KAAM,CAAA;AAChD;AAEA,SAAS,oBAAoB;AAAA,EAC3B,aAAa;AAAA,EACb,OAAO;AACT,CAAC;ACJM,MAAM,kBACX,QAAQ,aAAa,MAAM,SAAS;AAEtC,SAAS,gBAAgB,QAAQ;AAAA,EAC/B,aAAa;AAAA,EACb,OAAO;AACT,CAAC;AAED,SAAS,gBAAgB,SAAS;AAAA,EAChC,aAAa;AAAA,EACb,OAAO;AACT,CAAC;ACZD,MAAM,YAAY,IAAI,UAAU,kCAAkC;AAElE,SAAS,cAAc,MAAY,QAAc;AAC/C,MAAI,QAAQ;AACZ,SAAO,QAAQ,CAAC,OAAO,SAAS,MAAM;AAChC,QAAA,UAAU,KAAc,SAAA;AAAA,EAAA,CAC7B;AACM,SAAA;AACT;AAEa,MAAA,uBAAuB,OAAO,MAAM;AAC/C,SAAO,IAAI,OAAO;AAAA,IAChB,KAAK;AAAA,IACL,mBAAmB,CAAC,KAAK,UAAU,UAAU;AACvC,UAAA;AACE,YAAA,QAAQ,CAAC,MAAY,QAAgB;AACrC,YAAA,CAAC,GAAI,MAAK,MAAM;AAEhB,YAAA,KAAK,KAAK,SAAS,aAAc;AAErC,cAAM,OAAO,MAAM,IAAI,QAAQ,GAAG;AAClC,cAAM,WAAW,KAAK,KAAK,KAAK,KAAK;AACrC,cAAM,QAAQ,KAAK,KAAK,KAAK,QAAQ,CAAC;AACtC,cAAM,iBAAiB,MAAM;AAE7B,YAAI,CAAC,eAAgB;AAEf,cAAA,QAAQ,cAAc,MAAM,QAAQ;AACpC,cAAA,aAAa,eAAe,WAAW,KAAK;AAClD,YAAI,CAAC,WAAY;AACX,cAAA,QAAQ,WAAW,MAAM;AACzB,cAAA,eAAe,KAAK,MAAM;AAChC,YAAI,UAAU,aAAc;AAEzB,WAAA,cAAc,KAAK,QAAW,EAAE,GAAG,KAAK,OAAO,WAAW,OAAO;AAAA,MACtE;AACA,UAAI,SAAS,QAAQ,MAAM,IAAW,OAAA,IAAI,YAAY,KAAK;AAEpD,aAAA;AAAA,IAAA;AAAA,EACT,CACD;AACH,CAAC;AAED,SAAS,sBAAsB;AAAA,EAC7B,aAAa;AAAA,EACb,OAAO;AACT,CAAC;AC5CM,MAAM,UAA4B;AAAA,EACvC;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,EAAE,KAAK;ACAA,MAAM,SAA2B;AAAA,EACtC;AAAA,EAEA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EAEA;AAAA,EACA;AAAA,EAEA;AAAA,EACA;AACF,EAAE,KAAK;ACTA,MAAM,WAAW;AAAA,EACtB;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EAEA;AACF;ACvBO,MAAM,MAAM;AAAA,EACjB;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,EAAE,KAAK;"}