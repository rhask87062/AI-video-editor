{"version":3,"file":"index.js","sources":["../src/context/container.ts","../src/context/slice.ts","../src/inspector/inspector.ts","../src/plugin/ctx.ts","../src/timer/clock.ts","../src/timer/timer.ts"],"sourcesContent":["import { contextNotFound } from '@milkdown/exception'\n\nimport type { Slice, SliceType } from './slice'\n\n/// @internal\nexport type SliceMap = Map<symbol, Slice>\n\n/// Container is a map of slices.\nexport class Container {\n  /// @internal\n  sliceMap: SliceMap = new Map()\n\n  /// Get a slice from the container by slice type or slice name.\n  get = <T, N extends string = string>(\n    slice: SliceType<T, N> | N\n  ): Slice<T, N> => {\n    const context =\n      typeof slice === 'string'\n        ? [...this.sliceMap.values()].find((x) => x.type.name === slice)\n        : this.sliceMap.get(slice.id)\n\n    if (!context) {\n      const name = typeof slice === 'string' ? slice : slice.name\n      throw contextNotFound(name)\n    }\n    return context as Slice<T, N>\n  }\n\n  /// Remove a slice from the container by slice type or slice name.\n  remove = <T, N extends string = string>(slice: SliceType<T, N> | N): void => {\n    const context =\n      typeof slice === 'string'\n        ? [...this.sliceMap.values()].find((x) => x.type.name === slice)\n        : this.sliceMap.get(slice.id)\n\n    if (!context) return\n\n    this.sliceMap.delete(context.type.id)\n  }\n\n  /// Check if the container has a slice by slice type or slice name.\n  has = <T, N extends string = string>(slice: SliceType<T, N> | N): boolean => {\n    if (typeof slice === 'string')\n      return [...this.sliceMap.values()].some((x) => x.type.name === slice)\n\n    return this.sliceMap.has(slice.id)\n  }\n}\n","import { ctxCallOutOfScope } from '@milkdown/exception'\n\nimport type { SliceMap } from './container'\n\n/// Slice is a value of slice type.\nexport class Slice<T = any, N extends string = string> {\n  /// The type of the slice.\n  readonly type: SliceType<T, N>\n\n  /// @internal\n  #watchers: Array<(value: T) => unknown> = []\n\n  /// @internal\n  #value: T\n\n  /// @internal\n  #emit = () => {\n    this.#watchers.forEach((watcher) => watcher(this.#value))\n  }\n\n  /// @internal\n  constructor(container: SliceMap, value: T, type: SliceType<T, N>) {\n    this.type = type\n    this.#value = value\n    container.set(type.id, this)\n  }\n\n  /// Add a watcher for changes in the slice.\n  /// Returns a function to remove the watcher.\n  on(watcher: (value: T) => unknown) {\n    this.#watchers.push(watcher)\n    return () => {\n      this.#watchers = this.#watchers.filter((w) => w !== watcher)\n    }\n  }\n\n  /// Add a one-time watcher for changes in the slice.\n  /// The watcher will be removed after it is called.\n  /// Returns a function to remove the watcher.\n  once(watcher: (value: T) => unknown) {\n    const off = this.on((value) => {\n      watcher(value)\n      off()\n    })\n    return off\n  }\n\n  /// Remove a watcher.\n  off(watcher: (value: T) => unknown) {\n    this.#watchers = this.#watchers.filter((w) => w !== watcher)\n  }\n\n  /// Remove all watchers.\n  offAll() {\n    this.#watchers = []\n  }\n\n  /// Set the value of the slice.\n  set = (value: T) => {\n    this.#value = value\n    this.#emit()\n  }\n\n  /// Get the value of the slice.\n  get = () => this.#value\n\n  /// Update the value of the slice with a callback.\n  update = (updater: (prev: T) => T) => {\n    this.#value = updater(this.#value)\n    this.#emit()\n  }\n}\n\n/// Slice type can be used to create slices in different containers.\nexport class SliceType<T = any, N extends string = string> {\n  /// The unique id of the slice type.\n  readonly id: symbol\n  /// The name of the slice type.\n  readonly name: N\n  /// @internal\n  readonly _typeInfo: () => T\n  /// @internal\n  readonly _defaultValue: T\n\n  /// Create a slice type with a default value and a name.\n  /// The name should be unique in the container.\n  constructor(value: T, name: N) {\n    this.id = Symbol(`Context-${name}`)\n    this.name = name\n    this._defaultValue = value\n    this._typeInfo = (): T => {\n      throw ctxCallOutOfScope()\n    }\n  }\n\n  /// Create a slice with a container.\n  /// You can also pass a value to override the default value.\n  create(container: SliceMap, value: T = this._defaultValue): Slice<T, N> {\n    return new Slice(container, value, this)\n  }\n}\n\n/// Create a slice type with a default value and a name.\n/// This is equivalent to `new SliceType(value, name)`.\nexport const createSlice = <T = any, N extends string = string>(\n  value: T,\n  name: N\n) => new SliceType(value, name)\n","import type { Container, SliceType } from '../context'\nimport type { Clock, TimerStatus, TimerType } from '../timer'\nimport type { Meta } from './meta'\n\nexport interface Telemetry {\n  metadata: Meta\n  injectedSlices: { name: string; value: unknown }[]\n  consumedSlices: { name: string; value: unknown }[]\n  recordedTimers: { name: string; duration: number; status: TimerStatus }[]\n  waitTimers: { name: string; duration: number; status: TimerStatus }[]\n}\n\n/// The inspector object that is used to inspect the runtime environment of a ctx.\nexport class Inspector {\n  /// @internal\n  readonly #meta: Meta\n\n  /// @internal\n  readonly #container: Container\n\n  /// @internal\n  readonly #clock: Clock\n\n  /// @internal\n  readonly #injectedSlices: Set<SliceType | string> = new Set()\n\n  /// @internal\n  readonly #consumedSlices: Set<SliceType | string> = new Set()\n\n  /// @internal\n  readonly #recordedTimers: Map<\n    TimerType,\n    { duration: number; start: number }\n  > = new Map()\n\n  /// @internal\n  readonly #waitTimers: Map<TimerType, { duration: number }> = new Map()\n\n  /// Create an inspector with container, clock and metadata.\n  constructor(container: Container, clock: Clock, meta: Meta) {\n    this.#container = container\n    this.#clock = clock\n    this.#meta = meta\n  }\n\n  /// Read the runtime telemetry as an object of the ctx.\n  read = (): Telemetry => {\n    return {\n      metadata: this.#meta,\n      injectedSlices: [...this.#injectedSlices].map((slice) => ({\n        name: typeof slice === 'string' ? slice : slice.name,\n        value: this.#getSlice(slice),\n      })),\n      consumedSlices: [...this.#consumedSlices].map((slice) => ({\n        name: typeof slice === 'string' ? slice : slice.name,\n        value: this.#getSlice(slice),\n      })),\n      recordedTimers: [...this.#recordedTimers].map(\n        ([timer, { duration }]) => ({\n          name: timer.name,\n          duration,\n          status: this.#getTimer(timer),\n        })\n      ),\n      waitTimers: [...this.#waitTimers].map(([timer, { duration }]) => ({\n        name: timer.name,\n        duration,\n        status: this.#getTimer(timer),\n      })),\n    }\n  }\n\n  /// @internal\n  readonly onRecord = (timerType: TimerType) => {\n    this.#recordedTimers.set(timerType, { start: Date.now(), duration: 0 })\n  }\n\n  /// @internal\n  readonly onClear = (timerType: TimerType) => {\n    this.#recordedTimers.delete(timerType)\n  }\n\n  /// @internal\n  readonly onDone = (timerType: TimerType) => {\n    const timer = this.#recordedTimers.get(timerType)\n    if (!timer) return\n    timer.duration = Date.now() - timer.start\n  }\n\n  /// @internal\n  readonly onWait = (timerType: TimerType, promise: Promise<void>) => {\n    const start = Date.now()\n    promise\n      .finally(() => {\n        this.#waitTimers.set(timerType, { duration: Date.now() - start })\n      })\n      .catch(console.error)\n  }\n\n  /// @internal\n  readonly onInject = (sliceType: SliceType | string) => {\n    this.#injectedSlices.add(sliceType)\n  }\n\n  /// @internal\n  readonly onRemove = (sliceType: SliceType | string) => {\n    this.#injectedSlices.delete(sliceType)\n  }\n\n  /// @internal\n  readonly onUse = (sliceType: SliceType | string) => {\n    this.#consumedSlices.add(sliceType)\n  }\n\n  /// @internal\n  #getSlice = (sliceType: SliceType | string) => {\n    return this.#container.get(sliceType).get()\n  }\n\n  /// @internal\n  #getTimer = (timerType: TimerType) => {\n    return this.#clock.get(timerType).status\n  }\n}\n","import type { Container, Slice, SliceType } from '../context'\nimport type { Meta } from '../inspector'\nimport type { Clock, TimerType } from '../timer'\n\nimport { Inspector } from '../inspector'\n\n/// The ctx object that can be accessed in plugin and action.\nexport class Ctx {\n  /// @internal\n  readonly #container: Container\n  /// @internal\n  readonly #clock: Clock\n  /// @internal\n  readonly #meta?: Meta\n  /// @internal\n  readonly #inspector?: Inspector\n\n  /// Create a ctx object with container and clock.\n  constructor(container: Container, clock: Clock, meta?: Meta) {\n    this.#container = container\n    this.#clock = clock\n    this.#meta = meta\n    if (meta) this.#inspector = new Inspector(container, clock, meta)\n  }\n\n  /// Get metadata of the ctx.\n  get meta() {\n    return this.#meta\n  }\n\n  /// Get the inspector of the ctx.\n  get inspector() {\n    return this.#inspector\n  }\n\n  /// Produce a new ctx with metadata.\n  /// The new ctx will link to the same container and clock with the current ctx.\n  /// If the metadata is empty, it will return the current ctx.\n  readonly produce = (meta?: Meta) => {\n    if (meta && Object.keys(meta).length)\n      return new Ctx(this.#container, this.#clock, { ...meta })\n\n    return this\n  }\n\n  /// Add a slice into the ctx.\n  readonly inject = <T>(sliceType: SliceType<T>, value?: T) => {\n    const slice = sliceType.create(this.#container.sliceMap)\n    if (value != null) slice.set(value)\n\n    this.#inspector?.onInject(sliceType)\n\n    return this\n  }\n\n  /// Remove a slice from the ctx.\n  readonly remove = <T, N extends string = string>(\n    sliceType: SliceType<T, N> | N\n  ) => {\n    this.#container.remove(sliceType)\n    this.#inspector?.onRemove(sliceType)\n    return this\n  }\n\n  /// Add a timer into the ctx.\n  readonly record = (timerType: TimerType) => {\n    timerType.create(this.#clock.store)\n    this.#inspector?.onRecord(timerType)\n    return this\n  }\n\n  /// Remove a timer from the ctx.\n  readonly clearTimer = (timerType: TimerType) => {\n    this.#clock.remove(timerType)\n    this.#inspector?.onClear(timerType)\n    return this\n  }\n\n  /// Check if the ctx has a slice.\n  readonly isInjected = <T, N extends string = string>(\n    sliceType: SliceType<T, N> | N\n  ) => this.#container.has(sliceType)\n\n  /// Check if the ctx has a timer.\n  readonly isRecorded = (timerType: TimerType) => this.#clock.has(timerType)\n\n  /// Get a slice from the ctx.\n  readonly use = <T, N extends string = string>(\n    sliceType: SliceType<T, N> | N\n  ): Slice<T, N> => {\n    this.#inspector?.onUse(sliceType)\n    return this.#container.get(sliceType)\n  }\n\n  /// Get a slice value from the ctx.\n  readonly get = <T, N extends string>(sliceType: SliceType<T, N> | N) =>\n    this.use(sliceType).get()\n\n  /// Get a slice value from the ctx.\n  readonly set = <T, N extends string>(\n    sliceType: SliceType<T, N> | N,\n    value: T\n  ) => this.use(sliceType).set(value)\n\n  /// Update a slice value from the ctx by a callback.\n  readonly update = <T, N extends string>(\n    sliceType: SliceType<T, N> | N,\n    updater: (prev: T) => T\n  ) => this.use(sliceType).update(updater)\n\n  /// Get a timer from the ctx.\n  readonly timer = (timer: TimerType) => this.#clock.get(timer)\n\n  /// Resolve a timer from the ctx.\n  readonly done = (timer: TimerType) => {\n    this.timer(timer).done()\n    this.#inspector?.onDone(timer)\n  }\n\n  /// Start a timer from the ctx.\n  readonly wait = (timer: TimerType) => {\n    const promise = this.timer(timer).start()\n    this.#inspector?.onWait(timer, promise)\n    return promise\n  }\n\n  /// Start a list of timers from the ctx, the list is stored in a slice in the ctx.\n  /// This is equivalent to\n  ///\n  /// ```typescript\n  /// Promise.all(ctx.get(slice).map(x => ctx.wait(x))).\n  /// ```\n  readonly waitTimers = async (slice: SliceType<TimerType[]>) => {\n    await Promise.all(this.get(slice).map((x) => this.wait(x)))\n  }\n}\n","import { timerNotFound } from '@milkdown/exception'\n\nimport type { Timer, TimerType } from './timer'\n\n/// @internal\nexport type TimerMap = Map<symbol, Timer>\n\n/// Container is a map of timers.\nexport class Clock {\n  /// @internal\n  readonly store: TimerMap = new Map()\n\n  /// Get a timer from the clock by timer type.\n  get = (timer: TimerType) => {\n    const meta = this.store.get(timer.id)\n    if (!meta) throw timerNotFound(timer.name)\n    return meta\n  }\n\n  /// Remove a timer from the clock by timer type.\n  remove = (timer: TimerType) => {\n    this.store.delete(timer.id)\n  }\n\n  // Check if the clock has a timer by timer type.\n  has = (timer: TimerType) => {\n    return this.store.has(timer.id)\n  }\n}\n","import type { TimerMap } from './clock'\n\nexport type TimerStatus = 'pending' | 'resolved' | 'rejected'\n\n/// Timer is a promise that can be resolved by calling done.\nexport class Timer {\n  /// The type of the timer.\n  readonly type: TimerType\n\n  /// @internal\n  #promise: Promise<void> | null = null\n  /// @internal\n  #listener: EventListener | null = null\n  /// @internal\n  readonly #eventUniqId: symbol\n  /// @internal\n  #status: TimerStatus = 'pending'\n\n  /// @internal\n  constructor(clock: TimerMap, type: TimerType) {\n    this.#eventUniqId = Symbol(type.name)\n    this.type = type\n    clock.set(type.id, this)\n  }\n\n  /// The status of the timer.\n  /// Can be `pending`, `resolved` or `rejected`.\n  get status() {\n    return this.#status\n  }\n\n  /// Start the timer, which will return a promise.\n  /// If the timer is already started, it will return the same promise.\n  /// If the timer is not resolved in the timeout, it will reject the promise.\n  start = () => {\n    this.#promise ??= new Promise((resolve, reject) => {\n      this.#listener = (e: Event) => {\n        if (!(e instanceof CustomEvent)) return\n\n        if (e.detail.id === this.#eventUniqId) {\n          this.#status = 'resolved'\n          this.#removeListener()\n          e.stopImmediatePropagation()\n          resolve()\n        }\n      }\n\n      this.#waitTimeout(() => {\n        if (this.#status === 'pending') this.#status = 'rejected'\n\n        this.#removeListener()\n        reject(new Error(`Timing ${this.type.name} timeout.`))\n      })\n\n      this.#status = 'pending'\n      addEventListener(this.type.name, this.#listener)\n    })\n\n    return this.#promise\n  }\n\n  /// Resolve the timer.\n  done = () => {\n    const event = new CustomEvent(this.type.name, {\n      detail: { id: this.#eventUniqId },\n    })\n    dispatchEvent(event)\n  }\n\n  /// @internal\n  #removeListener = () => {\n    if (this.#listener) removeEventListener(this.type.name, this.#listener)\n  }\n\n  /// @internal\n  #waitTimeout = (ifTimeout: () => void) => {\n    setTimeout(() => {\n      ifTimeout()\n    }, this.type.timeout)\n  }\n}\n\n/// Timer type can be used to create timers in different clocks.\nexport class TimerType {\n  /// The unique id of the timer type.\n  readonly id: symbol\n  /// The name of the timer type.\n  readonly name: string\n  /// The timeout of the timer type.\n  readonly timeout: number\n\n  /// Create a timer type with a name and a timeout.\n  /// The name should be unique in the clock.\n  constructor(name: string, timeout = 3000) {\n    this.id = Symbol(`Timer-${name}`)\n    this.name = name\n    this.timeout = timeout\n  }\n\n  /// Create a timer with a clock.\n  create = (clock: TimerMap): Timer => {\n    return new Timer(clock, this)\n  }\n}\n\n/// Create a timer type with a name and a timeout.\n/// This is equivalent to `new TimerType(name, timeout)`.\nexport const createTimer = (name: string, timeout = 3000) =>\n  new TimerType(name, timeout)\n"],"names":["value","_container","_clock","_meta","meta"],"mappings":"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"}