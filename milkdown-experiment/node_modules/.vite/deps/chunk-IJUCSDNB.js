import {
  CommandsReady,
  InitReady,
  SchemaReady,
  commandsCtx,
  createCmdKey,
  createSlice,
  inputRulesCtx,
  keymap,
  marksCtx,
  missingMarkInSchema,
  missingNodeInSchema,
  nodesCtx,
  prosePluginsCtx,
  remarkPluginsCtx,
  schemaCtx
} from "./chunk-X37FA2KY.js";

// node_modules/nanoid/index.browser.js
var random = (bytes) => crypto.getRandomValues(new Uint8Array(bytes));
var customRandom = (alphabet, defaultSize, getRandom) => {
  let mask = (2 << Math.log2(alphabet.length - 1)) - 1;
  let step = -~(1.6 * mask * defaultSize / alphabet.length);
  return (size = defaultSize) => {
    let id = "";
    while (true) {
      let bytes = getRandom(step);
      let j = step | 0;
      while (j--) {
        id += alphabet[bytes[j] & mask] || "";
        if (id.length >= size) return id;
      }
    }
  };
};
var customAlphabet = (alphabet, size = 21) => customRandom(alphabet, size | 0, random);

// node_modules/@milkdown/utils/lib/index.js
var nanoid = customAlphabet("abcedfghicklmn", 10);
function $command(key, cmd) {
  const cmdKey = createCmdKey(key);
  const plugin = (ctx) => async () => {
    plugin.key = cmdKey;
    await ctx.wait(CommandsReady);
    const command = cmd(ctx);
    ctx.get(commandsCtx).create(cmdKey, command);
    plugin.run = (payload) => ctx.get(commandsCtx).call(key, payload);
    return () => {
      ctx.get(commandsCtx).remove(cmdKey);
    };
  };
  return plugin;
}
function $inputRule(inputRule) {
  const plugin = (ctx) => async () => {
    await ctx.wait(SchemaReady);
    const ir = inputRule(ctx);
    ctx.update(inputRulesCtx, (irs) => [...irs, ir]);
    plugin.inputRule = ir;
    return () => {
      ctx.update(inputRulesCtx, (irs) => irs.filter((x) => x !== ir));
    };
  };
  return plugin;
}
function $mark(id, schema) {
  const plugin = (ctx) => async () => {
    const markSchema = schema(ctx);
    ctx.update(marksCtx, (ns) => [
      ...ns.filter((n) => n[0] !== id),
      [id, markSchema]
    ]);
    plugin.id = id;
    plugin.schema = markSchema;
    return () => {
      ctx.update(marksCtx, (ns) => ns.filter(([x]) => x !== id));
    };
  };
  plugin.type = (ctx) => {
    const markType = ctx.get(schemaCtx).marks[id];
    if (!markType) throw missingMarkInSchema(id);
    return markType;
  };
  return plugin;
}
function $node(id, schema) {
  const plugin = (ctx) => async () => {
    const nodeSchema = schema(ctx);
    ctx.update(nodesCtx, (ns) => [
      ...ns.filter((n) => n[0] !== id),
      [id, nodeSchema]
    ]);
    plugin.id = id;
    plugin.schema = nodeSchema;
    return () => {
      ctx.update(nodesCtx, (ns) => ns.filter(([x]) => x !== id));
    };
  };
  plugin.type = (ctx) => {
    const nodeType = ctx.get(schemaCtx).nodes[id];
    if (!nodeType) throw missingNodeInSchema(id);
    return nodeType;
  };
  return plugin;
}
function $prose(prose) {
  let prosePlugin;
  const plugin = (ctx) => async () => {
    await ctx.wait(SchemaReady);
    prosePlugin = prose(ctx);
    ctx.update(prosePluginsCtx, (ps) => [...ps, prosePlugin]);
    return () => {
      ctx.update(prosePluginsCtx, (ps) => ps.filter((x) => x !== prosePlugin));
    };
  };
  plugin.plugin = () => prosePlugin;
  plugin.key = () => prosePlugin.spec.key;
  return plugin;
}
function $shortcut(shortcut) {
  const plugin = (ctx) => async () => {
    await ctx.wait(SchemaReady);
    const k = shortcut(ctx);
    const keymapPlugin = keymap(k);
    ctx.update(prosePluginsCtx, (ps) => [...ps, keymapPlugin]);
    plugin.keymap = k;
    return () => {
      ctx.update(prosePluginsCtx, (ps) => ps.filter((x) => x !== keymapPlugin));
    };
  };
  return plugin;
}
function $ctx(value, name) {
  const slice = createSlice(value, name);
  const plugin = (ctx) => {
    ctx.inject(slice);
    return () => {
      return () => {
        ctx.remove(slice);
      };
    };
  };
  plugin.key = slice;
  return plugin;
}
function $nodeSchema(id, schema) {
  const schemaCtx2 = $ctx(schema, id);
  const nodeSchema = $node(id, (ctx) => {
    const userSchema = ctx.get(schemaCtx2.key);
    return userSchema(ctx);
  });
  const result = [schemaCtx2, nodeSchema];
  result.id = nodeSchema.id;
  result.node = nodeSchema;
  result.type = (ctx) => nodeSchema.type(ctx);
  result.schema = nodeSchema.schema;
  result.ctx = schemaCtx2;
  result.key = schemaCtx2.key;
  result.extendSchema = (handler) => {
    return (ctx) => () => {
      const prev = ctx.get(schemaCtx2.key);
      const next = handler(prev);
      const nodeSchema2 = next(ctx);
      ctx.update(nodesCtx, (ns) => [
        ...ns.filter((n) => n[0] !== id),
        [id, nodeSchema2]
      ]);
      result.schema = nodeSchema2;
    };
  };
  return result;
}
function $markSchema(id, schema) {
  const schemaCtx2 = $ctx(schema, id);
  const markSchema = $mark(id, (ctx) => {
    const userSchema = ctx.get(schemaCtx2.key);
    return userSchema(ctx);
  });
  const result = [schemaCtx2, markSchema];
  result.id = markSchema.id;
  result.mark = markSchema;
  result.type = markSchema.type;
  result.schema = markSchema.schema;
  result.ctx = schemaCtx2;
  result.key = schemaCtx2.key;
  result.extendSchema = (handler) => {
    return (ctx) => () => {
      const prev = ctx.get(schemaCtx2.key);
      const next = handler(prev);
      const markSchema2 = next(ctx);
      ctx.update(marksCtx, (ms) => [
        ...ms.filter((m) => m[0] !== id),
        [id, markSchema2]
      ]);
      result.schema = markSchema2;
    };
  };
  return result;
}
function $useKeymap(name, userKeymap) {
  const key = Object.fromEntries(
    Object.entries(userKeymap).map(([key2, { shortcuts: shortcuts2 }]) => {
      return [key2, shortcuts2];
    })
  );
  const keymapDef = $ctx(key, `${name}Keymap`);
  const shortcuts = $shortcut((ctx) => {
    const keys = ctx.get(keymapDef.key);
    const keymapTuple = Object.entries(userKeymap).flatMap(
      ([key2, { command }]) => {
        const targetKeys = [keys[key2]].flat();
        return targetKeys.map((targetKey) => [targetKey, command(ctx)]);
      }
    );
    return Object.fromEntries(keymapTuple);
  });
  const result = [keymapDef, shortcuts];
  result.ctx = keymapDef;
  result.shortcuts = shortcuts;
  result.key = keymapDef.key;
  result.keymap = shortcuts.keymap;
  return result;
}
var $nodeAttr = (name, value = () => ({})) => $ctx(value, `${name}Attr`);
var $markAttr = (name, value = () => ({})) => $ctx(value, `${name}Attr`);
function $remark(id, remark, initialOptions) {
  const options = $ctx(initialOptions ?? {}, id);
  const plugin = (ctx) => async () => {
    await ctx.wait(InitReady);
    const re = remark(ctx);
    const remarkPlugin = {
      plugin: re,
      options: ctx.get(options.key)
    };
    ctx.update(remarkPluginsCtx, (rp) => [...rp, remarkPlugin]);
    return () => {
      ctx.update(remarkPluginsCtx, (rp) => rp.filter((x) => x !== remarkPlugin));
    };
  };
  const result = [options, plugin];
  result.id = id;
  result.plugin = plugin;
  result.options = options;
  return result;
}

export {
  $command,
  $inputRule,
  $node,
  $prose,
  $ctx,
  $nodeSchema,
  $markSchema,
  $useKeymap,
  $nodeAttr,
  $markAttr,
  $remark
};
//# sourceMappingURL=chunk-IJUCSDNB.js.map
