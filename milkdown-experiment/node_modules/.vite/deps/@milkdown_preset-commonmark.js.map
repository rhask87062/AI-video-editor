{
  "version": 3,
  "sources": ["../../prosemirror-schema-list/dist/index.js", "../../mdast-util-definitions/lib/index.js", "../../remark-inline-links/lib/index.js", "../../@milkdown/preset-commonmark/src/__internal__/serialize-text.ts", "../../@milkdown/preset-commonmark/src/__internal__/with-meta.ts", "../../@milkdown/preset-commonmark/src/mark/emphasis.ts", "../../@milkdown/preset-commonmark/src/mark/strong.ts", "../../@milkdown/preset-commonmark/src/mark/inline-code.ts", "../../@milkdown/preset-commonmark/src/mark/link.ts", "../../@milkdown/preset-commonmark/src/node/doc.ts", "../../@milkdown/preset-commonmark/src/plugin/remark-preserve-empty-line.ts", "../../@milkdown/preset-commonmark/src/node/paragraph.ts", "../../@milkdown/preset-commonmark/src/node/heading.ts", "../../@milkdown/preset-commonmark/src/node/blockquote.ts", "../../@milkdown/preset-commonmark/src/node/code-block.ts", "../../@milkdown/preset-commonmark/src/node/image.ts", "../../@milkdown/preset-commonmark/src/node/hardbreak.ts", "../../@milkdown/preset-commonmark/src/node/hr.ts", "../../@milkdown/preset-commonmark/src/node/bullet-list.ts", "../../@milkdown/preset-commonmark/src/node/ordered-list.ts", "../../@milkdown/preset-commonmark/src/node/list-item.ts", "../../@milkdown/preset-commonmark/src/node/text.ts", "../../@milkdown/preset-commonmark/src/node/html.ts", "../../@milkdown/preset-commonmark/src/composed/schema.ts", "../../@milkdown/preset-commonmark/src/composed/inputrules.ts", "../../@milkdown/preset-commonmark/src/composed/commands.ts", "../../@milkdown/preset-commonmark/src/composed/keymap.ts", "../../@milkdown/preset-commonmark/src/plugin/remark-add-order-in-list-plugin.ts", "../../@milkdown/preset-commonmark/src/plugin/remark-line-break.ts", "../../@milkdown/preset-commonmark/src/plugin/remark-inline-link-plugin.ts", "../../@milkdown/preset-commonmark/src/plugin/remark-html-transformer.ts", "../../@milkdown/preset-commonmark/src/plugin/remark-marker-plugin.ts", "../../@milkdown/preset-commonmark/src/plugin/inline-nodes-cursor-plugin.ts", "../../@milkdown/preset-commonmark/src/plugin/hardbreak-clear-mark-plugin.ts", "../../@milkdown/preset-commonmark/src/plugin/hardbreak-filter-plugin.ts", "../../@milkdown/preset-commonmark/src/plugin/sync-heading-id-plugin.ts", "../../@milkdown/preset-commonmark/src/plugin/sync-list-order-plugin.ts", "../../@milkdown/preset-commonmark/src/composed/plugins.ts", "../../@milkdown/preset-commonmark/src/index.ts"],
  "sourcesContent": ["import { findWrapping, ReplaceAroundStep, canSplit, liftTarget, canJoin } from 'prosemirror-transform';\nimport { NodeRange, Fragment, Slice } from 'prosemirror-model';\nimport { Selection } from 'prosemirror-state';\n\nconst olDOM = [\"ol\", 0], ulDOM = [\"ul\", 0], liDOM = [\"li\", 0];\n/**\nAn ordered list [node spec](https://prosemirror.net/docs/ref/#model.NodeSpec). Has a single\nattribute, `order`, which determines the number at which the list\nstarts counting, and defaults to 1. Represented as an `<ol>`\nelement.\n*/\nconst orderedList = {\n    attrs: { order: { default: 1, validate: \"number\" } },\n    parseDOM: [{ tag: \"ol\", getAttrs(dom) {\n                return { order: dom.hasAttribute(\"start\") ? +dom.getAttribute(\"start\") : 1 };\n            } }],\n    toDOM(node) {\n        return node.attrs.order == 1 ? olDOM : [\"ol\", { start: node.attrs.order }, 0];\n    }\n};\n/**\nA bullet list node spec, represented in the DOM as `<ul>`.\n*/\nconst bulletList = {\n    parseDOM: [{ tag: \"ul\" }],\n    toDOM() { return ulDOM; }\n};\n/**\nA list item (`<li>`) spec.\n*/\nconst listItem = {\n    parseDOM: [{ tag: \"li\" }],\n    toDOM() { return liDOM; },\n    defining: true\n};\nfunction add(obj, props) {\n    let copy = {};\n    for (let prop in obj)\n        copy[prop] = obj[prop];\n    for (let prop in props)\n        copy[prop] = props[prop];\n    return copy;\n}\n/**\nConvenience function for adding list-related node types to a map\nspecifying the nodes for a schema. Adds\n[`orderedList`](https://prosemirror.net/docs/ref/#schema-list.orderedList) as `\"ordered_list\"`,\n[`bulletList`](https://prosemirror.net/docs/ref/#schema-list.bulletList) as `\"bullet_list\"`, and\n[`listItem`](https://prosemirror.net/docs/ref/#schema-list.listItem) as `\"list_item\"`.\n\n`itemContent` determines the content expression for the list items.\nIf you want the commands defined in this module to apply to your\nlist structure, it should have a shape like `\"paragraph block*\"` or\n`\"paragraph (ordered_list | bullet_list)*\"`. `listGroup` can be\ngiven to assign a group name to the list node types, for example\n`\"block\"`.\n*/\nfunction addListNodes(nodes, itemContent, listGroup) {\n    return nodes.append({\n        ordered_list: add(orderedList, { content: \"list_item+\", group: listGroup }),\n        bullet_list: add(bulletList, { content: \"list_item+\", group: listGroup }),\n        list_item: add(listItem, { content: itemContent })\n    });\n}\n/**\nReturns a command function that wraps the selection in a list with\nthe given type an attributes. If `dispatch` is null, only return a\nvalue to indicate whether this is possible, but don't actually\nperform the change.\n*/\nfunction wrapInList(listType, attrs = null) {\n    return function (state, dispatch) {\n        let { $from, $to } = state.selection;\n        let range = $from.blockRange($to);\n        if (!range)\n            return false;\n        let tr = dispatch ? state.tr : null;\n        if (!wrapRangeInList(tr, range, listType, attrs))\n            return false;\n        if (dispatch)\n            dispatch(tr.scrollIntoView());\n        return true;\n    };\n}\n/**\nTry to wrap the given node range in a list of the given type.\nReturn `true` when this is possible, `false` otherwise. When `tr`\nis non-null, the wrapping is added to that transaction. When it is\n`null`, the function only queries whether the wrapping is\npossible.\n*/\nfunction wrapRangeInList(tr, range, listType, attrs = null) {\n    let doJoin = false, outerRange = range, doc = range.$from.doc;\n    // This is at the top of an existing list item\n    if (range.depth >= 2 && range.$from.node(range.depth - 1).type.compatibleContent(listType) && range.startIndex == 0) {\n        // Don't do anything if this is the top of the list\n        if (range.$from.index(range.depth - 1) == 0)\n            return false;\n        let $insert = doc.resolve(range.start - 2);\n        outerRange = new NodeRange($insert, $insert, range.depth);\n        if (range.endIndex < range.parent.childCount)\n            range = new NodeRange(range.$from, doc.resolve(range.$to.end(range.depth)), range.depth);\n        doJoin = true;\n    }\n    let wrap = findWrapping(outerRange, listType, attrs, range);\n    if (!wrap)\n        return false;\n    if (tr)\n        doWrapInList(tr, range, wrap, doJoin, listType);\n    return true;\n}\nfunction doWrapInList(tr, range, wrappers, joinBefore, listType) {\n    let content = Fragment.empty;\n    for (let i = wrappers.length - 1; i >= 0; i--)\n        content = Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content));\n    tr.step(new ReplaceAroundStep(range.start - (joinBefore ? 2 : 0), range.end, range.start, range.end, new Slice(content, 0, 0), wrappers.length, true));\n    let found = 0;\n    for (let i = 0; i < wrappers.length; i++)\n        if (wrappers[i].type == listType)\n            found = i + 1;\n    let splitDepth = wrappers.length - found;\n    let splitPos = range.start + wrappers.length - (joinBefore ? 2 : 0), parent = range.parent;\n    for (let i = range.startIndex, e = range.endIndex, first = true; i < e; i++, first = false) {\n        if (!first && canSplit(tr.doc, splitPos, splitDepth)) {\n            tr.split(splitPos, splitDepth);\n            splitPos += 2 * splitDepth;\n        }\n        splitPos += parent.child(i).nodeSize;\n    }\n    return tr;\n}\n/**\nBuild a command that splits a non-empty textblock at the top level\nof a list item by also splitting that list item.\n*/\nfunction splitListItem(itemType, itemAttrs) {\n    return function (state, dispatch) {\n        let { $from, $to, node } = state.selection;\n        if ((node && node.isBlock) || $from.depth < 2 || !$from.sameParent($to))\n            return false;\n        let grandParent = $from.node(-1);\n        if (grandParent.type != itemType)\n            return false;\n        if ($from.parent.content.size == 0 && $from.node(-1).childCount == $from.indexAfter(-1)) {\n            // In an empty block. If this is a nested list, the wrapping\n            // list item should be split. Otherwise, bail out and let next\n            // command handle lifting.\n            if ($from.depth == 3 || $from.node(-3).type != itemType ||\n                $from.index(-2) != $from.node(-2).childCount - 1)\n                return false;\n            if (dispatch) {\n                let wrap = Fragment.empty;\n                let depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3;\n                // Build a fragment containing empty versions of the structure\n                // from the outer list item to the parent node of the cursor\n                for (let d = $from.depth - depthBefore; d >= $from.depth - 3; d--)\n                    wrap = Fragment.from($from.node(d).copy(wrap));\n                let depthAfter = $from.indexAfter(-1) < $from.node(-2).childCount ? 1\n                    : $from.indexAfter(-2) < $from.node(-3).childCount ? 2 : 3;\n                // Add a second list item with an empty default start node\n                wrap = wrap.append(Fragment.from(itemType.createAndFill()));\n                let start = $from.before($from.depth - (depthBefore - 1));\n                let tr = state.tr.replace(start, $from.after(-depthAfter), new Slice(wrap, 4 - depthBefore, 0));\n                let sel = -1;\n                tr.doc.nodesBetween(start, tr.doc.content.size, (node, pos) => {\n                    if (sel > -1)\n                        return false;\n                    if (node.isTextblock && node.content.size == 0)\n                        sel = pos + 1;\n                });\n                if (sel > -1)\n                    tr.setSelection(Selection.near(tr.doc.resolve(sel)));\n                dispatch(tr.scrollIntoView());\n            }\n            return true;\n        }\n        let nextType = $to.pos == $from.end() ? grandParent.contentMatchAt(0).defaultType : null;\n        let tr = state.tr.delete($from.pos, $to.pos);\n        let types = nextType ? [itemAttrs ? { type: itemType, attrs: itemAttrs } : null, { type: nextType }] : undefined;\n        if (!canSplit(tr.doc, $from.pos, 2, types))\n            return false;\n        if (dispatch)\n            dispatch(tr.split($from.pos, 2, types).scrollIntoView());\n        return true;\n    };\n}\n/**\nActs like [`splitListItem`](https://prosemirror.net/docs/ref/#schema-list.splitListItem), but\nwithout resetting the set of active marks at the cursor.\n*/\nfunction splitListItemKeepMarks(itemType, itemAttrs) {\n    let split = splitListItem(itemType, itemAttrs);\n    return (state, dispatch) => {\n        return split(state, dispatch && (tr => {\n            let marks = state.storedMarks || (state.selection.$to.parentOffset && state.selection.$from.marks());\n            if (marks)\n                tr.ensureMarks(marks);\n            dispatch(tr);\n        }));\n    };\n}\n/**\nCreate a command to lift the list item around the selection up into\na wrapping list.\n*/\nfunction liftListItem(itemType) {\n    return function (state, dispatch) {\n        let { $from, $to } = state.selection;\n        let range = $from.blockRange($to, node => node.childCount > 0 && node.firstChild.type == itemType);\n        if (!range)\n            return false;\n        if (!dispatch)\n            return true;\n        if ($from.node(range.depth - 1).type == itemType) // Inside a parent list\n            return liftToOuterList(state, dispatch, itemType, range);\n        else // Outer list node\n            return liftOutOfList(state, dispatch, range);\n    };\n}\nfunction liftToOuterList(state, dispatch, itemType, range) {\n    let tr = state.tr, end = range.end, endOfList = range.$to.end(range.depth);\n    if (end < endOfList) {\n        // There are siblings after the lifted items, which must become\n        // children of the last item\n        tr.step(new ReplaceAroundStep(end - 1, endOfList, end, endOfList, new Slice(Fragment.from(itemType.create(null, range.parent.copy())), 1, 0), 1, true));\n        range = new NodeRange(tr.doc.resolve(range.$from.pos), tr.doc.resolve(endOfList), range.depth);\n    }\n    const target = liftTarget(range);\n    if (target == null)\n        return false;\n    tr.lift(range, target);\n    let $after = tr.doc.resolve(tr.mapping.map(end, -1) - 1);\n    if (canJoin(tr.doc, $after.pos) && $after.nodeBefore.type == $after.nodeAfter.type)\n        tr.join($after.pos);\n    dispatch(tr.scrollIntoView());\n    return true;\n}\nfunction liftOutOfList(state, dispatch, range) {\n    let tr = state.tr, list = range.parent;\n    // Merge the list items into a single big item\n    for (let pos = range.end, i = range.endIndex - 1, e = range.startIndex; i > e; i--) {\n        pos -= list.child(i).nodeSize;\n        tr.delete(pos - 1, pos + 1);\n    }\n    let $start = tr.doc.resolve(range.start), item = $start.nodeAfter;\n    if (tr.mapping.map(range.end) != range.start + $start.nodeAfter.nodeSize)\n        return false;\n    let atStart = range.startIndex == 0, atEnd = range.endIndex == list.childCount;\n    let parent = $start.node(-1), indexBefore = $start.index(-1);\n    if (!parent.canReplace(indexBefore + (atStart ? 0 : 1), indexBefore + 1, item.content.append(atEnd ? Fragment.empty : Fragment.from(list))))\n        return false;\n    let start = $start.pos, end = start + item.nodeSize;\n    // Strip off the surrounding list. At the sides where we're not at\n    // the end of the list, the existing list is closed. At sides where\n    // this is the end, it is overwritten to its end.\n    tr.step(new ReplaceAroundStep(start - (atStart ? 1 : 0), end + (atEnd ? 1 : 0), start + 1, end - 1, new Slice((atStart ? Fragment.empty : Fragment.from(list.copy(Fragment.empty)))\n        .append(atEnd ? Fragment.empty : Fragment.from(list.copy(Fragment.empty))), atStart ? 0 : 1, atEnd ? 0 : 1), atStart ? 0 : 1));\n    dispatch(tr.scrollIntoView());\n    return true;\n}\n/**\nCreate a command to sink the list item around the selection down\ninto an inner list.\n*/\nfunction sinkListItem(itemType) {\n    return function (state, dispatch) {\n        let { $from, $to } = state.selection;\n        let range = $from.blockRange($to, node => node.childCount > 0 && node.firstChild.type == itemType);\n        if (!range)\n            return false;\n        let startIndex = range.startIndex;\n        if (startIndex == 0)\n            return false;\n        let parent = range.parent, nodeBefore = parent.child(startIndex - 1);\n        if (nodeBefore.type != itemType)\n            return false;\n        if (dispatch) {\n            let nestedBefore = nodeBefore.lastChild && nodeBefore.lastChild.type == parent.type;\n            let inner = Fragment.from(nestedBefore ? itemType.create() : null);\n            let slice = new Slice(Fragment.from(itemType.create(null, Fragment.from(parent.type.create(null, inner)))), nestedBefore ? 3 : 1, 0);\n            let before = range.start, after = range.end;\n            dispatch(state.tr.step(new ReplaceAroundStep(before - (nestedBefore ? 3 : 1), after, before, after, slice, 1, true))\n                .scrollIntoView());\n        }\n        return true;\n    };\n}\n\nexport { addListNodes, bulletList, liftListItem, listItem, orderedList, sinkListItem, splitListItem, splitListItemKeepMarks, wrapInList, wrapRangeInList };\n", "/**\n * @typedef {import('mdast').Definition} Definition\n * @typedef {import('mdast').Nodes} Nodes\n */\n\n/**\n * @callback GetDefinition\n *   Get a definition by identifier.\n * @param {string | null | undefined} [identifier]\n *   Identifier of definition (optional).\n * @returns {Definition | undefined}\n *   Definition corresponding to `identifier` or `null`.\n */\n\nimport {visit} from 'unist-util-visit'\n\n/**\n * Find definitions in `tree`.\n *\n * Uses CommonMark precedence, which means that earlier definitions are\n * preferred over duplicate later definitions.\n *\n * @param {Nodes} tree\n *   Tree to check.\n * @returns {GetDefinition}\n *   Getter.\n */\nexport function definitions(tree) {\n  /** @type {Map<string, Definition>} */\n  const cache = new Map()\n\n  if (!tree || !tree.type) {\n    throw new Error('mdast-util-definitions expected node')\n  }\n\n  visit(tree, 'definition', function (definition) {\n    const id = clean(definition.identifier)\n    if (id && !cache.get(id)) {\n      cache.set(id, definition)\n    }\n  })\n\n  return definition\n\n  /** @type {GetDefinition} */\n  function definition(identifier) {\n    const id = clean(identifier)\n    return cache.get(id)\n  }\n}\n\n/**\n * @param {string | null | undefined} [value]\n * @returns {string}\n */\nfunction clean(value) {\n  return String(value || '').toUpperCase()\n}\n", "/**\n * @typedef {import('mdast').Root} Root\n */\n\nimport {definitions} from 'mdast-util-definitions'\nimport {SKIP, visit} from 'unist-util-visit'\n\n/**\n * Turn references and definitions into normal links and images.\n *\n * @returns\n *   Transform.\n */\nexport default function remarkInlineLinks() {\n  /**\n   * Transform.\n   *\n   * @param {Root} tree\n   *   Tree.\n   * @returns {undefined}\n   *   Nothing.\n   */\n  return function (tree) {\n    const definition = definitions(tree)\n\n    visit(tree, function (node, index, parent) {\n      if (\n        node.type === 'definition' &&\n        parent !== undefined &&\n        typeof index === 'number'\n      ) {\n        parent.children.splice(index, 1)\n        return [SKIP, index]\n      }\n\n      if (node.type === 'imageReference' || node.type === 'linkReference') {\n        const def = definition(node.identifier)\n\n        if (def && parent && typeof index === 'number') {\n          parent.children[index] =\n            node.type === 'imageReference'\n              ? {type: 'image', url: def.url, title: def.title, alt: node.alt}\n              : {\n                  type: 'link',\n                  url: def.url,\n                  title: def.title,\n                  children: node.children\n                }\n          return [SKIP, index]\n        }\n      }\n    })\n  }\n}\n", "import type { Node } from '@milkdown/prose/model'\nimport type { SerializerState } from '@milkdown/transformer'\n\nimport { Fragment } from '@milkdown/prose/model'\n\nexport function serializeText(state: SerializerState, node: Node) {\n  const lastIsHardBreak =\n    node.childCount >= 1 && node.lastChild?.type.name === 'hardbreak'\n  if (!lastIsHardBreak) {\n    state.next(node.content)\n    return\n  }\n\n  const contentArr: Node[] = []\n  node.content.forEach((n, _, i) => {\n    if (i === node.childCount - 1) return\n\n    contentArr.push(n)\n  })\n  state.next(Fragment.fromArray(contentArr))\n}\n", "import type { Meta, MilkdownPlugin } from '@milkdown/ctx'\n\nexport function withMeta<T extends MilkdownPlugin>(\n  plugin: T,\n  meta: Partial<Meta> & Pick<Meta, 'displayName'>\n): T {\n  Object.assign(plugin, {\n    meta: {\n      package: '@milkdown/preset-commonmark',\n      ...meta,\n    },\n  })\n\n  return plugin\n}\n", "import { commandsCtx, remarkStringifyOptionsCtx } from '@milkdown/core'\nimport { markRule } from '@milkdown/prose'\nimport { toggleMark } from '@milkdown/prose/commands'\nimport {\n  $command,\n  $inputRule,\n  $markAttr,\n  $markSchema,\n  $useKeymap,\n} from '@milkdown/utils'\n\nimport { withMeta } from '../__internal__'\n\n/// HTML attributes for the emphasis mark.\nexport const emphasisAttr = $markAttr('emphasis')\n\nwithMeta(emphasisAttr, {\n  displayName: 'Attr<emphasis>',\n  group: 'Emphasis',\n})\n\n/// Emphasis mark schema.\nexport const emphasisSchema = $markSchema('emphasis', (ctx) => ({\n  attrs: {\n    marker: {\n      default: ctx.get(remarkStringifyOptionsCtx).emphasis || '*',\n      validate: 'string',\n    },\n  },\n  parseDOM: [\n    { tag: 'i' },\n    { tag: 'em' },\n    { style: 'font-style', getAttrs: (value) => (value === 'italic') as false },\n  ],\n  toDOM: (mark) => ['em', ctx.get(emphasisAttr.key)(mark)],\n  parseMarkdown: {\n    match: (node) => node.type === 'emphasis',\n    runner: (state, node, markType) => {\n      state.openMark(markType, { marker: node.marker })\n      state.next(node.children)\n      state.closeMark(markType)\n    },\n  },\n  toMarkdown: {\n    match: (mark) => mark.type.name === 'emphasis',\n    runner: (state, mark) => {\n      state.withMark(mark, 'emphasis', undefined, {\n        marker: mark.attrs.marker,\n      })\n    },\n  },\n}))\n\nwithMeta(emphasisSchema.mark, {\n  displayName: 'MarkSchema<emphasis>',\n  group: 'Emphasis',\n})\n\nwithMeta(emphasisSchema.ctx, {\n  displayName: 'MarkSchemaCtx<emphasis>',\n  group: 'Emphasis',\n})\n\n/// A command to toggle the emphasis mark.\nexport const toggleEmphasisCommand = $command('ToggleEmphasis', (ctx) => () => {\n  return toggleMark(emphasisSchema.type(ctx))\n})\n\nwithMeta(toggleEmphasisCommand, {\n  displayName: 'Command<toggleEmphasisCommand>',\n  group: 'Emphasis',\n})\n\n/// Input rule for use `*` to create emphasis mark.\nexport const emphasisStarInputRule = $inputRule((ctx) => {\n  return markRule(/(?:^|[^*])\\*([^*]+)\\*$/, emphasisSchema.type(ctx), {\n    getAttr: () => ({\n      marker: '*',\n    }),\n    updateCaptured: ({ fullMatch, start }) =>\n      !fullMatch.startsWith('*')\n        ? { fullMatch: fullMatch.slice(1), start: start + 1 }\n        : {},\n  })\n})\n\nwithMeta(emphasisStarInputRule, {\n  displayName: 'InputRule<emphasis>|Star',\n  group: 'Emphasis',\n})\n\n/// Input rule for use `_` to create emphasis mark.\nexport const emphasisUnderscoreInputRule = $inputRule((ctx) => {\n  return markRule(/(?:^|[^_])_([^_]+)_$/, emphasisSchema.type(ctx), {\n    getAttr: () => ({\n      marker: '_',\n    }),\n    updateCaptured: ({ fullMatch, start }) =>\n      !fullMatch.startsWith('_')\n        ? { fullMatch: fullMatch.slice(1), start: start + 1 }\n        : {},\n  })\n})\n\nwithMeta(emphasisUnderscoreInputRule, {\n  displayName: 'InputRule<emphasis>|Underscore',\n  group: 'Emphasis',\n})\n\n/// Keymap for the emphasis mark.\n/// - `Mod-i` - Toggle the emphasis mark.\nexport const emphasisKeymap = $useKeymap('emphasisKeymap', {\n  ToggleEmphasis: {\n    shortcuts: 'Mod-i',\n    command: (ctx) => {\n      const commands = ctx.get(commandsCtx)\n      return () => commands.call(toggleEmphasisCommand.key)\n    },\n  },\n})\n\nwithMeta(emphasisKeymap.ctx, {\n  displayName: 'KeymapCtx<emphasis>',\n  group: 'Emphasis',\n})\n\nwithMeta(emphasisKeymap.shortcuts, {\n  displayName: 'Keymap<emphasis>',\n  group: 'Emphasis',\n})\n", "import { commandsCtx, remarkStringifyOptionsCtx } from '@milkdown/core'\nimport { markRule } from '@milkdown/prose'\nimport { toggleMark } from '@milkdown/prose/commands'\nimport {\n  $command,\n  $inputRule,\n  $markAttr,\n  $markSchema,\n  $useKeymap,\n} from '@milkdown/utils'\n\nimport { withMeta } from '../__internal__'\n\n/// HTML attributes for the strong mark.\nexport const strongAttr = $markAttr('strong')\n\nwithMeta(strongAttr, {\n  displayName: 'Attr<strong>',\n  group: 'Strong',\n})\n\n/// Strong mark schema.\nexport const strongSchema = $markSchema('strong', (ctx) => ({\n  attrs: {\n    marker: {\n      default: ctx.get(remarkStringifyOptionsCtx).strong || '*',\n      validate: 'string',\n    },\n  },\n  parseDOM: [\n    // This works around a Google Docs misbehavior where\n    // pasted content will be inexplicably wrapped in `<b>`\n    // tags with a font-weight normal.\n    {\n      tag: 'b',\n      getAttrs: (node: HTMLElement) =>\n        node.style.fontWeight != 'normal' && null,\n    },\n    { tag: 'strong' },\n    { style: 'font-style', getAttrs: (value) => (value === 'bold') as false },\n    { style: 'font-weight=400', clearMark: (m) => m.type.name == 'strong' },\n    {\n      style: 'font-weight',\n      getAttrs: (value: string) =>\n        /^(bold(er)?|[5-9]\\d{2,})$/.test(value) && null,\n    },\n  ],\n  toDOM: (mark) => ['strong', ctx.get(strongAttr.key)(mark)],\n  parseMarkdown: {\n    match: (node) => node.type === 'strong',\n    runner: (state, node, markType) => {\n      state.openMark(markType, { marker: node.marker })\n      state.next(node.children)\n      state.closeMark(markType)\n    },\n  },\n  toMarkdown: {\n    match: (mark) => mark.type.name === 'strong',\n    runner: (state, mark) => {\n      state.withMark(mark, 'strong', undefined, {\n        marker: mark.attrs.marker,\n      })\n    },\n  },\n}))\n\nwithMeta(strongSchema.mark, {\n  displayName: 'MarkSchema<strong>',\n  group: 'Strong',\n})\n\nwithMeta(strongSchema.ctx, {\n  displayName: 'MarkSchemaCtx<strong>',\n  group: 'Strong',\n})\n\n/// A command to toggle the strong mark.\nexport const toggleStrongCommand = $command('ToggleStrong', (ctx) => () => {\n  return toggleMark(strongSchema.type(ctx))\n})\n\nwithMeta(toggleStrongCommand, {\n  displayName: 'Command<toggleStrongCommand>',\n  group: 'Strong',\n})\n\n/// A input rule that will capture the strong mark.\nexport const strongInputRule = $inputRule((ctx) => {\n  return markRule(/(?:\\*\\*|__)([^*_]+)(?:\\*\\*|__)$/, strongSchema.type(ctx), {\n    getAttr: (match) => {\n      return {\n        marker: match[0].startsWith('*') ? '*' : '_',\n      }\n    },\n  })\n})\n\nwithMeta(strongInputRule, {\n  displayName: 'InputRule<strong>',\n  group: 'Strong',\n})\n\n/// Keymap for the strong mark.\n/// - `Mod-b` - Toggle the strong mark.\nexport const strongKeymap = $useKeymap('strongKeymap', {\n  ToggleBold: {\n    shortcuts: ['Mod-b'],\n    command: (ctx) => {\n      const commands = ctx.get(commandsCtx)\n      return () => commands.call(toggleStrongCommand.key)\n    },\n  },\n})\n\nwithMeta(strongKeymap.ctx, {\n  displayName: 'KeymapCtx<strong>',\n  group: 'Strong',\n})\n\nwithMeta(strongKeymap.shortcuts, {\n  displayName: 'Keymap<strong>',\n  group: 'Strong',\n})\n", "import type { MarkType } from '@milkdown/prose/model'\n\nimport { commandsCtx } from '@milkdown/core'\nimport { markRule } from '@milkdown/prose'\nimport {\n  $command,\n  $inputRule,\n  $markAttr,\n  $markSchema,\n  $useKeymap,\n} from '@milkdown/utils'\n\nimport { withMeta } from '../__internal__'\n\n/// HTML attributes for the inlineCode mark.\nexport const inlineCodeAttr = $markAttr('inlineCode')\n\nwithMeta(inlineCodeAttr, {\n  displayName: 'Attr<inlineCode>',\n  group: 'InlineCode',\n})\n\n/// InlineCode mark schema.\nexport const inlineCodeSchema = $markSchema('inlineCode', (ctx) => ({\n  priority: 100,\n  code: true,\n  parseDOM: [{ tag: 'code' }],\n  toDOM: (mark) => ['code', ctx.get(inlineCodeAttr.key)(mark)],\n  parseMarkdown: {\n    match: (node) => node.type === 'inlineCode',\n    runner: (state, node, markType) => {\n      state.openMark(markType)\n      state.addText(node.value as string)\n      state.closeMark(markType)\n    },\n  },\n  toMarkdown: {\n    match: (mark) => mark.type.name === 'inlineCode',\n    runner: (state, mark, node) => {\n      state.withMark(mark, 'inlineCode', node.text || '')\n    },\n  },\n}))\n\nwithMeta(inlineCodeSchema.mark, {\n  displayName: 'MarkSchema<inlineCode>',\n  group: 'InlineCode',\n})\n\nwithMeta(inlineCodeSchema.ctx, {\n  displayName: 'MarkSchemaCtx<inlineCode>',\n  group: 'InlineCode',\n})\n\n/// A command to toggle the inlineCode mark.\nexport const toggleInlineCodeCommand = $command(\n  'ToggleInlineCode',\n  (ctx) => () => (state, dispatch) => {\n    const { selection, tr } = state\n    if (selection.empty) return false\n    const { from, to } = selection\n\n    const has = state.doc.rangeHasMark(from, to, inlineCodeSchema.type(ctx))\n    // remove exists inlineCode mark if have\n    if (has) {\n      dispatch?.(tr.removeMark(from, to, inlineCodeSchema.type(ctx)))\n      return true\n    }\n\n    const restMarksName = Object.keys(state.schema.marks).filter(\n      (x) => x !== inlineCodeSchema.type.name\n    )\n\n    // remove other marks\n    restMarksName\n      .map((name) => state.schema.marks[name] as MarkType)\n      .forEach((t) => {\n        tr.removeMark(from, to, t)\n      })\n\n    // add inlineCode mark\n    dispatch?.(tr.addMark(from, to, inlineCodeSchema.type(ctx).create()))\n    return true\n  }\n)\n\nwithMeta(toggleInlineCodeCommand, {\n  displayName: 'Command<toggleInlineCodeCommand>',\n  group: 'InlineCode',\n})\n\n/// Input rule for create inlineCode mark.\nexport const inlineCodeInputRule = $inputRule((ctx) => {\n  return markRule(/(?:`)([^`]+)(?:`)$/, inlineCodeSchema.type(ctx))\n})\n\nwithMeta(inlineCodeInputRule, {\n  displayName: 'InputRule<inlineCodeInputRule>',\n  group: 'InlineCode',\n})\n\n/// Keymap for the inlineCode mark.\n/// - `Mod-e` - Toggle the inlineCode mark.\nexport const inlineCodeKeymap = $useKeymap('inlineCodeKeymap', {\n  ToggleInlineCode: {\n    shortcuts: 'Mod-e',\n    command: (ctx) => {\n      const commands = ctx.get(commandsCtx)\n      return () => commands.call(toggleInlineCodeCommand.key)\n    },\n  },\n})\n\nwithMeta(inlineCodeKeymap.ctx, {\n  displayName: 'KeymapCtx<inlineCode>',\n  group: 'InlineCode',\n})\n\nwithMeta(inlineCodeKeymap.shortcuts, {\n  displayName: 'Keymap<inlineCode>',\n  group: 'InlineCode',\n})\n", "import type { Node as ProseNode } from '@milkdown/prose/model'\n\nimport { expectDomTypeError } from '@milkdown/exception'\nimport { toggleMark } from '@milkdown/prose/commands'\nimport { TextSelection } from '@milkdown/prose/state'\nimport { $command, $markAttr, $markSchema } from '@milkdown/utils'\n\nimport { withMeta } from '../__internal__'\n\n/// HTML attributes for the link mark.\nexport const linkAttr = $markAttr('link')\n\nwithMeta(linkAttr, {\n  displayName: 'Attr<link>',\n  group: 'Link',\n})\n\n/// Link mark schema.\nexport const linkSchema = $markSchema('link', (ctx) => ({\n  attrs: {\n    href: { validate: 'string' },\n    title: { default: null, validate: 'string|null' },\n  },\n  parseDOM: [\n    {\n      tag: 'a[href]',\n      getAttrs: (dom) => {\n        if (!(dom instanceof HTMLElement)) throw expectDomTypeError(dom)\n\n        return {\n          href: dom.getAttribute('href'),\n          title: dom.getAttribute('title'),\n        }\n      },\n    },\n  ],\n  toDOM: (mark) => ['a', { ...ctx.get(linkAttr.key)(mark), ...mark.attrs }],\n  parseMarkdown: {\n    match: (node) => node.type === 'link',\n    runner: (state, node, markType) => {\n      const url = node.url as string\n      const title = node.title as string\n      state.openMark(markType, { href: url, title })\n      state.next(node.children)\n      state.closeMark(markType)\n    },\n  },\n  toMarkdown: {\n    match: (mark) => mark.type.name === 'link',\n    runner: (state, mark) => {\n      state.withMark(mark, 'link', undefined, {\n        title: mark.attrs.title,\n        url: mark.attrs.href,\n      })\n    },\n  },\n}))\n\nwithMeta(linkSchema.mark, {\n  displayName: 'MarkSchema<link>',\n  group: 'Link',\n})\n\n/// @internal\nexport interface UpdateLinkCommandPayload {\n  href?: string\n  title?: string\n}\n/// A command to toggle the link mark.\n/// You can pass the `href` and `title` to the link.\nexport const toggleLinkCommand = $command(\n  'ToggleLink',\n  (ctx) =>\n    (payload: UpdateLinkCommandPayload = {}) =>\n      toggleMark(linkSchema.type(ctx), payload)\n)\n\nwithMeta(toggleLinkCommand, {\n  displayName: 'Command<toggleLinkCommand>',\n  group: 'Link',\n})\n\n/// A command to update the link mark.\n/// You can pass the `href` and `title` to update the link.\nexport const updateLinkCommand = $command(\n  'UpdateLink',\n  (ctx) =>\n    (payload: UpdateLinkCommandPayload = {}) =>\n    (state, dispatch) => {\n      if (!dispatch) return false\n\n      let node: ProseNode | undefined\n      let pos = -1\n      const { selection } = state\n      const { from, to } = selection\n      state.doc.nodesBetween(from, from === to ? to + 1 : to, (n, p) => {\n        if (linkSchema.type(ctx).isInSet(n.marks)) {\n          node = n\n          pos = p\n          return false\n        }\n\n        return undefined\n      })\n\n      if (!node) return false\n\n      const mark = node.marks.find(({ type }) => type === linkSchema.type(ctx))\n      if (!mark) return false\n\n      const start = pos\n      const end = pos + node.nodeSize\n      const { tr } = state\n      const linkMark = linkSchema\n        .type(ctx)\n        .create({ ...mark.attrs, ...payload })\n      if (!linkMark) return false\n\n      dispatch(\n        tr\n          .removeMark(start, end, mark)\n          .addMark(start, end, linkMark)\n          .setSelection(new TextSelection(tr.selection.$anchor))\n          .scrollIntoView()\n      )\n\n      return true\n    }\n)\n\nwithMeta(updateLinkCommand, {\n  displayName: 'Command<updateLinkCommand>',\n  group: 'Link',\n})\n", "import { $node } from '@milkdown/utils'\n\nimport { withMeta } from '../__internal__'\n\n/// The top-level document node.\nexport const docSchema = $node('doc', () => ({\n  content: 'block+',\n  parseMarkdown: {\n    match: ({ type }) => type === 'root',\n    runner: (state, node, type) => {\n      state.injectRoot(node, type)\n    },\n  },\n  toMarkdown: {\n    match: (node) => node.type.name === 'doc',\n    runner: (state, node) => {\n      state.openNode('root')\n      state.next(node.content)\n    },\n  },\n}))\n\nwithMeta(docSchema, {\n  displayName: 'NodeSchema<doc>',\n  group: 'Doc',\n})\n", "import type { Node } from '@milkdown/transformer'\n\nimport { $remark } from '@milkdown/utils'\nimport { visitParents } from 'unist-util-visit-parents'\n\nimport { withMeta } from '../__internal__'\n\nfunction visitEmptyLine(ast: Node) {\n  return visitParents(\n    ast,\n    (node: Node) =>\n      node.type === 'html' &&\n      ['<br />', '<br>', '<br >', '<br/>'].includes(\n        (node as Node & { value: string }).value?.trim()\n      ),\n    (node: Node, parents: Node[]) => {\n      if (!parents.length) return\n      const parent = parents[parents.length - 1] as\n        | (Node & { children: Node[] })\n        | undefined\n      if (!parent) return\n      const index = parent.children.indexOf(node)\n      if (index === -1) return\n\n      parent.children.splice(index, 1)\n    },\n    true\n  )\n}\n\n/// @internal\n/// This plugin is used to preserve the empty line.\n/// Markdown will fold the empty line into the previous line by default.\n/// This plugin will preserve the empty line by converting `<br />` to `line-break`.\n/// This plugin should be used with `linebreakSchema` to work.\nexport const remarkPreserveEmptyLinePlugin = $remark(\n  'remark-preserve-empty-line',\n  () => () => visitEmptyLine\n)\n\nwithMeta(remarkPreserveEmptyLinePlugin.plugin, {\n  displayName: 'Remark<remarkPreserveEmptyLine>',\n  group: 'Remark',\n})\n\nwithMeta(remarkPreserveEmptyLinePlugin.options, {\n  displayName: 'RemarkConfig<remarkPreserveEmptyLine>',\n  group: 'Remark',\n})\n", "import type { Ctx } from '@milkdown/ctx'\n\nimport { commandsCtx, editorViewCtx } from '@milkdown/core'\nimport { setBlockType } from '@milkdown/prose/commands'\nimport { $command, $nodeAttr, $nodeSchema, $useKeymap } from '@milkdown/utils'\n\nimport { serializeText, withMeta } from '../__internal__'\nimport { remarkPreserveEmptyLinePlugin } from '../plugin/remark-preserve-empty-line'\n\n/// HTML attributes for paragraph node.\nexport const paragraphAttr = $nodeAttr('paragraph')\n\nwithMeta(paragraphAttr, {\n  displayName: 'Attr<paragraph>',\n  group: 'Paragraph',\n})\n\n/// Schema for paragraph node.\nexport const paragraphSchema = $nodeSchema('paragraph', (ctx) => ({\n  content: 'inline*',\n  group: 'block',\n  parseDOM: [{ tag: 'p' }],\n  toDOM: (node) => ['p', ctx.get(paragraphAttr.key)(node), 0],\n  parseMarkdown: {\n    match: (node) => node.type === 'paragraph',\n    runner: (state, node, type) => {\n      state.openNode(type)\n      if (node.children) state.next(node.children)\n      else state.addText((node.value || '') as string)\n\n      state.closeNode()\n    },\n  },\n  toMarkdown: {\n    match: (node) => node.type.name === 'paragraph',\n    runner: (state, node) => {\n      const view = ctx.get(editorViewCtx)\n      const lastNode = view.state?.doc.lastChild\n\n      state.openNode('paragraph')\n      if (\n        (!node.content || node.content.size === 0) &&\n        node !== lastNode &&\n        shouldPreserveEmptyLine(ctx)\n      ) {\n        state.addNode('html', undefined, '<br />')\n      } else {\n        serializeText(state, node)\n      }\n      state.closeNode()\n    },\n  },\n}))\n\nfunction shouldPreserveEmptyLine(ctx: Ctx) {\n  let shouldPreserveEmptyLine = false\n  try {\n    ctx.get(remarkPreserveEmptyLinePlugin.id)\n    shouldPreserveEmptyLine = true\n  } catch {\n    shouldPreserveEmptyLine = false\n  }\n  return shouldPreserveEmptyLine\n}\n\nwithMeta(paragraphSchema.node, {\n  displayName: 'NodeSchema<paragraph>',\n  group: 'Paragraph',\n})\nwithMeta(paragraphSchema.ctx, {\n  displayName: 'NodeSchemaCtx<paragraph>',\n  group: 'Paragraph',\n})\n\n/// This command can turn the selected block into paragraph.\nexport const turnIntoTextCommand = $command(\n  'TurnIntoText',\n  (ctx) => () => setBlockType(paragraphSchema.type(ctx))\n)\n\nwithMeta(turnIntoTextCommand, {\n  displayName: 'Command<turnIntoTextCommand>',\n  group: 'Paragraph',\n})\n\n/// Keymap for paragraph node.\n/// - `<Mod-Alt-0>`: Turn the selected block into paragraph.\nexport const paragraphKeymap = $useKeymap('paragraphKeymap', {\n  TurnIntoText: {\n    shortcuts: 'Mod-Alt-0',\n    command: (ctx) => {\n      const commands = ctx.get(commandsCtx)\n      return () => commands.call(turnIntoTextCommand.key)\n    },\n  },\n})\n\nwithMeta(paragraphKeymap.ctx, {\n  displayName: 'KeymapCtx<paragraph>',\n  group: 'Paragraph',\n})\n\nwithMeta(paragraphKeymap.shortcuts, {\n  displayName: 'Keymap<paragraph>',\n  group: 'Paragraph',\n})\n", "import type { Node } from '@milkdown/prose/model'\n\nimport { commandsCtx, editorViewCtx } from '@milkdown/core'\nimport { expectDomTypeError } from '@milkdown/exception'\nimport { setBlockType } from '@milkdown/prose/commands'\nimport { textblockTypeInputRule } from '@milkdown/prose/inputrules'\nimport {\n  $command,\n  $ctx,\n  $inputRule,\n  $nodeAttr,\n  $nodeSchema,\n  $useKeymap,\n} from '@milkdown/utils'\n\nimport { serializeText, withMeta } from '../__internal__'\nimport { paragraphSchema } from './paragraph'\n\nconst headingIndex = Array(6)\n  .fill(0)\n  .map((_, i) => i + 1)\n\nfunction defaultHeadingIdGenerator(node: Node) {\n  return node.textContent\n    .toLowerCase()\n    .trim()\n    .replace(/[^\\w\\s-]/g, '')\n    .replace(/\\s+/g, '-')\n}\n\n/// This is a slice contains a function to generate heading id.\n/// You can configure it to generate id in your own way.\nexport const headingIdGenerator = $ctx(\n  defaultHeadingIdGenerator,\n  'headingIdGenerator'\n)\n\nwithMeta(headingIdGenerator, {\n  displayName: 'Ctx<HeadingIdGenerator>',\n  group: 'Heading',\n})\n\n/// HTML attributes for heading node.\nexport const headingAttr = $nodeAttr('heading')\n\nwithMeta(headingAttr, {\n  displayName: 'Attr<heading>',\n  group: 'Heading',\n})\n\n/// Schema for heading node.\nexport const headingSchema = $nodeSchema('heading', (ctx) => {\n  const getId = ctx.get(headingIdGenerator.key)\n  return {\n    content: 'inline*',\n    group: 'block',\n    defining: true,\n    attrs: {\n      id: {\n        default: '',\n        validate: 'string',\n      },\n      level: {\n        default: 1,\n        validate: 'number',\n      },\n    },\n    parseDOM: headingIndex.map((x) => ({\n      tag: `h${x}`,\n      getAttrs: (node) => {\n        if (!(node instanceof HTMLElement)) throw expectDomTypeError(node)\n\n        return { level: x, id: node.id }\n      },\n    })),\n    toDOM: (node) => {\n      return [\n        `h${node.attrs.level}`,\n        {\n          ...ctx.get(headingAttr.key)(node),\n          id: node.attrs.id || getId(node),\n        },\n        0,\n      ]\n    },\n    parseMarkdown: {\n      match: ({ type }) => type === 'heading',\n      runner: (state, node, type) => {\n        const depth = node.depth as number\n        state.openNode(type, { level: depth })\n        state.next(node.children)\n        state.closeNode()\n      },\n    },\n    toMarkdown: {\n      match: (node) => node.type.name === 'heading',\n      runner: (state, node) => {\n        state.openNode('heading', undefined, { depth: node.attrs.level })\n        serializeText(state, node)\n        state.closeNode()\n      },\n    },\n  }\n})\n\nwithMeta(headingSchema.node, {\n  displayName: 'NodeSchema<heading>',\n  group: 'Heading',\n})\n\nwithMeta(headingSchema.ctx, {\n  displayName: 'NodeSchemaCtx<heading>',\n  group: 'Heading',\n})\n\n/// This input rule can turn the selected block into heading.\n/// You can input numbers of `#` and a `space` to create heading.\nexport const wrapInHeadingInputRule = $inputRule((ctx) => {\n  return textblockTypeInputRule(\n    /^(?<hashes>#+)\\s$/,\n    headingSchema.type(ctx),\n    (match) => {\n      const x = match.groups?.hashes?.length || 0\n\n      const view = ctx.get(editorViewCtx)\n      const { $from } = view.state.selection\n      const node = $from.node()\n      if (node.type.name === 'heading') {\n        let level = Number(node.attrs.level) + Number(x)\n        if (level > 6) level = 6\n\n        return { level }\n      }\n      return { level: x }\n    }\n  )\n})\n\nwithMeta(wrapInHeadingInputRule, {\n  displayName: 'InputRule<wrapInHeadingInputRule>',\n  group: 'Heading',\n})\n\n/// This command can turn the selected block into heading.\n/// You can pass the level of heading to this command.\n/// By default, the level is 1, which means it will create a `h1` element.\nexport const wrapInHeadingCommand = $command('WrapInHeading', (ctx) => {\n  return (level?: number) => {\n    level ??= 1\n\n    if (level < 1) return setBlockType(paragraphSchema.type(ctx))\n\n    return setBlockType(headingSchema.type(ctx), { level })\n  }\n})\n\nwithMeta(wrapInHeadingCommand, {\n  displayName: 'Command<wrapInHeadingCommand>',\n  group: 'Heading',\n})\n\n/// This command can downgrade the selected heading.\n/// For example, if you have a `h2` element, and you call this command, you will get a `h1` element.\n/// If the element is already a `h1` element, it will turn it into a `p` element.\nexport const downgradeHeadingCommand = $command(\n  'DowngradeHeading',\n  (ctx) => () => (state, dispatch, view) => {\n    const { $from } = state.selection\n    const node = $from.node()\n    if (\n      node.type !== headingSchema.type(ctx) ||\n      !state.selection.empty ||\n      $from.parentOffset !== 0\n    )\n      return false\n\n    const level = node.attrs.level - 1\n    if (!level)\n      return setBlockType(paragraphSchema.type(ctx))(state, dispatch, view)\n\n    dispatch?.(\n      state.tr.setNodeMarkup(state.selection.$from.before(), undefined, {\n        ...node.attrs,\n        level,\n      })\n    )\n    return true\n  }\n)\n\nwithMeta(downgradeHeadingCommand, {\n  displayName: 'Command<downgradeHeadingCommand>',\n  group: 'Heading',\n})\n\n/// Keymap for heading node.\n/// - `<Mod-Alt-{1-6}>`: Turn the selected block into `h{1-6}` element.\n/// - `<Delete>/<Backspace>`: Downgrade the selected heading.\nexport const headingKeymap = $useKeymap('headingKeymap', {\n  TurnIntoH1: {\n    shortcuts: 'Mod-Alt-1',\n    command: (ctx) => {\n      const commands = ctx.get(commandsCtx)\n      return () => commands.call(wrapInHeadingCommand.key, 1)\n    },\n  },\n  TurnIntoH2: {\n    shortcuts: 'Mod-Alt-2',\n    command: (ctx) => {\n      const commands = ctx.get(commandsCtx)\n      return () => commands.call(wrapInHeadingCommand.key, 2)\n    },\n  },\n  TurnIntoH3: {\n    shortcuts: 'Mod-Alt-3',\n    command: (ctx) => {\n      const commands = ctx.get(commandsCtx)\n      return () => commands.call(wrapInHeadingCommand.key, 3)\n    },\n  },\n  TurnIntoH4: {\n    shortcuts: 'Mod-Alt-4',\n    command: (ctx) => {\n      const commands = ctx.get(commandsCtx)\n      return () => commands.call(wrapInHeadingCommand.key, 4)\n    },\n  },\n  TurnIntoH5: {\n    shortcuts: 'Mod-Alt-5',\n    command: (ctx) => {\n      const commands = ctx.get(commandsCtx)\n      return () => commands.call(wrapInHeadingCommand.key, 5)\n    },\n  },\n  TurnIntoH6: {\n    shortcuts: 'Mod-Alt-6',\n    command: (ctx) => {\n      const commands = ctx.get(commandsCtx)\n      return () => commands.call(wrapInHeadingCommand.key, 6)\n    },\n  },\n  DowngradeHeading: {\n    shortcuts: ['Delete', 'Backspace'],\n    command: (ctx) => {\n      const commands = ctx.get(commandsCtx)\n      return () => commands.call(downgradeHeadingCommand.key)\n    },\n  },\n})\n\nwithMeta(headingKeymap.ctx, {\n  displayName: 'KeymapCtx<heading>',\n  group: 'Heading',\n})\n\nwithMeta(headingKeymap.shortcuts, {\n  displayName: 'Keymap<heading>',\n  group: 'Heading',\n})\n", "import type { $NodeSchema } from '@milkdown/utils'\n\nimport { commandsCtx } from '@milkdown/core'\nimport { wrapIn } from '@milkdown/prose/commands'\nimport { wrappingInputRule } from '@milkdown/prose/inputrules'\nimport {\n  $command,\n  $inputRule,\n  $nodeAttr,\n  $nodeSchema,\n  $useKeymap,\n} from '@milkdown/utils'\n\nimport { withMeta } from '../__internal__'\n\n/// HTML attributes for blockquote node.\nexport const blockquoteAttr = $nodeAttr('blockquote')\n\nwithMeta(blockquoteAttr, {\n  displayName: 'Attr<blockquote>',\n  group: 'Blockquote',\n})\n\n/// Schema for blockquote node.\nexport const blockquoteSchema: $NodeSchema<'blockquote'> = $nodeSchema(\n  'blockquote',\n  (ctx) => ({\n    content: 'block+',\n    group: 'block',\n    defining: true,\n    parseDOM: [{ tag: 'blockquote' }],\n    toDOM: (node) => ['blockquote', ctx.get(blockquoteAttr.key)(node), 0],\n    parseMarkdown: {\n      match: ({ type }) => type === 'blockquote',\n      runner: (state, node, type) => {\n        state.openNode(type).next(node.children).closeNode()\n      },\n    },\n    toMarkdown: {\n      match: (node) => node.type.name === 'blockquote',\n      runner: (state, node) => {\n        state.openNode('blockquote').next(node.content).closeNode()\n      },\n    },\n  })\n)\n\nwithMeta(blockquoteSchema.node, {\n  displayName: 'NodeSchema<blockquote>',\n  group: 'Blockquote',\n})\n\nwithMeta(blockquoteSchema.ctx, {\n  displayName: 'NodeSchemaCtx<blockquote>',\n  group: 'Blockquote',\n})\n\n/// This input rule will convert a line that starts with `> ` into a blockquote.\n/// You can type `> ` at the start of a line to create a blockquote.\nexport const wrapInBlockquoteInputRule = $inputRule((ctx) =>\n  wrappingInputRule(/^\\s*>\\s$/, blockquoteSchema.type(ctx))\n)\n\nwithMeta(wrapInBlockquoteInputRule, {\n  displayName: 'InputRule<wrapInBlockquoteInputRule>',\n  group: 'Blockquote',\n})\n\n/// This command will wrap the current selection in a blockquote.\nexport const wrapInBlockquoteCommand = $command(\n  'WrapInBlockquote',\n  (ctx) => () => wrapIn(blockquoteSchema.type(ctx))\n)\n\nwithMeta(wrapInBlockquoteCommand, {\n  displayName: 'Command<wrapInBlockquoteCommand>',\n  group: 'Blockquote',\n})\n\n/// Keymap for blockquote.\n/// - `Mod-Shift-b`: Wrap selection in blockquote.\nexport const blockquoteKeymap = $useKeymap('blockquoteKeymap', {\n  WrapInBlockquote: {\n    shortcuts: 'Mod-Shift-b',\n    command: (ctx) => {\n      const commands = ctx.get(commandsCtx)\n      return () => commands.call(wrapInBlockquoteCommand.key)\n    },\n  },\n})\n\nwithMeta(blockquoteKeymap.ctx, {\n  displayName: 'KeymapCtx<blockquote>',\n  group: 'Blockquote',\n})\n\nwithMeta(blockquoteKeymap.shortcuts, {\n  displayName: 'Keymap<blockquote>',\n  group: 'Blockquote',\n})\n", "import { commandsCtx } from '@milkdown/core'\nimport { expectDomTypeError } from '@milkdown/exception'\nimport { setBlockType } from '@milkdown/prose/commands'\nimport { textblockTypeInputRule } from '@milkdown/prose/inputrules'\nimport {\n  $command,\n  $inputRule,\n  $nodeAttr,\n  $nodeSchema,\n  $useKeymap,\n} from '@milkdown/utils'\n\nimport { withMeta } from '../__internal__'\n\n/// HTML attributes for code block node.\nexport const codeBlockAttr = $nodeAttr('codeBlock', () => ({\n  pre: {},\n  code: {},\n}))\n\nwithMeta(codeBlockAttr, {\n  displayName: 'Attr<codeBlock>',\n  group: 'CodeBlock',\n})\n\n/// Schema for code block node.\nexport const codeBlockSchema = $nodeSchema('code_block', (ctx) => {\n  return {\n    content: 'text*',\n    group: 'block',\n    marks: '',\n    defining: true,\n    code: true,\n    attrs: {\n      language: {\n        default: '',\n        validate: 'string',\n      },\n    },\n    parseDOM: [\n      {\n        tag: 'pre',\n        preserveWhitespace: 'full',\n        getAttrs: (dom) => {\n          if (!(dom instanceof HTMLElement)) throw expectDomTypeError(dom)\n\n          return { language: dom.dataset.language }\n        },\n      },\n    ],\n    toDOM: (node) => {\n      const attr = ctx.get(codeBlockAttr.key)(node)\n      return [\n        'pre',\n        {\n          ...attr.pre,\n          'data-language': node.attrs.language,\n        },\n        ['code', attr.code, 0],\n      ]\n    },\n    parseMarkdown: {\n      match: ({ type }) => type === 'code',\n      runner: (state, node, type) => {\n        const language = node.lang as string\n        const value = node.value as string\n        state.openNode(type, { language })\n        if (value) state.addText(value)\n\n        state.closeNode()\n      },\n    },\n    toMarkdown: {\n      match: (node) => node.type.name === 'code_block',\n      runner: (state, node) => {\n        state.addNode('code', undefined, node.content.firstChild?.text || '', {\n          lang: node.attrs.language,\n        })\n      },\n    },\n  }\n})\n\nwithMeta(codeBlockSchema.node, {\n  displayName: 'NodeSchema<codeBlock>',\n  group: 'CodeBlock',\n})\n\nwithMeta(codeBlockSchema.ctx, {\n  displayName: 'NodeSchemaCtx<codeBlock>',\n  group: 'CodeBlock',\n})\n\n/// A input rule for creating code block.\n/// For example, ` ```javascript ` will create a code block with language javascript.\nexport const createCodeBlockInputRule = $inputRule((ctx) =>\n  textblockTypeInputRule(\n    /^```(?<language>[a-z]*)?[\\s\\n]$/,\n    codeBlockSchema.type(ctx),\n    (match) => ({\n      language: match.groups?.language ?? '',\n    })\n  )\n)\n\nwithMeta(createCodeBlockInputRule, {\n  displayName: 'InputRule<createCodeBlockInputRule>',\n  group: 'CodeBlock',\n})\n\n/// A command for creating code block.\n/// You can pass the language of the code block as the parameter.\nexport const createCodeBlockCommand = $command(\n  'CreateCodeBlock',\n  (ctx) =>\n    (language = '') =>\n      setBlockType(codeBlockSchema.type(ctx), { language })\n)\n\nwithMeta(createCodeBlockCommand, {\n  displayName: 'Command<createCodeBlockCommand>',\n  group: 'CodeBlock',\n})\n\n/// A command for updating the code block language of the target position.\nexport const updateCodeBlockLanguageCommand = $command(\n  'UpdateCodeBlockLanguage',\n  () =>\n    (\n      { pos, language }: { pos: number; language: string } = {\n        pos: -1,\n        language: '',\n      }\n    ) =>\n    (state, dispatch) => {\n      if (pos >= 0) {\n        dispatch?.(state.tr.setNodeAttribute(pos, 'language', language))\n        return true\n      }\n\n      return false\n    }\n)\n\nwithMeta(updateCodeBlockLanguageCommand, {\n  displayName: 'Command<updateCodeBlockLanguageCommand>',\n  group: 'CodeBlock',\n})\n\n/// Keymap for code block.\n/// - `Mod-Alt-c`: Create a code block.\nexport const codeBlockKeymap = $useKeymap('codeBlockKeymap', {\n  CreateCodeBlock: {\n    shortcuts: 'Mod-Alt-c',\n    command: (ctx) => {\n      const commands = ctx.get(commandsCtx)\n      return () => commands.call(createCodeBlockCommand.key)\n    },\n  },\n})\n\nwithMeta(codeBlockKeymap.ctx, {\n  displayName: 'KeymapCtx<codeBlock>',\n  group: 'CodeBlock',\n})\n\nwithMeta(codeBlockKeymap.shortcuts, {\n  displayName: 'Keymap<codeBlock>',\n  group: 'CodeBlock',\n})\n", "import { expectDomTypeError } from '@milkdown/exception'\nimport { findSelectedNodeOfType } from '@milkdown/prose'\nimport { InputRule } from '@milkdown/prose/inputrules'\nimport { $command, $inputRule, $nodeAttr, $nodeSchema } from '@milkdown/utils'\n\nimport { withMeta } from '../__internal__'\n\n/// HTML attributes for image node.\nexport const imageAttr = $nodeAttr('image')\n\nwithMeta(imageAttr, {\n  displayName: 'Attr<image>',\n  group: 'Image',\n})\n\n/// Schema for image node.\nexport const imageSchema = $nodeSchema('image', (ctx) => {\n  return {\n    inline: true,\n    group: 'inline',\n    selectable: true,\n    draggable: true,\n    marks: '',\n    atom: true,\n    defining: true,\n    isolating: true,\n    attrs: {\n      src: { default: '', validate: 'string' },\n      alt: { default: '', validate: 'string' },\n      title: { default: '', validate: 'string' },\n    },\n    parseDOM: [\n      {\n        tag: 'img[src]',\n        getAttrs: (dom) => {\n          if (!(dom instanceof HTMLElement)) throw expectDomTypeError(dom)\n\n          return {\n            src: dom.getAttribute('src') || '',\n            alt: dom.getAttribute('alt') || '',\n            title: dom.getAttribute('title') || dom.getAttribute('alt') || '',\n          }\n        },\n      },\n    ],\n    toDOM: (node) => {\n      return ['img', { ...ctx.get(imageAttr.key)(node), ...node.attrs }]\n    },\n    parseMarkdown: {\n      match: ({ type }) => type === 'image',\n      runner: (state, node, type) => {\n        const url = node.url as string\n        const alt = node.alt as string\n        const title = node.title as string\n        state.addNode(type, {\n          src: url,\n          alt,\n          title,\n        })\n      },\n    },\n    toMarkdown: {\n      match: (node) => node.type.name === 'image',\n      runner: (state, node) => {\n        state.addNode('image', undefined, undefined, {\n          title: node.attrs.title,\n          url: node.attrs.src,\n          alt: node.attrs.alt,\n        })\n      },\n    },\n  }\n})\n\nwithMeta(imageSchema.node, {\n  displayName: 'NodeSchema<image>',\n  group: 'Image',\n})\n\nwithMeta(imageSchema.ctx, {\n  displayName: 'NodeSchemaCtx<image>',\n  group: 'Image',\n})\n\n/// @internal\nexport interface UpdateImageCommandPayload {\n  src?: string\n  title?: string\n  alt?: string\n}\n\n/// This command will insert a image node.\n/// You can pass a payload to set `src`, `alt` and `title` for the image node.\nexport const insertImageCommand = $command(\n  'InsertImage',\n  (ctx) =>\n    (payload: UpdateImageCommandPayload = {}) =>\n    (state, dispatch) => {\n      if (!dispatch) return true\n\n      const { src = '', alt = '', title = '' } = payload\n\n      const node = imageSchema.type(ctx).create({ src, alt, title })\n      if (!node) return true\n\n      dispatch(state.tr.replaceSelectionWith(node).scrollIntoView())\n      return true\n    }\n)\n\nwithMeta(insertImageCommand, {\n  displayName: 'Command<insertImageCommand>',\n  group: 'Image',\n})\n\n/// This command will update the selected image node.\n/// You can pass a payload to update `src`, `alt` and `title` for the image node.\nexport const updateImageCommand = $command(\n  'UpdateImage',\n  (ctx) =>\n    (payload: UpdateImageCommandPayload = {}) =>\n    (state, dispatch) => {\n      const nodeWithPos = findSelectedNodeOfType(\n        state.selection,\n        imageSchema.type(ctx)\n      )\n      if (!nodeWithPos) return false\n\n      const { node, pos } = nodeWithPos\n\n      const newAttrs = { ...node.attrs }\n      const { src, alt, title } = payload\n      if (src !== undefined) newAttrs.src = src\n      if (alt !== undefined) newAttrs.alt = alt\n      if (title !== undefined) newAttrs.title = title\n\n      dispatch?.(\n        state.tr.setNodeMarkup(pos, undefined, newAttrs).scrollIntoView()\n      )\n      return true\n    }\n)\n\nwithMeta(updateImageCommand, {\n  displayName: 'Command<updateImageCommand>',\n  group: 'Image',\n})\n\n/// This input rule will insert a image node.\n/// You can input `![alt](src \"title\")` to insert a image node.\n/// The `title` is optional.\nexport const insertImageInputRule = $inputRule(\n  (ctx) =>\n    new InputRule(\n      /!\\[(?<alt>.*?)]\\((?<filename>.*?)\\s*(?=\"|\\))\"?(?<title>[^\"]+)?\"?\\)/,\n      (state, match, start, end) => {\n        const [matched, alt, src = '', title] = match\n        if (matched)\n          return state.tr.replaceWith(\n            start,\n            end,\n            imageSchema.type(ctx).create({ src, alt, title })\n          )\n\n        return null\n      }\n    )\n)\n\nwithMeta(insertImageInputRule, {\n  displayName: 'InputRule<insertImageInputRule>',\n  group: 'Image',\n})\n", "import { commandsCtx } from '@milkdown/core'\nimport { Selection, TextSelection } from '@milkdown/prose/state'\nimport { $command, $nodeAttr, $nodeSchema, $useKeymap } from '@milkdown/utils'\n\nimport { withMeta } from '../__internal__'\n\n/// HTML attributes for the hardbreak node.\n///\n/// Default value:\n/// - `data-is-inline` - Whether the hardbreak is inline.\nexport const hardbreakAttr = $nodeAttr('hardbreak', (node) => {\n  return {\n    'data-type': 'hardbreak',\n    'data-is-inline': node.attrs.isInline,\n  }\n})\n\nwithMeta(hardbreakAttr, {\n  displayName: 'Attr<hardbreak>',\n  group: 'Hardbreak',\n})\n\n/// Hardbreak node schema.\nexport const hardbreakSchema = $nodeSchema('hardbreak', (ctx) => ({\n  inline: true,\n  group: 'inline',\n  attrs: {\n    isInline: {\n      default: false,\n      validate: 'boolean',\n    },\n  },\n  selectable: false,\n  parseDOM: [\n    { tag: 'br' },\n    {\n      tag: 'span[data-type=\"hardbreak\"]',\n      getAttrs: () => ({ isInline: true }),\n    },\n  ],\n  toDOM: (node) =>\n    node.attrs.isInline\n      ? ['span', ctx.get(hardbreakAttr.key)(node), ' ']\n      : ['br', ctx.get(hardbreakAttr.key)(node)],\n  parseMarkdown: {\n    match: ({ type }) => type === 'break',\n    runner: (state, node, type) => {\n      state.addNode(type, {\n        isInline: Boolean(\n          (node.data as undefined | { isInline: boolean })?.isInline\n        ),\n      })\n    },\n  },\n  leafText: () => '\\n',\n  toMarkdown: {\n    match: (node) => node.type.name === 'hardbreak',\n    runner: (state, node) => {\n      if (node.attrs.isInline) state.addNode('text', undefined, '\\n')\n      else state.addNode('break')\n    },\n  },\n}))\n\nwithMeta(hardbreakSchema.node, {\n  displayName: 'NodeSchema<hardbreak>',\n  group: 'Hardbreak',\n})\n\nwithMeta(hardbreakSchema.ctx, {\n  displayName: 'NodeSchemaCtx<hardbreak>',\n  group: 'Hardbreak',\n})\n\n/// Command to insert a hardbreak.\nexport const insertHardbreakCommand = $command(\n  'InsertHardbreak',\n  (ctx) => () => (state, dispatch) => {\n    const { selection, tr } = state\n    if (!(selection instanceof TextSelection)) return false\n\n    if (selection.empty) {\n      // Transform two successive hardbreak into a new line\n      const node = selection.$from.node()\n      if (node.childCount > 0 && node.lastChild?.type.name === 'hardbreak') {\n        dispatch?.(\n          tr\n            .replaceRangeWith(\n              selection.to - 1,\n              selection.to,\n              state.schema.node('paragraph')\n            )\n            .setSelection(Selection.near(tr.doc.resolve(selection.to)))\n            .scrollIntoView()\n        )\n        return true\n      }\n    }\n    dispatch?.(\n      tr\n        .setMeta('hardbreak', true)\n        .replaceSelectionWith(hardbreakSchema.type(ctx).create())\n        .scrollIntoView()\n    )\n    return true\n  }\n)\n\nwithMeta(insertHardbreakCommand, {\n  displayName: 'Command<insertHardbreakCommand>',\n  group: 'Hardbreak',\n})\n\n/// Keymap for the hardbreak node.\n/// - `Shift-Enter` - Insert a hardbreak.\nexport const hardbreakKeymap = $useKeymap('hardbreakKeymap', {\n  InsertHardbreak: {\n    shortcuts: 'Shift-Enter',\n    command: (ctx) => {\n      const commands = ctx.get(commandsCtx)\n      return () => commands.call(insertHardbreakCommand.key)\n    },\n  },\n})\n\nwithMeta(hardbreakKeymap.ctx, {\n  displayName: 'KeymapCtx<hardbreak>',\n  group: 'Hardbreak',\n})\n\nwithMeta(hardbreakKeymap.shortcuts, {\n  displayName: 'Keymap<hardbreak>',\n  group: 'Hardbreak',\n})\n", "import { InputRule } from '@milkdown/prose/inputrules'\nimport { Selection } from '@milkdown/prose/state'\nimport { $command, $inputRule, $nodeAttr, $nodeSchema } from '@milkdown/utils'\n\nimport { withMeta } from '../__internal__'\nimport { paragraphSchema } from './paragraph'\n\n/// HTML attributes for the hr node.\nexport const hrAttr = $nodeAttr('hr')\n\nwithMeta(hrAttr, {\n  displayName: 'Attr<hr>',\n  group: 'Hr',\n})\n\n/// Hr node schema.\nexport const hrSchema = $nodeSchema('hr', (ctx) => ({\n  group: 'block',\n  parseDOM: [{ tag: 'hr' }],\n  toDOM: (node) => ['hr', ctx.get(hrAttr.key)(node)],\n  parseMarkdown: {\n    match: ({ type }) => type === 'thematicBreak',\n    runner: (state, _, type) => {\n      state.addNode(type)\n    },\n  },\n  toMarkdown: {\n    match: (node) => node.type.name === 'hr',\n    runner: (state) => {\n      state.addNode('thematicBreak')\n    },\n  },\n}))\n\nwithMeta(hrSchema.node, {\n  displayName: 'NodeSchema<hr>',\n  group: 'Hr',\n})\n\nwithMeta(hrSchema.ctx, {\n  displayName: 'NodeSchemaCtx<hr>',\n  group: 'Hr',\n})\n\n/// Input rule to insert a hr.\n/// For example, `---` will be converted to a hr.\nexport const insertHrInputRule = $inputRule(\n  (ctx) =>\n    new InputRule(/^(?:---|___\\s|\\*\\*\\*\\s)$/, (state, match, start, end) => {\n      const { tr } = state\n\n      if (match[0]) tr.replaceWith(start - 1, end, hrSchema.type(ctx).create())\n\n      return tr\n    })\n)\n\nwithMeta(insertHrInputRule, {\n  displayName: 'InputRule<insertHrInputRule>',\n  group: 'Hr',\n})\n\n/// Command to insert a hr.\nexport const insertHrCommand = $command(\n  'InsertHr',\n  (ctx) => () => (state, dispatch) => {\n    if (!dispatch) return true\n\n    const paragraph = paragraphSchema.node.type(ctx).create()\n    const { tr, selection } = state\n    const { from } = selection\n    const node = hrSchema.type(ctx).create()\n    if (!node) return true\n\n    const _tr = tr.replaceSelectionWith(node).insert(from, paragraph)\n    const sel = Selection.findFrom(_tr.doc.resolve(from), 1, true)\n    if (!sel) return true\n\n    dispatch(_tr.setSelection(sel).scrollIntoView())\n    return true\n  }\n)\n\nwithMeta(insertHrCommand, {\n  displayName: 'Command<insertHrCommand>',\n  group: 'Hr',\n})\n", "import { commandsCtx } from '@milkdown/core'\nimport { expectDomTypeError } from '@milkdown/exception'\nimport { wrapIn } from '@milkdown/prose/commands'\nimport { wrappingInputRule } from '@milkdown/prose/inputrules'\nimport {\n  $command,\n  $inputRule,\n  $nodeAttr,\n  $nodeSchema,\n  $useKeymap,\n} from '@milkdown/utils'\n\nimport { withMeta } from '../__internal__'\n\n/// HTML attributes for bullet list node.\nexport const bulletListAttr = $nodeAttr('bulletList')\n\nwithMeta(bulletListAttr, {\n  displayName: 'Attr<bulletList>',\n  group: 'BulletList',\n})\n\n/// Schema for bullet list node.\nexport const bulletListSchema = $nodeSchema('bullet_list', (ctx) => {\n  return {\n    content: 'listItem+',\n    group: 'block',\n    attrs: {\n      spread: {\n        default: false,\n        validate: 'boolean',\n      },\n    },\n    parseDOM: [\n      {\n        tag: 'ul',\n        getAttrs: (dom) => {\n          if (!(dom instanceof HTMLElement)) throw expectDomTypeError(dom)\n\n          return {\n            spread: dom.dataset.spread === 'true',\n          }\n        },\n      },\n    ],\n    toDOM: (node) => {\n      return [\n        'ul',\n        {\n          ...ctx.get(bulletListAttr.key)(node),\n          'data-spread': node.attrs.spread,\n        },\n        0,\n      ]\n    },\n    parseMarkdown: {\n      match: ({ type, ordered }) => type === 'list' && !ordered,\n      runner: (state, node, type) => {\n        const spread = node.spread != null ? `${node.spread}` : 'false'\n        state.openNode(type, { spread }).next(node.children).closeNode()\n      },\n    },\n    toMarkdown: {\n      match: (node) => node.type.name === 'bullet_list',\n      runner: (state, node) => {\n        state\n          .openNode('list', undefined, {\n            ordered: false,\n            spread: node.attrs.spread,\n          })\n          .next(node.content)\n          .closeNode()\n      },\n    },\n  }\n})\n\nwithMeta(bulletListSchema.node, {\n  displayName: 'NodeSchema<bulletList>',\n  group: 'BulletList',\n})\n\nwithMeta(bulletListSchema.ctx, {\n  displayName: 'NodeSchemaCtx<bulletList>',\n  group: 'BulletList',\n})\n\n/// Input rule for wrapping a block in bullet list node.\nexport const wrapInBulletListInputRule = $inputRule((ctx) =>\n  wrappingInputRule(/^\\s*([-+*])\\s$/, bulletListSchema.type(ctx))\n)\n\nwithMeta(wrapInBulletListInputRule, {\n  displayName: 'InputRule<wrapInBulletListInputRule>',\n  group: 'BulletList',\n})\n\n/// Command for creating bullet list node.\nexport const wrapInBulletListCommand = $command(\n  'WrapInBulletList',\n  (ctx) => () => wrapIn(bulletListSchema.type(ctx))\n)\n\nwithMeta(wrapInBulletListCommand, {\n  displayName: 'Command<wrapInBulletListCommand>',\n  group: 'BulletList',\n})\n\n/// Keymap for bullet list node.\n/// - `Mod-Alt-8`: Wrap a block in bullet list.\nexport const bulletListKeymap = $useKeymap('bulletListKeymap', {\n  WrapInBulletList: {\n    shortcuts: 'Mod-Alt-8',\n    command: (ctx) => {\n      const commands = ctx.get(commandsCtx)\n      return () => commands.call(wrapInBulletListCommand.key)\n    },\n  },\n})\n\nwithMeta(bulletListKeymap.ctx, {\n  displayName: 'KeymapCtx<bulletListKeymap>',\n  group: 'BulletList',\n})\n\nwithMeta(bulletListKeymap.shortcuts, {\n  displayName: 'Keymap<bulletListKeymap>',\n  group: 'BulletList',\n})\n", "import { commandsCtx } from '@milkdown/core'\nimport { expectDomTypeError } from '@milkdown/exception'\nimport { wrapIn } from '@milkdown/prose/commands'\nimport { wrappingInputRule } from '@milkdown/prose/inputrules'\nimport {\n  $command,\n  $inputRule,\n  $nodeAttr,\n  $nodeSchema,\n  $useKeymap,\n} from '@milkdown/utils'\n\nimport { withMeta } from '../__internal__'\n\n/// HTML attributes for ordered list node.\nexport const orderedListAttr = $nodeAttr('orderedList')\n\nwithMeta(orderedListAttr, {\n  displayName: 'Attr<orderedList>',\n  group: 'OrderedList',\n})\n\n/// Schema for ordered list node.\nexport const orderedListSchema = $nodeSchema('ordered_list', (ctx) => ({\n  content: 'listItem+',\n  group: 'block',\n  attrs: {\n    order: {\n      default: 1,\n      validate: 'number',\n    },\n    spread: {\n      default: false,\n      validate: 'boolean',\n    },\n  },\n  parseDOM: [\n    {\n      tag: 'ol',\n      getAttrs: (dom) => {\n        if (!(dom instanceof HTMLElement)) throw expectDomTypeError(dom)\n\n        return {\n          spread: dom.dataset.spread,\n          order: dom.hasAttribute('start')\n            ? Number(dom.getAttribute('start'))\n            : 1,\n        }\n      },\n    },\n  ],\n  toDOM: (node) => [\n    'ol',\n    {\n      ...ctx.get(orderedListAttr.key)(node),\n      ...(node.attrs.order === 1 ? {} : node.attrs.order),\n      'data-spread': node.attrs.spread,\n    },\n    0,\n  ],\n  parseMarkdown: {\n    match: ({ type, ordered }) => type === 'list' && !!ordered,\n    runner: (state, node, type) => {\n      const spread = node.spread != null ? `${node.spread}` : 'true'\n      state.openNode(type, { spread }).next(node.children).closeNode()\n    },\n  },\n  toMarkdown: {\n    match: (node) => node.type.name === 'ordered_list',\n    runner: (state, node) => {\n      state.openNode('list', undefined, {\n        ordered: true,\n        start: 1,\n        spread: node.attrs.spread === 'true',\n      })\n      state.next(node.content)\n      state.closeNode()\n    },\n  },\n}))\n\nwithMeta(orderedListSchema.node, {\n  displayName: 'NodeSchema<orderedList>',\n  group: 'OrderedList',\n})\n\nwithMeta(orderedListSchema.ctx, {\n  displayName: 'NodeSchemaCtx<orderedList>',\n  group: 'OrderedList',\n})\n\n/// Input rule for wrapping a block in ordered list node.\nexport const wrapInOrderedListInputRule = $inputRule((ctx) =>\n  wrappingInputRule(\n    /^\\s*(\\d+)\\.\\s$/,\n    orderedListSchema.type(ctx),\n    (match) => ({ order: Number(match[1]) }),\n    (match, node) => node.childCount + node.attrs.order === Number(match[1])\n  )\n)\n\nwithMeta(wrapInOrderedListInputRule, {\n  displayName: 'InputRule<wrapInOrderedListInputRule>',\n  group: 'OrderedList',\n})\n\n/// Command for wrapping a block in ordered list node.\nexport const wrapInOrderedListCommand = $command(\n  'WrapInOrderedList',\n  (ctx) => () => wrapIn(orderedListSchema.type(ctx))\n)\n\nwithMeta(wrapInOrderedListCommand, {\n  displayName: 'Command<wrapInOrderedListCommand>',\n  group: 'OrderedList',\n})\n\n/// Keymap for ordered list node.\n/// - `Mod-Alt-7`: Wrap a block in ordered list.\nexport const orderedListKeymap = $useKeymap('orderedListKeymap', {\n  WrapInOrderedList: {\n    shortcuts: 'Mod-Alt-7',\n    command: (ctx) => {\n      const commands = ctx.get(commandsCtx)\n      return () => commands.call(wrapInOrderedListCommand.key)\n    },\n  },\n})\n\nwithMeta(orderedListKeymap.ctx, {\n  displayName: 'KeymapCtx<orderedList>',\n  group: 'OrderedList',\n})\n\nwithMeta(orderedListKeymap.shortcuts, {\n  displayName: 'Keymap<orderedList>',\n  group: 'OrderedList',\n})\n", "import type { Ctx } from '@milkdown/ctx'\n\nimport { commandsCtx } from '@milkdown/core'\nimport { expectDomTypeError } from '@milkdown/exception'\nimport {\n  liftListItem,\n  sinkListItem,\n  splitListItem,\n} from '@milkdown/prose/schema-list'\nimport { type Command, TextSelection } from '@milkdown/prose/state'\nimport { $command, $nodeAttr, $nodeSchema, $useKeymap } from '@milkdown/utils'\n\nimport { withMeta } from '../__internal__'\n\n/// HTML attributes for list item node.\nexport const listItemAttr = $nodeAttr('listItem')\n\nwithMeta(listItemAttr, {\n  displayName: 'Attr<listItem>',\n  group: 'ListItem',\n})\n\n/// Schema for list item node.\nexport const listItemSchema = $nodeSchema('list_item', (ctx) => ({\n  group: 'listItem',\n  content: 'paragraph block*',\n  attrs: {\n    label: {\n      default: '•',\n      validate: 'string',\n    },\n    listType: {\n      default: 'bullet',\n      validate: 'string',\n    },\n    spread: {\n      default: true,\n      validate: 'boolean',\n    },\n  },\n  defining: true,\n  parseDOM: [\n    {\n      tag: 'li',\n      getAttrs: (dom) => {\n        if (!(dom instanceof HTMLElement)) throw expectDomTypeError(dom)\n\n        return {\n          label: dom.dataset.label,\n          listType: dom.dataset.listType,\n          spread: dom.dataset.spread === 'true',\n        }\n      },\n    },\n  ],\n  toDOM: (node) => [\n    'li',\n    {\n      ...ctx.get(listItemAttr.key)(node),\n      'data-label': node.attrs.label,\n      'data-list-type': node.attrs.listType,\n      'data-spread': node.attrs.spread,\n    },\n    0,\n  ],\n  parseMarkdown: {\n    match: ({ type }) => type === 'listItem',\n    runner: (state, node, type) => {\n      const label = node.label != null ? `${node.label}.` : '•'\n      const listType = node.label != null ? 'ordered' : 'bullet'\n      const spread = node.spread != null ? `${node.spread}` : 'true'\n      state.openNode(type, { label, listType, spread })\n      state.next(node.children)\n      state.closeNode()\n    },\n  },\n  toMarkdown: {\n    match: (node) => node.type.name === 'list_item',\n    runner: (state, node) => {\n      state.openNode('listItem', undefined, {\n        spread: node.attrs.spread,\n      })\n      state.next(node.content)\n      state.closeNode()\n    },\n  },\n}))\n\nwithMeta(listItemSchema.node, {\n  displayName: 'NodeSchema<listItem>',\n  group: 'ListItem',\n})\n\nwithMeta(listItemSchema.ctx, {\n  displayName: 'NodeSchemaCtx<listItem>',\n  group: 'ListItem',\n})\n\n/// The command to sink list item.\n///\n/// For example:\n/// ```md\n/// * List item 1\n/// * List item 2 <- cursor here\n/// ```\n/// Will get:\n/// ```md\n/// * List item 1\n///   * List item 2\n/// ```\nexport const sinkListItemCommand = $command(\n  'SinkListItem',\n  (ctx) => () => sinkListItem(listItemSchema.type(ctx))\n)\n\nwithMeta(sinkListItemCommand, {\n  displayName: 'Command<sinkListItemCommand>',\n  group: 'ListItem',\n})\n\n/// The command to lift list item.\n///\n/// For example:\n/// ```md\n/// * List item 1\n///   * List item 2 <- cursor here\n/// ```\n/// Will get:\n/// ```md\n/// * List item 1\n/// * List item 2\n/// ```\nexport const liftListItemCommand = $command(\n  'LiftListItem',\n  (ctx) => () => liftListItem(listItemSchema.type(ctx))\n)\n\nwithMeta(liftListItemCommand, {\n  displayName: 'Command<liftListItemCommand>',\n  group: 'ListItem',\n})\n\n/// The command to split a list item.\n///\n/// For example:\n/// ```md\n/// * List item 1\n/// * List item 2 <- cursor here\n/// ```\n/// Will get:\n/// ```md\n/// * List item 1\n/// * List item 2\n/// * <- cursor here\n/// ```\nexport const splitListItemCommand = $command(\n  'SplitListItem',\n  (ctx) => () => splitListItem(listItemSchema.type(ctx))\n)\n\nwithMeta(splitListItemCommand, {\n  displayName: 'Command<splitListItemCommand>',\n  group: 'ListItem',\n})\n\nfunction liftFirstListItem(ctx: Ctx): Command {\n  return (state, dispatch, view) => {\n    const { selection } = state\n    if (!(selection instanceof TextSelection)) return false\n\n    const { empty, $from } = selection\n\n    // selection should be empty and at the start of the node\n    if (!empty || $from.parentOffset !== 0) return false\n\n    const parentItem = $from.node(-1)\n    // selection should be in list item and list item should be the first child of the list\n    if (\n      parentItem.type !== listItemSchema.type(ctx) ||\n      parentItem.firstChild !== $from.node()\n    )\n      return false\n\n    const list = $from.node(-2)\n    // list should have only one list item\n    if (list.childCount > 1) return false\n\n    return liftListItem(listItemSchema.type(ctx))(state, dispatch, view)\n  }\n}\n\n/// The command to remove list item **only if**:\n///\n/// - Selection is at the start of the list item.\n/// - List item is the only child of the list.\n///\n/// Most of the time, you shouldn't use this command directly.\nexport const liftFirstListItemCommand = $command(\n  'LiftFirstListItem',\n  (ctx) => () => liftFirstListItem(ctx)\n)\n\nwithMeta(liftFirstListItemCommand, {\n  displayName: 'Command<liftFirstListItemCommand>',\n  group: 'ListItem',\n})\n\n/// Keymap for list item node.\n/// - `<Enter>`: Split the current list item.\n/// - `<Tab>/<Mod-]>`: Sink the current list item.\n/// - `<Shift-Tab>/<Mod-[>`: Lift the current list item.\nexport const listItemKeymap = $useKeymap('listItemKeymap', {\n  NextListItem: {\n    shortcuts: 'Enter',\n    command: (ctx) => {\n      const commands = ctx.get(commandsCtx)\n      return () => commands.call(splitListItemCommand.key)\n    },\n  },\n  SinkListItem: {\n    shortcuts: ['Tab', 'Mod-]'],\n    command: (ctx) => {\n      const commands = ctx.get(commandsCtx)\n      return () => commands.call(sinkListItemCommand.key)\n    },\n  },\n  LiftListItem: {\n    shortcuts: ['Shift-Tab', 'Mod-['],\n    command: (ctx) => {\n      const commands = ctx.get(commandsCtx)\n      return () => commands.call(liftListItemCommand.key)\n    },\n  },\n  LiftFirstListItem: {\n    shortcuts: ['Backspace', 'Delete'],\n    command: (ctx) => {\n      const commands = ctx.get(commandsCtx)\n      return () => commands.call(liftFirstListItemCommand.key)\n    },\n  },\n})\n\nwithMeta(listItemKeymap.ctx, {\n  displayName: 'KeymapCtx<listItem>',\n  group: 'ListItem',\n})\n\nwithMeta(listItemKeymap.shortcuts, {\n  displayName: 'Keymap<listItem>',\n  group: 'ListItem',\n})\n", "import { $node } from '@milkdown/utils'\n\nimport { withMeta } from '../__internal__'\n\n/// The bottom-level node.\nexport const textSchema = $node('text', () => ({\n  group: 'inline',\n  parseMarkdown: {\n    match: ({ type }) => type === 'text',\n    runner: (state, node) => {\n      state.addText(node.value as string)\n    },\n  },\n  toMarkdown: {\n    match: (node) => node.type.name === 'text',\n    runner: (state, node) => {\n      state.addNode('text', undefined, node.text as string)\n    },\n  },\n}))\n\nwithMeta(textSchema, {\n  displayName: 'NodeSchema<text>',\n  group: 'Text',\n})\n", "import { $nodeAttr, $nodeSchema } from '@milkdown/utils'\n\nimport { withMeta } from '../__internal__'\n\nexport const htmlAttr = $nodeAttr('html')\n\nwithMeta(htmlAttr, {\n  displayName: 'Attr<html>',\n  group: 'Html',\n})\n\nexport const htmlSchema = $nodeSchema('html', (ctx) => {\n  return {\n    atom: true,\n    group: 'inline',\n    inline: true,\n    attrs: {\n      value: {\n        default: '',\n        validate: 'string',\n      },\n    },\n    toDOM: (node) => {\n      const span = document.createElement('span')\n      const attr = {\n        ...ctx.get(htmlAttr.key)(node),\n        'data-value': node.attrs.value,\n        'data-type': 'html',\n      }\n      span.textContent = node.attrs.value\n      return ['span', attr, node.attrs.value]\n    },\n    parseDOM: [\n      {\n        tag: 'span[data-type=\"html\"]',\n        getAttrs: (dom) => {\n          return {\n            value: dom.dataset.value ?? '',\n          }\n        },\n      },\n    ],\n    parseMarkdown: {\n      match: ({ type }) => Boolean(type === 'html'),\n      runner: (state, node, type) => {\n        state.addNode(type, { value: node.value as string })\n      },\n    },\n    toMarkdown: {\n      match: (node) => node.type.name === 'html',\n      runner: (state, node) => {\n        state.addNode('html', undefined, node.attrs.value)\n      },\n    },\n  }\n})\n\nwithMeta(htmlSchema.node, {\n  displayName: 'NodeSchema<html>',\n  group: 'Html',\n})\n\nwithMeta(htmlSchema.ctx, {\n  displayName: 'NodeSchemaCtx<html>',\n  group: 'Html',\n})\n", "import type { MilkdownPlugin } from '@milkdown/ctx'\n\nimport {\n  emphasisAttr,\n  emphasisSchema,\n  inlineCodeAttr,\n  inlineCodeSchema,\n  linkAttr,\n  linkSchema,\n  strongAttr,\n  strongSchema,\n} from '../mark'\nimport {\n  blockquoteAttr,\n  blockquoteSchema,\n  bulletListAttr,\n  bulletListSchema,\n  codeBlockAttr,\n  codeBlockSchema,\n  docSchema,\n  hardbreakAttr,\n  hardbreakSchema,\n  headingAttr,\n  headingIdGenerator,\n  headingSchema,\n  hrAttr,\n  hrSchema,\n  htmlAttr,\n  htmlSchema,\n  imageAttr,\n  imageSchema,\n  listItemAttr,\n  listItemSchema,\n  orderedListAttr,\n  orderedListSchema,\n  paragraphAttr,\n  paragraphSchema,\n  textSchema,\n} from '../node'\n\n/// @internal\nexport const schema: MilkdownPlugin[] = [\n  docSchema,\n\n  paragraphAttr,\n  paragraphSchema,\n\n  headingIdGenerator,\n  headingAttr,\n  headingSchema,\n\n  hardbreakAttr,\n  hardbreakSchema,\n\n  blockquoteAttr,\n  blockquoteSchema,\n\n  codeBlockAttr,\n  codeBlockSchema,\n\n  hrAttr,\n  hrSchema,\n\n  imageAttr,\n  imageSchema,\n\n  bulletListAttr,\n  bulletListSchema,\n\n  orderedListAttr,\n  orderedListSchema,\n\n  listItemAttr,\n  listItemSchema,\n\n  emphasisAttr,\n  emphasisSchema,\n\n  strongAttr,\n  strongSchema,\n\n  inlineCodeAttr,\n  inlineCodeSchema,\n\n  linkAttr,\n  linkSchema,\n\n  htmlAttr,\n  htmlSchema,\n\n  textSchema,\n].flat()\n", "import type { MilkdownPlugin } from '@milkdown/ctx'\n\nimport {\n  emphasisStarInputRule,\n  emphasisUnderscoreInputRule,\n  inlineCodeInputRule,\n  strongInputRule,\n} from '../mark'\nimport {\n  createCodeBlockInputRule,\n  insertHrInputRule,\n  wrapInBlockquoteInputRule,\n  wrapInBulletListInputRule,\n  wrapInHeadingInputRule,\n  wrapInOrderedListInputRule,\n} from '../node'\n\n/// @internal\nexport const inputRules: MilkdownPlugin[] = [\n  wrapInBlockquoteInputRule,\n  wrapInBulletListInputRule,\n  wrapInOrderedListInputRule,\n  createCodeBlockInputRule,\n  insertHrInputRule,\n  wrapInHeadingInputRule,\n].flat()\n\n/// @internal\nexport const markInputRules: MilkdownPlugin[] = [\n  emphasisStarInputRule,\n  emphasisUnderscoreInputRule,\n  inlineCodeInputRule,\n  strongInputRule,\n]\n", "import type { MilkdownPlugin } from '@milkdown/ctx'\n\nimport {\n  toggleEmphasisCommand,\n  toggleInlineCodeCommand,\n  toggleLinkCommand,\n  toggleStrongCommand,\n  updateLinkCommand,\n} from '../mark'\nimport {\n  createCodeBlockCommand,\n  downgradeHeadingCommand,\n  insertHardbreakCommand,\n  insertHrCommand,\n  insertImageCommand,\n  liftFirstListItemCommand,\n  liftListItemCommand,\n  sinkListItemCommand,\n  splitListItemCommand,\n  turnIntoTextCommand,\n  updateImageCommand,\n  wrapInBlockquoteCommand,\n  wrapInBulletListCommand,\n  wrapInHeadingCommand,\n  wrapInOrderedListCommand,\n} from '../node'\n\n/// @internal\nexport const commands: MilkdownPlugin[] = [\n  turnIntoTextCommand,\n  wrapInBlockquoteCommand,\n  wrapInHeadingCommand,\n  downgradeHeadingCommand,\n  createCodeBlockCommand,\n  insertHardbreakCommand,\n  insertHrCommand,\n\n  insertImageCommand,\n  updateImageCommand,\n\n  wrapInOrderedListCommand,\n  wrapInBulletListCommand,\n  sinkListItemCommand,\n  splitListItemCommand,\n  liftListItemCommand,\n  liftFirstListItemCommand,\n\n  toggleEmphasisCommand,\n  toggleInlineCodeCommand,\n  toggleStrongCommand,\n\n  toggleLinkCommand,\n  updateLinkCommand,\n]\n", "import type { MilkdownPlugin } from '@milkdown/ctx'\n\nimport { emphasisKeymap, inlineCodeKeymap, strongKeymap } from '../mark'\nimport {\n  blockquoteKeymap,\n  bulletListKeymap,\n  codeBlockKeymap,\n  hardbreakKeymap,\n  headingKeymap,\n  listItemKeymap,\n  orderedListKeymap,\n  paragraphKeymap,\n} from '../node'\n\n/// @internal\nexport const keymap: MilkdownPlugin[] = [\n  blockquoteKeymap,\n  codeBlockKeymap,\n  hardbreakKeymap,\n  headingKeymap,\n  listItemKeymap,\n  orderedListKeymap,\n  bulletListKeymap,\n  paragraphKeymap,\n\n  emphasisKeymap,\n  inlineCodeKeymap,\n  strongKeymap,\n].flat()\n", "import { $remark } from '@milkdown/utils'\nimport { visit } from 'unist-util-visit'\n\nimport { withMeta } from '../__internal__'\n\n/// This plugin is used to add order in list for remark AST.\nexport const remarkAddOrderInListPlugin = $remark(\n  'remarkAddOrderInList',\n  () => () => (tree) => {\n    visit(tree, 'list', (node) => {\n      if (node.ordered) {\n        const start = node.start ?? 1\n        node.children.forEach((child, index) => {\n          ;(child as unknown as Record<string, number>).label = index + start\n        })\n      }\n    })\n  }\n)\n\nwithMeta(remarkAddOrderInListPlugin.plugin, {\n  displayName: 'Remark<remarkAddOrderInListPlugin>',\n  group: 'Remark',\n})\n\nwithMeta(remarkAddOrderInListPlugin.options, {\n  displayName: 'RemarkConfig<remarkAddOrderInListPlugin>',\n  group: 'Remark',\n})\n", "import type { Node } from '@milkdown/transformer'\n\nimport { $remark } from '@milkdown/utils'\nimport { visit } from 'unist-util-visit'\n\nimport { withMeta } from '../__internal__'\n\n/// This plugin is used to add inline line break for remark AST.\n/// The inline line break should be treated as a `space`.\n/// And the normal line break should be treated as a `LF`.\nexport const remarkLineBreak = $remark(\n  'remarkLineBreak',\n  () => () => (tree: Node) => {\n    const find = /[\\t ]*(?:\\r?\\n|\\r)/g\n    visit(\n      tree,\n      'text',\n      (\n        node: Node & { value: string },\n        index: number,\n        parent: Node & { children: Node[] }\n      ) => {\n        if (!node.value || typeof node.value !== 'string') return\n\n        const result = []\n        let start = 0\n\n        find.lastIndex = 0\n\n        let match = find.exec(node.value)\n\n        while (match) {\n          const position = match.index\n\n          if (start !== position)\n            result.push({\n              type: 'text',\n              value: node.value.slice(start, position),\n            })\n\n          result.push({ type: 'break', data: { isInline: true } })\n          start = position + match[0].length\n          match = find.exec(node.value)\n        }\n\n        const hasResultAndIndex =\n          result.length > 0 && parent && typeof index === 'number'\n\n        if (!hasResultAndIndex) return\n\n        if (start < node.value.length)\n          result.push({ type: 'text', value: node.value.slice(start) })\n\n        parent.children.splice(index, 1, ...result)\n        return index + result.length\n      }\n    )\n  }\n)\n\nwithMeta(remarkLineBreak.plugin, {\n  displayName: 'Remark<remarkLineBreak>',\n  group: 'Remark',\n})\n\nwithMeta(remarkLineBreak.options, {\n  displayName: 'RemarkConfig<remarkLineBreak>',\n  group: 'Remark',\n})\n", "import { $remark } from '@milkdown/utils'\nimport remarkInlineLinks from 'remark-inline-links'\n\nimport { withMeta } from '../__internal__'\n\n/// This plugin wraps [remark-inline-links](https://github.com/remarkjs/remark-inline-links).\nexport const remarkInlineLinkPlugin = $remark(\n  'remarkInlineLink',\n  () => remarkInlineLinks\n)\n\nwithMeta(remarkInlineLinkPlugin.plugin, {\n  displayName: 'Remark<remarkInlineLinkPlugin>',\n  group: 'Remark',\n})\n\nwithMeta(remarkInlineLinkPlugin.options, {\n  displayName: 'RemarkConfig<remarkInlineLinkPlugin>',\n  group: 'Remark',\n})\n", "import type { Node } from '@milkdown/transformer'\n\nimport { $remark } from '@milkdown/utils'\n\nimport { withMeta } from '../__internal__'\n\nconst isParent = (node: Node): node is Node & { children: Node[] } =>\n  !!(node as Node & { children: Node[] }).children\nconst isHTML = (\n  node: Node\n): node is Node & { children: Node[]; value: unknown } => node.type === 'html'\n\nfunction flatMapWithDepth(\n  ast: Node,\n  fn: (node: Node, index: number, parent: Node | null) => Node[]\n) {\n  return transform(ast, 0, null)[0]\n\n  function transform(node: Node, index: number, parent: Node | null) {\n    if (isParent(node)) {\n      const out = []\n      for (let i = 0, n = node.children.length; i < n; i++) {\n        const nthChild = node.children[i]\n        if (nthChild) {\n          const xs = transform(nthChild, i, node)\n          if (xs) {\n            for (let j = 0, m = xs.length; j < m; j++) {\n              const item = xs[j]\n              if (item) out.push(item)\n            }\n          }\n        }\n      }\n      node.children = out\n    }\n\n    return fn(node, index, parent)\n  }\n}\n\n/// @internal\n/// This plugin should be deprecated after we support HTML.\nexport const remarkHtmlTransformer = $remark(\n  'remarkHTMLTransformer',\n  () => () => (tree: Node) => {\n    flatMapWithDepth(tree, (node, _index, parent) => {\n      if (!isHTML(node)) return [node]\n\n      if (parent?.type === 'root') {\n        node.children = [{ ...node }]\n        delete node.value\n        ;(node as { type: string }).type = 'paragraph'\n      }\n\n      return [node]\n    })\n  }\n)\n\nwithMeta(remarkHtmlTransformer.plugin, {\n  displayName: 'Remark<remarkHtmlTransformer>',\n  group: 'Remark',\n})\n\nwithMeta(remarkHtmlTransformer.options, {\n  displayName: 'RemarkConfig<remarkHtmlTransformer>',\n  group: 'Remark',\n})\n", "import type { Node } from '@milkdown/transformer'\n\nimport { $remark } from '@milkdown/utils'\nimport { visit } from 'unist-util-visit'\n\nimport { withMeta } from '../__internal__'\n\n/// This plugin is used to keep the marker (`_` and `*`) of emphasis and strong nodes.\nexport const remarkMarker = $remark(\n  'remarkMarker',\n  () => () => (tree, file) => {\n    const getMarker = (node: Node) => {\n      return (file.value as string).charAt(node.position!.start.offset!)\n    }\n    visit(\n      tree,\n      (node: Node) => ['strong', 'emphasis'].includes(node.type),\n      (node: Node) => {\n        ;(node as Node & { marker: string }).marker = getMarker(node)\n      }\n    )\n  }\n)\n\nwithMeta(remarkMarker.plugin, {\n  displayName: 'Remark<remarkMarker>',\n  group: 'Remark',\n})\n\nwithMeta(remarkMarker.options, {\n  displayName: 'RemarkConfig<remarkMarker>',\n  group: 'Remark',\n})\n", "import { Plugin, PluginKey } from '@milkdown/prose/state'\nimport { Decoration, DecorationSet } from '@milkdown/prose/view'\nimport { $prose } from '@milkdown/utils'\n\nimport { withMeta } from '../__internal__'\n\n/// This plugin is to solve the [chrome 98 bug](https://discuss.prosemirror.net/t/cursor-jumps-at-the-end-of-line-when-it-betweens-two-inline-nodes/4641).\nexport const inlineNodesCursorPlugin = $prose(() => {\n  let lock = false\n  const inlineNodesCursorPluginKey = new PluginKey(\n    'MILKDOWN_INLINE_NODES_CURSOR'\n  )\n  const inlineNodesCursorPlugin: Plugin = new Plugin({\n    key: inlineNodesCursorPluginKey,\n    state: {\n      init() {\n        return false\n      },\n      apply(tr) {\n        if (!tr.selection.empty) return false\n\n        const pos = tr.selection.$from\n        const left = pos.nodeBefore\n        const right = pos.nodeAfter\n        if (\n          left &&\n          right &&\n          left.isInline &&\n          !left.isText &&\n          right.isInline &&\n          !right.isText\n        )\n          return true\n\n        return false\n      },\n    },\n    props: {\n      handleDOMEvents: {\n        compositionend: (view, e) => {\n          if (lock) {\n            lock = false\n            requestAnimationFrame(() => {\n              const active = inlineNodesCursorPlugin.getState(view.state)\n              if (active) {\n                const from = view.state.selection.from\n                e.preventDefault()\n                view.dispatch(view.state.tr.insertText(e.data || '', from))\n              }\n            })\n\n            return true\n          }\n          return false\n        },\n        compositionstart: (view) => {\n          const active = inlineNodesCursorPlugin.getState(view.state)\n          if (active) lock = true\n\n          return false\n        },\n        beforeinput: (view, e) => {\n          const active = inlineNodesCursorPlugin.getState(view.state)\n          if (active && e instanceof InputEvent && e.data && !lock) {\n            const from = view.state.selection.from\n            e.preventDefault()\n            view.dispatch(view.state.tr.insertText(e.data || '', from))\n\n            return true\n          }\n\n          return false\n        },\n      },\n      decorations(state) {\n        const active = inlineNodesCursorPlugin.getState(state)\n        if (active) {\n          const pos = state.selection.$from\n          const position = pos.pos\n          const left = document.createElement('span')\n          const leftDec = Decoration.widget(position, left, {\n            side: -1,\n          })\n          const right = document.createElement('span')\n          const rightDec = Decoration.widget(position, right)\n          setTimeout(() => {\n            left.contentEditable = 'true'\n            right.contentEditable = 'true'\n          })\n          return DecorationSet.create(state.doc, [leftDec, rightDec])\n        }\n        return DecorationSet.empty\n      },\n    },\n  })\n\n  return inlineNodesCursorPlugin\n})\n\nwithMeta(inlineNodesCursorPlugin, {\n  displayName: 'Prose<inlineNodesCursorPlugin>',\n  group: 'Prose',\n})\n", "import { Plugin, PluginKey } from '@milkdown/prose/state'\nimport { AddMarkStep, ReplaceStep } from '@milkdown/prose/transform'\nimport { $prose } from '@milkdown/utils'\n\nimport { withMeta } from '../__internal__'\nimport { hardbreakSchema } from '../node'\n\n/// This plugin is used to clear the marks around the hardbreak node.\nexport const hardbreakClearMarkPlugin = $prose((ctx) => {\n  return new Plugin({\n    key: new PluginKey('MILKDOWN_HARDBREAK_MARKS'),\n    appendTransaction: (trs, _oldState, newState) => {\n      if (!trs.length) return\n\n      const [tr] = trs\n      if (!tr) return\n\n      const [step] = tr.steps\n\n      const isInsertHr = tr.getMeta('hardbreak')\n      if (isInsertHr) {\n        if (!(step instanceof ReplaceStep)) return\n\n        const { from } = step as unknown as { from: number }\n        return newState.tr.setNodeMarkup(\n          from,\n          hardbreakSchema.type(ctx),\n          undefined,\n          []\n        )\n      }\n\n      const isAddMarkStep = step instanceof AddMarkStep\n      if (isAddMarkStep) {\n        let _tr = newState.tr\n        const { from, to } = step as unknown as { from: number; to: number }\n        newState.doc.nodesBetween(from, to, (node, pos) => {\n          if (node.type === hardbreakSchema.type(ctx))\n            _tr = _tr.setNodeMarkup(\n              pos,\n              hardbreakSchema.type(ctx),\n              undefined,\n              []\n            )\n        })\n\n        return _tr\n      }\n\n      return undefined\n    },\n  })\n})\n\nwithMeta(hardbreakClearMarkPlugin, {\n  displayName: 'Prose<hardbreakClearMarkPlugin>',\n  group: 'Prose',\n})\n", "import { Plugin, PluginKey } from '@milkdown/prose/state'\nimport { $ctx, $prose } from '@milkdown/utils'\n\nimport { withMeta } from '../__internal__'\n\n/// This slice contains the nodes that within which the hardbreak will be ignored.\nexport const hardbreakFilterNodes = $ctx(\n  ['table', 'code_block'],\n  'hardbreakFilterNodes'\n)\n\nwithMeta(hardbreakFilterNodes, {\n  displayName: 'Ctx<hardbreakFilterNodes>',\n  group: 'Prose',\n})\n\n/// This plugin is used to filter the hardbreak node.\n/// If the hardbreak is going to be inserted within a node that is in the `hardbreakFilterNodes`, ignore it.\nexport const hardbreakFilterPlugin = $prose((ctx) => {\n  const notIn = ctx.get(hardbreakFilterNodes.key)\n  return new Plugin({\n    key: new PluginKey('MILKDOWN_HARDBREAK_FILTER'),\n    filterTransaction: (tr, state) => {\n      const isInsertHr = tr.getMeta('hardbreak')\n      const [step] = tr.steps\n      if (isInsertHr && step) {\n        const { from } = step as unknown as { from: number }\n        const $from = state.doc.resolve(from)\n        let curDepth = $from.depth\n        let canApply = true\n        while (curDepth > 0) {\n          if (notIn.includes($from.node(curDepth).type.name)) canApply = false\n\n          curDepth--\n        }\n        return canApply\n      }\n      return true\n    },\n  })\n})\n\nwithMeta(hardbreakFilterPlugin, {\n  displayName: 'Prose<hardbreakFilterPlugin>',\n  group: 'Prose',\n})\n", "import type { EditorView } from '@milkdown/prose/view'\n\nimport { Plugin, PluginKey } from '@milkdown/prose/state'\nimport { $prose } from '@milkdown/utils'\n\nimport { withMeta } from '../__internal__'\nimport { headingIdGenerator, headingSchema } from '../node/heading'\n\n/// This plugin is used to sync the heading id when the heading content changes.\n/// It will use the `headingIdGenerator` to generate the id.\nexport const syncHeadingIdPlugin = $prose((ctx) => {\n  const headingIdPluginKey = new PluginKey('MILKDOWN_HEADING_ID')\n\n  const updateId = (view: EditorView) => {\n    if (view.composing) return\n\n    const getId = ctx.get(headingIdGenerator.key)\n    const tr = view.state.tr.setMeta('addToHistory', false)\n\n    let found = false\n    const idMap: Record<string, number> = {}\n\n    view.state.doc.descendants((node, pos) => {\n      if (node.type === headingSchema.type(ctx)) {\n        if (node.textContent.trim().length === 0) return\n\n        const attrs = node.attrs\n        let id = getId(node)\n        if (idMap[id]) {\n          idMap[id]! += 1\n          id += `-#${idMap[id]}`\n        } else {\n          idMap[id] = 1\n        }\n\n        if (attrs.id !== id) {\n          found = true\n          tr.setMeta(headingIdPluginKey, true).setNodeMarkup(pos, undefined, {\n            ...attrs,\n            id,\n          })\n        }\n      }\n    })\n\n    if (found) view.dispatch(tr)\n  }\n\n  return new Plugin({\n    key: headingIdPluginKey,\n    view: (view) => {\n      updateId(view)\n\n      return {\n        update: (view, prevState) => {\n          if (view.state.doc.eq(prevState.doc)) return\n          updateId(view)\n        },\n      }\n    },\n  })\n})\n\nwithMeta(syncHeadingIdPlugin, {\n  displayName: 'Prose<syncHeadingIdPlugin>',\n  group: 'Prose',\n})\n", "import type { EditorView } from '@milkdown/prose/view'\n\nimport { Plugin, PluginKey } from '@milkdown/prose/state'\nimport { $prose } from '@milkdown/utils'\n\nimport { withMeta } from '../__internal__'\nimport { bulletListSchema } from '../node'\nimport { listItemSchema } from '../node/list-item'\nimport { orderedListSchema } from '../node/ordered-list'\n\n/// This plugin is used to keep the label of list item up to date in ordered list.\nexport const syncListOrderPlugin = $prose((ctx) => {\n  const syncOrderLabel = (view: EditorView) => {\n    if (view.composing || !view.editable) return\n\n    const orderedListType = orderedListSchema.type(ctx)\n    const bulletListType = bulletListSchema.type(ctx)\n    const listItemType = listItemSchema.type(ctx)\n    const state = view.state\n    const handleNodeItem = (\n      attrs: Record<string, any>,\n      index: number\n    ): boolean => {\n      let changed = false\n      const expectedLabel = `${index + 1}.`\n      if (attrs.label !== expectedLabel) {\n        attrs.label = expectedLabel\n        changed = true\n      }\n\n      return changed\n    }\n\n    let tr = state.tr\n    let needDispatch = false\n    state.doc.descendants((node, pos, parent, index) => {\n      if (node.type === bulletListType) {\n        const base = node.maybeChild(0)\n        if (base?.type === listItemType && base.attrs.listType === 'ordered') {\n          needDispatch = true\n          tr.setNodeMarkup(pos, orderedListType, { spread: 'true' })\n\n          node.descendants((child, pos, _parent, index) => {\n            if (child.type === listItemType) {\n              const attrs = { ...child.attrs }\n              const changed = handleNodeItem(attrs, index)\n              if (changed) tr = tr.setNodeMarkup(pos, undefined, attrs)\n            }\n            return false\n          })\n        }\n      } else if (\n        node.type === listItemType &&\n        parent?.type === orderedListType\n      ) {\n        const attrs = { ...node.attrs }\n        let changed = false\n        if (attrs.listType !== 'ordered') {\n          attrs.listType = 'ordered'\n          changed = true\n        }\n\n        const base = parent?.maybeChild(0)\n        if (base) changed = handleNodeItem(attrs, index)\n\n        if (changed) {\n          tr = tr.setNodeMarkup(pos, undefined, attrs)\n          needDispatch = true\n        }\n      }\n    })\n\n    if (needDispatch) view.dispatch(tr.setMeta('addToHistory', false))\n  }\n  return new Plugin({\n    key: new PluginKey('MILKDOWN_KEEP_LIST_ORDER'),\n    view: (view) => {\n      syncOrderLabel(view)\n      return {\n        update: (view) => {\n          syncOrderLabel(view)\n        },\n      }\n    },\n  })\n})\n\nwithMeta(syncListOrderPlugin, {\n  displayName: 'Prose<syncListOrderPlugin>',\n  group: 'Prose',\n})\n", "import type { MilkdownPlugin } from '@milkdown/ctx'\n\nimport {\n  hardbreakClearMarkPlugin,\n  hardbreakFilterNodes,\n  hardbreakFilterPlugin,\n  inlineNodesCursorPlugin,\n  remarkAddOrderInListPlugin,\n  remarkHtmlTransformer,\n  remarkInlineLinkPlugin,\n  remarkLineBreak,\n  remarkMarker,\n  remarkPreserveEmptyLinePlugin,\n  syncHeadingIdPlugin,\n  syncListOrderPlugin,\n} from '../plugin'\n\n/// @internal\nexport const plugins: MilkdownPlugin[] = [\n  hardbreakClearMarkPlugin,\n  hardbreakFilterNodes,\n  hardbreakFilterPlugin,\n\n  inlineNodesCursorPlugin,\n\n  remarkAddOrderInListPlugin,\n  remarkInlineLinkPlugin,\n  remarkLineBreak,\n  remarkHtmlTransformer,\n  remarkMarker,\n  remarkPreserveEmptyLinePlugin,\n\n  syncHeadingIdPlugin,\n  syncListOrderPlugin,\n].flat()\n", "import type { MilkdownPlugin } from '@milkdown/ctx'\n\nimport {\n  commands,\n  inputRules,\n  keymap,\n  markInputRules,\n  plugins,\n  schema,\n} from './composed'\n\nexport * from './node'\nexport * from './mark'\nexport * from './plugin'\nexport * from './composed'\n\n/// The commonmark preset, includes all the plugins.\nexport const commonmark: MilkdownPlugin[] = [\n  schema,\n  inputRules,\n  markInputRules,\n  commands,\n  keymap,\n  plugins,\n].flat()\n"],
  "mappings": "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",
  "names": ["tr", "node", "definition", "commands", "shouldPreserveEmptyLine", "inlineNodesCursorPlugin", "view", "pos", "index"]
}
